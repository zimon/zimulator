           ================ SmallProf version 2.02 ================
                    Profile of ../modules/Configuration.pm             Page 1
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:# Package: Configuration
        0   0.00000   0.00000     2:#
        0   0.00000   0.00000     3:# Here are all Options defined. If a
        0   0.00000   0.00000     4:#
        0   0.00000   0.00000     5:# This class implements the singleton pattern
        0   0.00000   0.00000     6:package Configuration;
        0   0.00000   0.00000     7:use strict;
        0   0.00000   0.00000     8:use warnings;
        0   0.00000   0.00000     9:use lib ".";
        0   0.00000   0.00000    10:use File;
        0   0.00000   0.00000    11:
        0   0.00000   0.00000    12:##
        0   0.00000   0.00000    13:# VARIABLES: Member variables
        0   0.00000   0.00000    14:# Options can be stored with any option name
        0   0.00000   0.00000    15:#
        0   0.00000   0.00000    16:# configurationfile - file object of the
        0   0.00000   0.00000    17:#
        0   0.00000   0.00000    18:# For all default options that are set, see
        0   0.00000   0.00000    19:
        0   0.00000   0.00000    20:##
        0   0.00000   0.00000    21:# VARIABLE: $configurationInstance
        0   0.00000   0.00000    22:# The only object of this class
        0   0.00000   0.00000    23:my $configurationInstance;
        0   0.00000   0.00000    24:
        0   0.00000   0.00000    25:##
        0   0.00000   0.00000    26:# Returns the only instance of this class
        0   0.00000   0.00000    27:#
        0   0.00000   0.00000    28:# This function implements a singleton
        0   0.00000   0.00000    29:sub instance {#{{{
       83   0.00000   0.00000    30:    my $object = shift;
       83   0.00000   0.00000    31:    return ($configurationInstance) ?
        0   0.00000   0.00000    32:}#}}}
        0   0.00000   0.00000    33:
        0   0.00000   0.00000    34:##
        0   0.00000   0.00000    35:# *Contructor*
        0   0.00000   0.00000    36:#
        0   0.00000   0.00000    37:# PARAMETERS:
        0   0.00000   0.00000    38:# $configurationFileName - (optional) path to
        0   0.00000   0.00000    39:sub new {#{{{
        1   0.00000   0.00000    40:    my $object = shift;
        1   0.00000   0.00000    41:    my $configurationFileName = shift;
        1   0.00000   0.00000    42:    my $reference = {};
        1   0.00000   0.00000    43:    $configurationInstance =
        0   0.00000   0.00000    44:
        1   0.00000   0.00000    45:    $reference->{CONFIGURATIONFILE} =new
        1   0.00000   0.00000    46:    $reference->_setDefaults();
        1   0.00000   0.00000    47:    if($configurationFileName){
        0   0.00000   0.00000    48:        $reference->_readConfigFile();
        0   0.00000   0.00000    49:    }
        1   0.00000   0.00000    50:    return($reference);
        0   0.00000   0.00000    51:}#}}}
        0   0.00000   0.00000    52:
        0   0.00000   0.00000    53:##
        0   0.00000   0.00000    54:# Sets an option
        0   0.00000   0.00000    55:#
        0   0.00000   0.00000    56:# PARAMETERS:
           ================ SmallProf version 2.02 ================
                    Profile of ../modules/Configuration.pm             Page 2
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000    57:# $option - the option to be set (key)
        0   0.00000   0.00000    58:# $value - the value to be set for $option
        0   0.00000   0.00000    59:sub setOption {#{{{
        0   0.00000   0.00000    60:    my $object = shift;
        0   0.00000   0.00000    61:    my $option = shift;
        0   0.00000   0.00000    62:    my $value = shift;
        0   0.00000   0.00000    63:    die "option not defined in setOption\n"
        0   0.00000   0.00000    64:    $value = 0 if not defined $value;
        0   0.00000   0.00000    65:    $object->{$option} = $value;
        0   0.00000   0.00000    66:}#}}}
        0   0.00000   0.00000    67:
        0   0.00000   0.00000    68:##
        0   0.00000   0.00000    69:# Returns the value for a given option
        0   0.00000   0.00000    70:#
        0   0.00000   0.00000    71:# PARAMETERS:
        0   0.00000   0.00000    72:# $option - option to return value to
        0   0.00000   0.00000    73:sub getOption {#{{{
    11762   0.00169   0.08000    74:    my $object = shift;
    11762   0.00148   0.09000    75:    my $option = shift;
    11762   0.00033   0.14000    76:    die "option not defined in getOption\n"
    11762   0.00138   0.14000    77:    return $object->{$option};
        0   0.00000   0.00000    78:}#}}}
        0   0.00000   0.00000    79:
        0   0.00000   0.00000    80:
        0   0.00000   0.00000    81:
        0   0.00000   0.00000    82:##
        0   0.00000   0.00000    83:# Reads all values from configuration file
        0   0.00000   0.00000    84:sub _readConfigFile {#{{{
        0   0.00000   0.00000    85:    my $object = shift;
        0   0.00000   0.00000    86:    my $configFile = $object->{CONFIGFILE};
        0   0.00000   0.00000    87:    my @lines = $configFile->getLineArray();
        0   0.00000   0.00000    88:    foreach my $line (@lines) {
        0   0.00000   0.00000    89:        my ($option,$value) = $line =~
        0   0.00000   0.00000    90:        $object->setOption($option,$value);
        0   0.00000   0.00000    91:    }
        0   0.00000   0.00000    92:}#}}}
        0   0.00000   0.00000    93:
        0   0.00000   0.00000    94:##
        0   0.00000   0.00000    95:# Sets all default options
        0   0.00000   0.00000    96:sub _setDefaults {#{{{
        1   0.00000   0.00000    97:    my $object = shift;
        0   0.00000   0.00000    98:
        0   0.00000   0.00000    99:#{{{
        0   0.00000   0.00000   100:# Constants: VNUML XML-file constants
        0   0.00000   0.00000   101:#
        0   0.00000   0.00000   102:# Constants used for creating xml-files
        0   0.00000   0.00000   103:#
        0   0.00000   0.00000   104:# DTDPATH - path to dtd file
        0   0.00000   0.00000   105:# SSH_KEY - path to public ssh key to use for
        0   0.00000   0.00000   106:# MANAGEMENT_NET - net to take management
        0   0.00000   0.00000   107:# MANAGEMENT_NETMASK - netmask for the
        0   0.00000   0.00000   108:# MANAGEMENT_NET_OFFSET - offset to add to
        0   0.00000   0.00000   109:# VM_DEFAULTS - attributes for tag
        0   0.00000   0.00000   110:# FILESYSTEM - path to filesystem to use for
        0   0.00000   0.00000   111:# KERNEL - path to kernel to use for
        0   0.00000   0.00000   112:# NET_MODE - type of net to use (standard is
           ================ SmallProf version 2.02 ================
                    Profile of ../modules/Configuration.pm             Page 3
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   113:# ZEBRA_PATH - path to zebra daemon in
        0   0.00000   0.00000   114:# RIPD_PATH - path to rip daemon in
        0   0.00000   0.00000   115:# OSPF_PATH - path to ospf daemon in
        1   0.00000   0.00000   116:    $object->{DTDPATH} =
        1   0.00000   0.00000   117:    $object->{SSH_KEY} =
        1   0.00000   0.00000   118:    $object->{MANAGEMENT_NET} =
        1   0.00000   0.00000   119:    $object->{MANAGEMENT_NETMASK} = '24';
        1   0.00000   0.00000   120:    $object->{MANAGEMENT_NET_OFFSET} = '100';
        1   0.00000   0.00000   121:    $object->{VM_DEFAULTS} = "
        1   0.00000   0.00000   122:    $object->{FILESYSTEM} =
        1   0.00000   0.00000   123:    $object->{KERNEL} =
        1   0.00000   0.00000   124:    $object->{NET_MODE} = "virtual_bridge";
        1   0.00000   0.00000   125:    $object->{ZEBRA_PATH} =
        1   0.00000   0.00000   126:    $object->{RIPD_PATH} = "/usr/lib/quagga";
        1   0.00000   0.00000   127:    $object->{OSPF_PATH} =
        0   0.00000   0.00000   128:
        0   0.00000   0.00000   129:#{{{
        0   0.00000   0.00000   130:# Constants: VNUML execution configuration
        0   0.00000   0.00000   131:#
        0   0.00000   0.00000   132:# VNUML_PATH - path to VNUML binary (only
        0   0.00000   0.00000   133:# VNUML_START_PARAMETERS - parameters to give
        0   0.00000   0.00000   134:# VNUML_EXEC_PARAMETERS - parameters to give
        0   0.00000   0.00000   135:# VNUML_STOP_PARAMETERS - parameters to give
        1   0.00000   0.00000   136:    $object->{VNUML_PATH} = '/usr/local/bin';
        1   0.00000   0.00000   137:    $object->{VNUML_START_PARAMETERS} = '-w
        1   0.00000   0.00000   138:    $object->{VNUML_EXEC_PARAMETERS} = '-x';
        1   0.00000   0.00000   139:    $object->{VNUML_STOP_PARAMETERS} = '-
        0   0.00000   0.00000   140:
        0   0.00000   0.00000   141:#{{{
        0   0.00000   0.00000   142:# Constants: Misc
        0   0.00000   0.00000   143:#
        0   0.00000   0.00000   144:# MAXFAIL_DEFAULT - maximum number of
        0   0.00000   0.00000   145:# MAXRUN_DEFAULT - maximum number of runs if
        0   0.00000   0.00000   146:# LOGFILE - file to store VNUML output to
        0   0.00000   0.00000   147:# RAW_TCPDUMP - set 1 to store tcpdumps in
        0   0.00000   0.00000   148:# VISUALIZE_NET_NAMES - set 1 to show names
        0   0.00000   0.00000   149:# CREATEGRAPHIMAGE - set 1 to generate a png
        1   0.00000   0.00000   150:    $object->{MAXFAIL_DEFAULT} = 5;
        1   0.00000   0.00000   151:    $object->{MAXRUN_DEFAULT} = 15;
        1   0.00000   0.00000   152:    $object->{LOGFILE} = 'logfile.log';
        1   0.00000   0.00000   153:    $object->{RAW_TCPDUMP} = 0;
        1   0.00000   0.00000   154:    $object->{VISUALIZE_NET_NAMES} = 1;
        1   0.00000   0.00000   155:    $object->{CREATEGRAPHIMAGE} = 1;
        1   0.00000   0.00000   156:    $object->{TIMEOUT_TIMER} = 30;
        1   0.00000   0.00000   157:    $object->{GARBAGE_TIMER} = 20;
        0   0.00000   0.00000   158:#}}}
        0   0.00000   0.00000   159:
        0   0.00000   0.00000   160:}#}}}
        0   0.00000   0.00000   161:
        0   0.00000   0.00000   162:1;
        0   0.00000   0.00000   163:
        0   0.00000   0.00000   164:
        0   0.00000   0.00000   165:
        0   0.00000   0.00000   166:# for a better use with vim. All the
        0   0.00000   0.00000   167:# vim: foldmethod=marker
           ================ SmallProf version 2.02 ================
                         Profile of ../modules/File.pm                 Page 4
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:# Package: File
        0   0.00000   0.00000     2:#
        0   0.00000   0.00000     3:# Provides a class to handle a file
        0   0.00000   0.00000     4:#
        0   0.00000   0.00000     5:# Files are splittet into a line array and a
        0   0.00000   0.00000     6:#
        0   0.00000   0.00000     7:# The line array contains all the main
        0   0.00000   0.00000     8:#
        0   0.00000   0.00000     9:# The comments array contains all comments
        0   0.00000   0.00000    10:#
        0   0.00000   0.00000    11:# This class implements an iterator pattern
        0   0.00000   0.00000    12:
        0   0.00000   0.00000    13:package File;
        0   0.00000   0.00000    14:
        0   0.00000   0.00000    15:use warnings;
        0   0.00000   0.00000    16:use strict;
        0   0.00000   0.00000    17:
        0   0.00000   0.00000    18:use lib ".";
        0   0.00000   0.00000    19:use Configuration;
        0   0.00000   0.00000    20:
        0   0.00000   0.00000    21:##
        0   0.00000   0.00000    22:# VARIABLES: Member variables
        0   0.00000   0.00000    23:# lines - array of lines that contain main
        0   0.00000   0.00000    24:# comments - array of lines that contain
        0   0.00000   0.00000    25:# linepointer - integer that holds the index
        0   0.00000   0.00000    26:# path - the path to the file includes
        0   0.00000   0.00000    27:# directory - the location of the file
        0   0.00000   0.00000    28:# filename - name of the file includes
        0   0.00000   0.00000    29:# name - name of the file without filetype
        0   0.00000   0.00000    30:# filtype - type of the file
        0   0.00000   0.00000    31:
        0   0.00000   0.00000    32:##
        0   0.00000   0.00000    33:# *Constructor*
        0   0.00000   0.00000    34:#
        0   0.00000   0.00000    35:# PARAMETERS:
        0   0.00000   0.00000    36:# $pathToFile - path to the file represented
        0   0.00000   0.00000    37:sub new {#{{{
       67   0.00000   0.00000    38:    my $object = shift;
       67   0.00001   0.00000    39:    my $pathToFile = shift;
       67   0.00000   0.00000    40:    my $reference = {};
       67   0.00113   0.00000    41:    bless($reference,$object);
        0   0.00000   0.00000    42:
       67   0.00000   0.00000    43:    $pathToFile = "-" if not $pathToFile;
       67   0.00000   0.00000    44:    chomp $pathToFile;
       67   0.00000   0.00000    45:    $reference->setPath($pathToFile);
       67   0.00000   0.00000    46:    return 0 if not $reference->readFile();
        0   0.00000   0.00000    47:
       67   0.00000   0.00000    48:    return($reference);
        0   0.00000   0.00000    49:}#}}}
        0   0.00000   0.00000    50:
        0   0.00000   0.00000    51:
        0   0.00000   0.00000    52:##
        0   0.00000   0.00000    53:# Reads file into an array of lines and an
        0   0.00000   0.00000    54:sub readFile {#{{{
       67   0.00000   0.00000    55:    my $object = shift;
        0   0.00000   0.00000    56:    #return 0 if not -f $object->{FILENAME};
           ================ SmallProf version 2.02 ================
                         Profile of ../modules/File.pm                 Page 5
       =================================================================
    count wall tm  cpu time line
       67   0.00000   0.00000    57:    my $config = Configuration::instance();
       67   0.00000   0.00000    58:    my @content = ();
       67   0.00000   0.00000    59:    my @comments = ();
       67   0.00000   0.00000    60:    my $path = $object->{PATH};
       67   0.00000   0.00000    61:    my @lines = ();
       67   0.00000   0.00000    62:    my $ok = 0;
       67   0.00001   0.00000    63:    if($path ne "-" and -f $path) {
       66   0.00001   0.01000    64:        if($path =~ /\.dump$/ and $config-
        0   0.00000   0.00000    65:            my $file = $object->{PATH};
        0   0.00000   0.00000    66:            @lines = `tcpdump -s 0 -x -l -r
        0   0.00000   0.00000    67:        } else {
       66   0.00047   0.00000    68:            open(FILE,"<".$path) or return 0;
       66   0.04719   0.02000    69:            @lines = <FILE> or return 0;
       66   0.00001   0.00000    70:            close(FILE);
        0   0.00000   0.00000    71:        }
       66   0.00477   0.00000    72:        map(chomp,@lines);
       66   0.04445   0.02000    73:        @content = grep(/^[a-zA-Z0-9_
       66   0.00899   0.02000    74:        @comments = grep(/^[^a-zA-Z0-9_
        0   0.00000   0.00000    75:    }
       67   0.00000   0.00000    76:    $object->{LINES} = \@content;
       67   0.00000   0.00000    77:    $object->{COMMENTS} = \@comments;
       67   0.00050   0.00000    78:    $object->{LINEPOINTER} = 0;
       67   0.00112   0.00000    79:    @lines = undef;
       67   0.00000   0.00000    80:    return 1;
        0   0.00000   0.00000    81:}#}}}
        0   0.00000   0.00000    82:
        0   0.00000   0.00000    83:##
        0   0.00000   0.00000    84:# Deletes all lines of the file that are
        0   0.00000   0.00000    85:sub filterFile {#{{{
       12   0.00000   0.00000    86:    my $object = shift;
       12   0.00004   0.00000    87:    my @lines = @{$object->{LINES}};
       12   0.00012   0.00000    88:    my @content = grep(/^[a-zA-Z0-9_
       12   0.00000   0.00000    89:    $object->{LINES} = \@content;
       12   0.00000   0.00000    90:    @lines = undef;
        0   0.00000   0.00000    91:}#}}}
        0   0.00000   0.00000    92:
        0   0.00000   0.00000    93:##
        0   0.00000   0.00000    94:# Write array of lines to file
        0   0.00000   0.00000    95:sub writeFile {#{{{
        0   0.00000   0.00000    96:    my $object = shift;
        0   0.00000   0.00000    97:    my $fileName = $object->{PATH};
        0   0.00000   0.00000    98:    my @lines = @{$object->{LINES}};
        0   0.00000   0.00000    99:    my @comments = @{$object->{COMMENTS}};
        0   0.00000   0.00000   100:
        0   0.00000   0.00000   101:    if($fileName eq "-"){
        0   0.00000   0.00000   102:        $object->print();
        0   0.00000   0.00000   103:    } else {
        0   0.00000   0.00000   104:        open(FILE,">".$fileName) or return 0;
        0   0.00000   0.00000   105:        foreach(@comments){
        0   0.00000   0.00000   106:            print FILE "$_\n" or return 0;
        0   0.00000   0.00000   107:        }
        0   0.00000   0.00000   108:        #print "in file, comments written\n";
        0   0.00000   0.00000   109:        foreach(@lines){
        0   0.00000   0.00000   110:            print FILE "$_\n" or return 0;
        0   0.00000   0.00000   111:        }
        0   0.00000   0.00000   112:        close(FILE);
           ================ SmallProf version 2.02 ================
                         Profile of ../modules/File.pm                 Page 6
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   113:    }
        0   0.00000   0.00000   114:    #print "in file returning 1\n";
        0   0.00000   0.00000   115:    return 1;
        0   0.00000   0.00000   116:}#}}}
        0   0.00000   0.00000   117:
        0   0.00000   0.00000   118:##
        0   0.00000   0.00000   119:# Returns the whole array of lines of the
        0   0.00000   0.00000   120:sub getLineArray {#{{{
       78   0.00000   0.00000   121:    my $object = shift;
       78   0.01385   0.02000   122:    return @{$object->{LINES}};
        0   0.00000   0.00000   123:}#}}}
        0   0.00000   0.00000   124:
        0   0.00000   0.00000   125:##
        0   0.00000   0.00000   126:# Sets the wohle array of lines given as
        0   0.00000   0.00000   127:#
        0   0.00000   0.00000   128:# New lines are automaticaly split into
        0   0.00000   0.00000   129:#
        0   0.00000   0.00000   130:# PARAMETERS;
        0   0.00000   0.00000   131:# @lines - array of lines to set
        0   0.00000   0.00000   132:sub setLineArray {#{{{
        8   0.00000   0.00000   133:    my $object = shift;
        8   0.00002   0.00000   134:    my @lines = @_;
        8   0.00000   0.00000   135:    my @resultLines = ();
        0   0.00000   0.00000   136:
        8   0.00000   0.00000   137:    foreach my $line (@lines) {
      116   0.00001   0.01000   138:        my @newLines = ();
      116   0.00000   0.00000   139:        if($line =~ /\n/) {
        8   0.00000   0.00000   140:            @newLines = $line =~ m/(.*?)\n/g
        0   0.00000   0.00000   141:        } else {
      108   0.00045   0.00000   142:            push(@newLines,$line)
        0   0.00000   0.00000   143:        }
      116   0.00000   0.00000   144:        push(@resultLines,@newLines);
        0   0.00000   0.00000   145:    }
        8   0.00000   0.00000   146:    $object->{LINES} = \@resultLines;
        8   0.00000   0.00000   147:    @lines = undef;
        0   0.00000   0.00000   148:}#}}}
        0   0.00000   0.00000   149:
        0   0.00000   0.00000   150:
        0   0.00000   0.00000   151:##
        0   0.00000   0.00000   152:# Returns the comments array
        0   0.00000   0.00000   153:sub getCommentArray {#{{{
        0   0.00000   0.00000   154:    my $object = shift;
        0   0.00000   0.00000   155:    return @{$object->{COMMENTS}};
        0   0.00000   0.00000   156:}#}}}
        0   0.00000   0.00000   157:
        0   0.00000   0.00000   158:
        0   0.00000   0.00000   159:##
        0   0.00000   0.00000   160:# Sets the comments array
        0   0.00000   0.00000   161:#
        0   0.00000   0.00000   162:# New lines are automaticaly split into
        0   0.00000   0.00000   163:#
        0   0.00000   0.00000   164:# PARAMETERS;
        0   0.00000   0.00000   165:# @lines - array of lines to set
        0   0.00000   0.00000   166:sub setCommentArray {#{{{
        0   0.00000   0.00000   167:    my $object = shift;
        0   0.00000   0.00000   168:    my @lines = @_;
           ================ SmallProf version 2.02 ================
                         Profile of ../modules/File.pm                 Page 7
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   169:    my @resultLines = ();
        0   0.00000   0.00000   170:
        0   0.00000   0.00000   171:    foreach my $line (@lines) {
        0   0.00000   0.00000   172:        my @newLines = ();
        0   0.00000   0.00000   173:        if($line =~ /\n/) {
        0   0.00000   0.00000   174:            @newLines = $line =~ m/(.*?)\n/g
        0   0.00000   0.00000   175:        } else {
        0   0.00000   0.00000   176:            push(@newLines,$line)
        0   0.00000   0.00000   177:        }
        0   0.00000   0.00000   178:        push(@resultLines,@newLines);
        0   0.00000   0.00000   179:    }
        0   0.00000   0.00000   180:    $object->{COMMENTS} = \@lines;
        0   0.00000   0.00000   181:    @lines = undef;
        0   0.00000   0.00000   182:}#}}}
        0   0.00000   0.00000   183:
        0   0.00000   0.00000   184:
        0   0.00000   0.00000   185:##
        0   0.00000   0.00000   186:# Returns a line from line array
        0   0.00000   0.00000   187:#
        0   0.00000   0.00000   188:# PARAMETERS:
        0   0.00000   0.00000   189:# $index - number of line to return (index of
        0   0.00000   0.00000   190:sub getLine {#{{{
       58   0.00000   0.00000   191:    my $object = shift;
       58   0.00000   0.00000   192:    my $index = shift;
       58   0.00021   0.00000   193:    my @lines = @{$object->{LINES}};
       58   0.00000   0.00000   194:    return 0 if $index < 0;
       58   0.00000   0.00000   195:    return 0 if $index > $#lines;
       58   0.01950   0.00000   196:    return $lines[$index];
        0   0.00000   0.00000   197:}#}}}
        0   0.00000   0.00000   198:
        0   0.00000   0.00000   199:##
        0   0.00000   0.00000   200:# Sets a line in line array
        0   0.00000   0.00000   201:#
        0   0.00000   0.00000   202:# PARAMETERS:
        0   0.00000   0.00000   203:# $index - number of line to set
        0   0.00000   0.00000   204:# $line - string to set this line to
        0   0.00000   0.00000   205:sub setLine {#{{{
        0   0.00000   0.00000   206:    my ($object,$index,$line) = @_;
        0   0.00000   0.00000   207:    my @lines = ();
        0   0.00000   0.00000   208:    @lines = @{$object->{LINES}};
        0   0.00000   0.00000   209:
        0   0.00000   0.00000   210:    $lines[$index] = $line;
        0   0.00000   0.00000   211:
        0   0.00000   0.00000   212:    $object->{LINES} = \@lines;
        0   0.00000   0.00000   213:}#}}}
        0   0.00000   0.00000   214:
        0   0.00000   0.00000   215:##
        0   0.00000   0.00000   216:# Appends a line to the line array
        0   0.00000   0.00000   217:#
        0   0.00000   0.00000   218:# PARAMETERS:
        0   0.00000   0.00000   219:# $line - string to append
        0   0.00000   0.00000   220:sub addLine {#{{{
        8   0.00000   0.00000   221:    my $object = shift;
        8   0.00002   0.00000   222:    my $line = shift;
        8   0.00000   0.00000   223:    my @lines = @{$object->{LINES}};
        0   0.00000   0.00000   224:
           ================ SmallProf version 2.02 ================
                         Profile of ../modules/File.pm                 Page 8
       =================================================================
    count wall tm  cpu time line
        8   0.00000   0.00000   225:    my @newLines = ();
        8   0.00019   0.00000   226:    @newLines = $line =~ m/(.*?)\n/g if $line
        8   0.00000   0.00000   227:    push(@lines,$line) if not $line =~ /\n/;
        0   0.00000   0.00000   228:
        8   0.00000   0.00000   229:    push(@lines,@newLines);
        8   0.00000   0.00000   230:    $object->{LINES} = \@lines;
        0   0.00000   0.00000   231:}#}}}
        0   0.00000   0.00000   232:
        0   0.00000   0.00000   233:##
        0   0.00000   0.00000   234:# Appends an array of lines to the line array
        0   0.00000   0.00000   235:#
        0   0.00000   0.00000   236:# PARAMETERS:
        0   0.00000   0.00000   237:# @toAdd - string to append
        0   0.00000   0.00000   238:sub addLines {#{{{
        0   0.00000   0.00000   239:    my $object = shift;
        0   0.00000   0.00000   240:    my @toAdd = @_;
        0   0.00000   0.00000   241:    my @lines = @{$object->{LINES}};
        0   0.00000   0.00000   242:
        0   0.00000   0.00000   243:    foreach my $line (@toAdd) {
        0   0.00000   0.00000   244:        my @newLines = ();
        0   0.00000   0.00000   245:        @newLines = $line =~ m/(.*?)\n/g if
        0   0.00000   0.00000   246:        push(@newLines,$line) if not $line =~
        0   0.00000   0.00000   247:        #print "newlines: @newLines\n";
        0   0.00000   0.00000   248:
        0   0.00000   0.00000   249:        push(@lines,@newLines);
        0   0.00000   0.00000   250:    }
        0   0.00000   0.00000   251:    $object->{LINES} = \@lines;
        0   0.00000   0.00000   252:
        0   0.00000   0.00000   253:    @toAdd = ();
        0   0.00000   0.00000   254:}#}}}
        0   0.00000   0.00000   255:
        0   0.00000   0.00000   256:
        0   0.00000   0.00000   257:##
        0   0.00000   0.00000   258:# Appends a line to the comments array
        0   0.00000   0.00000   259:#
        0   0.00000   0.00000   260:# PARAMETERS:
        0   0.00000   0.00000   261:# $line - string to append
        0   0.00000   0.00000   262:sub addCommentLine {#{{{
        8   0.00000   0.00000   263:    my $object = shift;
        8   0.00000   0.00000   264:    my @toAdd = @_;
        8   0.00000   0.00000   265:    my @lines = @{$object->{LINES}};
        0   0.00000   0.00000   266:
        8   0.00000   0.00000   267:    foreach my $line (@toAdd) {
        8   0.00000   0.00000   268:        my @newLines;
        8   0.00021   0.00000   269:        @newLines = $line =~ m/(.*?)\n/g if
        8   0.00000   0.00000   270:        push(@newLines,$line) if not $line =~
        0   0.00000   0.00000   271:        #print "newlines: @newLines\n";
        0   0.00000   0.00000   272:
        8   0.00000   0.00000   273:        push(@lines,@newLines);
        0   0.00000   0.00000   274:    }
        8   0.00000   0.00000   275:    $object->{COMMENTS} = \@lines;
        0   0.00000   0.00000   276:}#}}}
        0   0.00000   0.00000   277:
        0   0.00000   0.00000   278:
        0   0.00000   0.00000   279:##
        0   0.00000   0.00000   280:# Returns an array of lines that match a
           ================ SmallProf version 2.02 ================
                         Profile of ../modules/File.pm                 Page 9
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   281:#
        0   0.00000   0.00000   282:# PARAMETERS:
        0   0.00000   0.00000   283:# $regularExpression - regular expression
        0   0.00000   0.00000   284:sub getLinesGrep {#{{{
     1256   0.00002   0.02000   285:    my $object = shift;
     1256   0.00047   0.00000   286:    my $regularExpression = shift;
     1256   0.01711   0.06000   287:    my @lines = @{$object->{LINES}};
     1256   0.00001   0.01000   288:    my @result = ();
     1256   0.00003   0.01000   289:    foreach(@lines){
    25186   0.01601   0.29000   290:        push(@result,$_) if
        0   0.00000   0.00000   291:    }
     1256   0.00145   0.00000   292:    return @result;
        0   0.00000   0.00000   293:}#}}}
        0   0.00000   0.00000   294:
        0   0.00000   0.00000   295:##
        0   0.00000   0.00000   296:# Returns the first line that matches a
        0   0.00000   0.00000   297:#
        0   0.00000   0.00000   298:# PARAMETERS:
        0   0.00000   0.00000   299:# $regularExpression - regular expression
        0   0.00000   0.00000   300:sub getFirstLineGrep {#{{{
        0   0.00000   0.00000   301:    my $object = shift;
        0   0.00000   0.00000   302:    my $regularExpression = shift;
        0   0.00000   0.00000   303:    my @lines = @{$object->{LINES}};
        0   0.00000   0.00000   304:    foreach(@lines){
        0   0.00000   0.00000   305:        return $_ if /$regularExpression/;
        0   0.00000   0.00000   306:    }
        0   0.00000   0.00000   307:    return 0;
        0   0.00000   0.00000   308:}#}}}
        0   0.00000   0.00000   309:
        0   0.00000   0.00000   310:##
        0   0.00000   0.00000   311:# Returns the index of the first line that
        0   0.00000   0.00000   312:#
        0   0.00000   0.00000   313:# PARAMETERS:
        0   0.00000   0.00000   314:# $regularExpression - regular expression
        0   0.00000   0.00000   315:sub getIndexFirstLineGrep {#{{{
        0   0.00000   0.00000   316:    my $object = shift;
        0   0.00000   0.00000   317:    my $regularExpression = shift;
        0   0.00000   0.00000   318:    my @lines = @{$object->{LINES}};
        0   0.00000   0.00000   319:    for my $index(0..$#lines){
        0   0.00000   0.00000   320:        return $index if $lines[$index] =~
        0   0.00000   0.00000   321:    }
        0   0.00000   0.00000   322:    return -1;
        0   0.00000   0.00000   323:}#}}}
        0   0.00000   0.00000   324:
        0   0.00000   0.00000   325:
        0   0.00000   0.00000   326:##
        0   0.00000   0.00000   327:# Returns true if line pointer has not
        0   0.00000   0.00000   328:#
        0   0.00000   0.00000   329:# This function is part of an iterator
        0   0.00000   0.00000   330:sub hasLines {#{{{
       66   0.00000   0.00000   331:    my $object = shift;
       66   0.00000   0.00000   332:    my $lenght = @{$object->{LINES}};
       66   0.00000   0.00000   333:    return ($lenght > $object->{LINEPOINTER})
        0   0.00000   0.00000   334:}#}}}
        0   0.00000   0.00000   335:
        0   0.00000   0.00000   336:##
           ================ SmallProf version 2.02 ================
                         Profile of ../modules/File.pm                 Page 10
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   337:# Returns actual line and increments line
        0   0.00000   0.00000   338:#
        0   0.00000   0.00000   339:# If the line pointer has reached the end of
        0   0.00000   0.00000   340:#
        0   0.00000   0.00000   341:# This function is part of an iterator
        0   0.00000   0.00000   342:sub getNextLine {#{{{
       58   0.00000   0.00000   343:    my $object = shift;
       58   0.00000   0.00000   344:    my $line = $object->getLine($object-
       58   0.00000   0.00000   345:    $object->{LINEPOINTER}++ if $object-
       58   0.00000   0.00000   346:    return $line;
        0   0.00000   0.00000   347:}#}}}
        0   0.00000   0.00000   348:
        0   0.00000   0.00000   349:##
        0   0.00000   0.00000   350:# Deletes all lines from line array
        0   0.00000   0.00000   351:sub clearLines {#{{{
        0   0.00000   0.00000   352:    my $object = shift;
        0   0.00000   0.00000   353:    my @lines = ();
        0   0.00000   0.00000   354:    $object->{LINES} = \@lines;
        0   0.00000   0.00000   355:}#}}}
        0   0.00000   0.00000   356:
        0   0.00000   0.00000   357:##
        0   0.00000   0.00000   358:# Deletes all lines from comments array
        0   0.00000   0.00000   359:sub clearComments {#{{{
        0   0.00000   0.00000   360:    my $object = shift;
        0   0.00000   0.00000   361:    my @comments = ();
        0   0.00000   0.00000   362:    $object->{COMMENTS} = \@comments;
        0   0.00000   0.00000   363:}#}}}
        0   0.00000   0.00000   364:
        0   0.00000   0.00000   365:##
        0   0.00000   0.00000   366:# Deletes all lines from line array and
        0   0.00000   0.00000   367:sub clearFile {#{{{
        8   0.00000   0.00000   368:    my $object = shift;
        8   0.00000   0.00000   369:    my @lines = ();
        8   0.00000   0.00000   370:    my @comments = ();
        8   0.00000   0.00000   371:    $object->{LINES} = \@lines;
        8   0.00000   0.00000   372:    $object->{COMMENTS} = \@comments;
        0   0.00000   0.00000   373:}#}}}
        0   0.00000   0.00000   374:
        0   0.00000   0.00000   375:##
        0   0.00000   0.00000   376:# Sets the line pointer to 0.
        0   0.00000   0.00000   377:#
        0   0.00000   0.00000   378:# This function is part of an iterator
        0   0.00000   0.00000   379:sub resetLinePointer {#{{{
        4   0.00000   0.00000   380:    my $object = shift;
        4   0.00000   0.00000   381:    $object->{LINEPOINTER} = 0;
        0   0.00000   0.00000   382:}#}}}
        0   0.00000   0.00000   383:
        0   0.00000   0.00000   384:##
        0   0.00000   0.00000   385:# Returns the path to the file
        0   0.00000   0.00000   386:sub getPath {#{{{
        0   0.00000   0.00000   387:    my $object = shift;
        0   0.00000   0.00000   388:    return $object->{PATH};
        0   0.00000   0.00000   389:}#}}}
        0   0.00000   0.00000   390:
        0   0.00000   0.00000   391:##
        0   0.00000   0.00000   392:# Sets the path to the file
           ================ SmallProf version 2.02 ================
                         Profile of ../modules/File.pm                 Page 11
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   393:#
        0   0.00000   0.00000   394:# The variables directory, filename, name and
        0   0.00000   0.00000   395:#
        0   0.00000   0.00000   396:# If path is "-" then path, filename and name
        0   0.00000   0.00000   397:sub setPath {#{{{
       67   0.00000   0.00000   398:    my $object = shift;
       67   0.00001   0.01000   399:    my $path = shift;
       67   0.00000   0.00000   400:    my $directory;
       67   0.00000   0.00000   401:    my $fileName;
       67   0.00000   0.00000   402:    my $name;
       67   0.00000   0.00000   403:    my $type;
       67   0.00000   0.00000   404:    if($path eq "-") {
        0   0.00000   0.00000   405:        ($path,$fileName,$name,$type) = ("-
        0   0.00000   0.00000   406:    } else {
       66   0.00004   0.00000   407:        ($directory,$fileName) = $path =~
       66   0.00000   0.00000   408:        $directory = "" if not defined
       66   0.00000   0.00000   409:        $fileName = $path if not defined
        0   0.00000   0.00000   410:        #($fileName) = $path =~ m/.*\/(.*)/;
       66   0.00000   0.00000   411:        ($name,$type) = $fileName =~
       66   0.00000   0.00000   412:        $name = $fileName if not defined
       66   0.00000   0.00000   413:        $type = "" if not defined $type;
        0   0.00000   0.00000   414:        #print "File: $directory$fileName
        0   0.00000   0.00000   415:    }
       67   0.00000   0.00000   416:    $object->{PATH} = $path;
       67   0.00017   0.00000   417:    $object->{DIRECTORY} = $directory;
       67   0.00016   0.00000   418:    $object->{FILENAME} = $fileName;
       67   0.00001   0.01000   419:    $object->{NAME} = $name;
       67   0.00000   0.00000   420:    $object->{FILETYPE} = $type;
        0   0.00000   0.00000   421:}#}}}
        0   0.00000   0.00000   422:
        0   0.00000   0.00000   423:##
        0   0.00000   0.00000   424:# Returns the filename of the represented
        0   0.00000   0.00000   425:sub getFileName {#{{{
       62   0.00000   0.00000   426:    my $object = shift;
       62   0.00000   0.00000   427:    return $object->{FILENAME};
        0   0.00000   0.00000   428:}#}}}
        0   0.00000   0.00000   429:
        0   0.00000   0.00000   430:##
        0   0.00000   0.00000   431:# Sets filename of the file
        0   0.00000   0.00000   432:#
        0   0.00000   0.00000   433:# The directory stays the same. The variables
        0   0.00000   0.00000   434:sub setFileName {#{{{
        0   0.00000   0.00000   435:    my $object = shift;
        0   0.00000   0.00000   436:    my $fileName = shift;
        0   0.00000   0.00000   437:    $object->setPath($object-
        0   0.00000   0.00000   438:}#}}}
        0   0.00000   0.00000   439:
        0   0.00000   0.00000   440:##
        0   0.00000   0.00000   441:# Returns the directory the file is stored at
        0   0.00000   0.00000   442:sub getDirectory {#{{{
        0   0.00000   0.00000   443:    my $object = shift;
        0   0.00000   0.00000   444:    return $object->{DIRECTORY};
        0   0.00000   0.00000   445:}#}}}
        0   0.00000   0.00000   446:
        0   0.00000   0.00000   447:##
        0   0.00000   0.00000   448:# Sets directory the file is stored at
           ================ SmallProf version 2.02 ================
                         Profile of ../modules/File.pm                 Page 12
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   449:#
        0   0.00000   0.00000   450:# Variable path gets updated
        0   0.00000   0.00000   451:sub setDirectory {#{{{
        0   0.00000   0.00000   452:    my $object = shift;
        0   0.00000   0.00000   453:    my $directory = shift;
        0   0.00000   0.00000   454:    $object->setPath($directory.$object-
        0   0.00000   0.00000   455:}#}}}
        0   0.00000   0.00000   456:
        0   0.00000   0.00000   457:##
        0   0.00000   0.00000   458:# Returns Name of the file (without suffix)
        0   0.00000   0.00000   459:sub getName {#{{{
       12   0.00000   0.00000   460:    my $object = shift;
       12   0.00000   0.00000   461:    return $object->{NAME};
        0   0.00000   0.00000   462:}#}}}
        0   0.00000   0.00000   463:
        0   0.00000   0.00000   464:##
        0   0.00000   0.00000   465:# Sets the name of the file (without suffix)
        0   0.00000   0.00000   466:#
        0   0.00000   0.00000   467:# Variables path and filename gets updated
        0   0.00000   0.00000   468:sub setName {#{{{
        0   0.00000   0.00000   469:    my $object = shift;
        0   0.00000   0.00000   470:    my $name = shift;
        0   0.00000   0.00000   471:    $object->setPath($object-
        0   0.00000   0.00000   472:}#}}}
        0   0.00000   0.00000   473:
        0   0.00000   0.00000   474:##
        0   0.00000   0.00000   475:# Returns suffix of filename
        0   0.00000   0.00000   476:sub getFileType {#{{{
        0   0.00000   0.00000   477:    my $object = shift;
        0   0.00000   0.00000   478:    return $object->{TYPE};
        0   0.00000   0.00000   479:}#}}}
        0   0.00000   0.00000   480:
        0   0.00000   0.00000   481:##
        0   0.00000   0.00000   482:# Sets suffix of filename
        0   0.00000   0.00000   483:#
        0   0.00000   0.00000   484:# Variables path and filename gets updated
        0   0.00000   0.00000   485:sub setFileType {#{{{
        0   0.00000   0.00000   486:    my $object = shift;
        0   0.00000   0.00000   487:    my $type = shift;
        0   0.00000   0.00000   488:    $object->setPath($object-
        0   0.00000   0.00000   489:}#}}}
        0   0.00000   0.00000   490:
        0   0.00000   0.00000   491:
        0   0.00000   0.00000   492:##
        0   0.00000   0.00000   493:# Returns the number of lines in the line
        0   0.00000   0.00000   494:sub getLength {#{{{
       70   0.00000   0.00000   495:    my $object = shift;
       70   0.00027   0.00000   496:    my @lines = @{$object->{LINES}};
       70   0.00001   0.00000   497:    return $#lines;
        0   0.00000   0.00000   498:}#}}}
        0   0.00000   0.00000   499:
        0   0.00000   0.00000   500:##
        0   0.00000   0.00000   501:# Prints the whole file to STDOUT.
        0   0.00000   0.00000   502:sub print {#{{{
        0   0.00000   0.00000   503:    my $object = shift;
        0   0.00000   0.00000   504:    my @comments = @{$object->{COMMENTS}};
           ================ SmallProf version 2.02 ================
                         Profile of ../modules/File.pm                 Page 13
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   505:    my @lines = @{$object->{LINES}};
        0   0.00000   0.00000   506:    foreach my $line (@comments) {
        0   0.00000   0.00000   507:        print $line."\n";
        0   0.00000   0.00000   508:    }
        0   0.00000   0.00000   509:    foreach my $line (@lines) {
        0   0.00000   0.00000   510:        print $line."\n";
        0   0.00000   0.00000   511:    }
        0   0.00000   0.00000   512:}#}}}
        0   0.00000   0.00000   513:
        0   0.00000   0.00000   514:##
        0   0.00000   0.00000   515:# Adds a line to a file
        0   0.00000   0.00000   516:#
        0   0.00000   0.00000   517:# This is a static function and can be called
        0   0.00000   0.00000   518:# If calles with a file object the associated
        0   0.00000   0.00000   519:#
        0   0.00000   0.00000   520:# PARAMETERS:
        0   0.00000   0.00000   521:# $fileName - path the to file the line
        0   0.00000   0.00000   522:# $line - line that should be added
        0   0.00000   0.00000   523:sub addLineToFile {#{{{
        0   0.00000   0.00000   524:    my $fileName = shift;
        0   0.00000   0.00000   525:    my $line = shift;
        0   0.00000   0.00000   526:    open(FILE,">>$fileName");
        0   0.00000   0.00000   527:    print FILE $line."\n";
        0   0.00000   0.00000   528:    close FILE;
        0   0.00000   0.00000   529:}#}}}
        0   0.00000   0.00000   530:
        0   0.00000   0.00000   531:1;
        0   0.00000   0.00000   532:
        0   0.00000   0.00000   533:
        0   0.00000   0.00000   534:# for a better use with vim. All the
        0   0.00000   0.00000   535:# vim: foldmethod=marker
           ================ SmallProf version 2.02 ================
                    Profile of ../modules/ProtocolParser.pm            Page 14
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:#
        0   0.00000   0.00000     2:# Package: ProtocolParser
        0   0.00000   0.00000     3:#
        0   0.00000   0.00000     4:# Provides functions to parse tcpdumps and
        0   0.00000   0.00000     5:package ProtocolParser;
        0   0.00000   0.00000     6:
        0   0.00000   0.00000     7:use warnings;
        0   0.00000   0.00000     8:use strict;
        0   0.00000   0.00000     9:
        0   0.00000   0.00000    10:use lib "modules";
        0   0.00000   0.00000    11:use Utilities;
        0   0.00000   0.00000    12:use Scenario;
        0   0.00000   0.00000    13:use RIPPacket;
        0   0.00000   0.00000    14:use Topology;
        0   0.00000   0.00000    15:
        0   0.00000   0.00000    16:##
        0   0.00000   0.00000    17:# VARIABLES: Member variables
        0   0.00000   0.00000    18:# topology - topology object
        0   0.00000   0.00000    19:# options - parsing options. Can be "-from"
        0   0.00000   0.00000    20:# failuretime - timestamp of shutting down a
        0   0.00000   0.00000    21:# name - topology name
        0   0.00000   0.00000    22:# packets - array with RIPPacket objects
        0   0.00000   0.00000    23:
        0   0.00000   0.00000    24:##
        0   0.00000   0.00000    25:# *Constructor*
        0   0.00000   0.00000    26:#
        0   0.00000   0.00000    27:# PARAMETERS:
        0   0.00000   0.00000    28:# $topology - topology object of the
        0   0.00000   0.00000    29:# $options - parsing options, see <options>
        0   0.00000   0.00000    30:# $failureTime - timestamp of router or
        0   0.00000   0.00000    31:# @files - file objects of dump files
        0   0.00000   0.00000    32:sub new {#{{{
        4   0.00000   0.00000    33:    my $object = shift;
        4   0.00000   0.00000    34:    my $topology = shift;
        4   0.00000   0.00000    35:    my $options = shift;
        4   0.00000   0.00000    36:    my $failureTime = shift;
        4   0.00000   0.00000    37:    my @files = @_;
        4   0.00000   0.00000    38:    my $reference = {};
        4   0.00000   0.00000    39:    bless($reference,$object);
        4   0.00000   0.00000    40:    $reference-
        4   0.00000   0.00000    41:    return($reference);
        0   0.00000   0.00000    42:}#}}}
        0   0.00000   0.00000    43:
        0   0.00000   0.00000    44:##
        0   0.00000   0.00000    45:# Returns a file object with the packet
        0   0.00000   0.00000    46:sub getHumanReadableDumpFile {#{{{
        0   0.00000   0.00000    47:    my $object = shift;
        0   0.00000   0.00000    48:    my @packets = @{$object->{PACKETS}};
        0   0.00000   0.00000    49:    my $firstTimeStamp = $object-
        0   0.00000   0.00000    50:    return 0 if $firstTimeStamp == -1;
        0   0.00000   0.00000    51:    my $config = Configuration::instance();
        0   0.00000   0.00000    52:    my $outputFileName = $config-
        0   0.00000   0.00000    53:    $outputFileName = "-" if not
        0   0.00000   0.00000    54:    my $outputFile = new
        0   0.00000   0.00000    55:    $outputFile->clearFile();
        0   0.00000   0.00000    56:
           ================ SmallProf version 2.02 ================
                    Profile of ../modules/ProtocolParser.pm            Page 15
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000    57:    foreach my $packet (@packets){
        0   0.00000   0.00000    58:            my $line =
        0   0.00000   0.00000    59:            print $line."\n" if
        0   0.00000   0.00000    60:            $outputFile->addLine($line) if
        0   0.00000   0.00000    61:    }
        0   0.00000   0.00000    62:
        0   0.00000   0.00000    63:    return $outputFile;
        0   0.00000   0.00000    64:}#}}}
        0   0.00000   0.00000    65:
        0   0.00000   0.00000    66:##
        0   0.00000   0.00000    67:# Calculates the time packets and traffic
        0   0.00000   0.00000    68:#
        0   0.00000   0.00000    69:# RETURNS:
        0   0.00000   0.00000    70:# Hash with results of the measurements
        0   0.00000   0.00000    71:sub getResultHash {#{{{
        0   0.00000   0.00000    72:    my $object = shift;
        0   0.00000   0.00000    73:    my $topology = $object->{TOPOLOGY};
        0   0.00000   0.00000    74:    my $opt = $object->{OPTIONS};
        0   0.00000   0.00000    75:    my $failureTime = $object->{FAILURETIME};
        0   0.00000   0.00000    76:    my %results;
        0   0.00000   0.00000    77:    my $firstTimeStamp = $object-
        0   0.00000   0.00000    78:    return () if $firstTimeStamp == -1;
        0   0.00000   0.00000    79:    $failureTime = 0 if not defined
        0   0.00000   0.00000    80:
        0   0.00000   0.00000    81:    # calculate first and last timestamp
        0   0.00000   0.00000    82:    $failureTime =
        0   0.00000   0.00000    83:    $firstTimeStamp = $failureTime if($opt eq
        0   0.00000   0.00000    84:    $object->{PACKETS} = $object-
        0   0.00000   0.00000    85:    my @packets = $object->{PACKETS};
        0   0.00000   0.00000    86:    print "there are ".@packets." packets\n";
        0   0.00000   0.00000    87:    my $lastTimeStamp=0;
        0   0.00000   0.00000    88:    $lastTimeStamp = $object-
        0   0.00000   0.00000    89:
        0   0.00000   0.00000    90:    # prepare for creating statistics
        0   0.00000   0.00000    91:    my @relevantPackets = @{$object-
        0   0.00000   0.00000    92:    return () if not @relevantPackets;
        0   0.00000   0.00000    93:    my
        0   0.00000   0.00000    94:    my
        0   0.00000   0.00000    95:
        0   0.00000   0.00000    96:    # creat traffic and packet statistics
        0   0.00000   0.00000    97:    my @netPackets;
        0   0.00000   0.00000    98:    my @netTraffic;
        0   0.00000   0.00000    99:    foreach my $p(@relevantPackets){
        0   0.00000   0.00000   100:        my $net = $p->getNet();
        0   0.00000   0.00000   101:        $netPackets[$net-1]++;
        0   0.00000   0.00000   102:        $netTraffic[$net-1]+=$p-
        0   0.00000   0.00000   103:    }
        0   0.00000   0.00000   104:    foreach my $net(0..$#netPackets){ #{{{
        0   0.00000   0.00000   105:        if($netPackets[$net] >
        0   0.00000   0.00000   106:
        0   0.00000   0.00000   107:            $mostPacketsNet = $net;
        0   0.00000   0.00000   108:        }
        0   0.00000   0.00000   109:        if($netPackets[$net] <
        0   0.00000   0.00000   110:            $leastPacketsNetCount =
        0   0.00000   0.00000   111:            $leastPacketsNet = $net;
        0   0.00000   0.00000   112:        }
           ================ SmallProf version 2.02 ================
                    Profile of ../modules/ProtocolParser.pm            Page 16
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   113:        if($netTraffic[$net] < $minTraffic){
        0   0.00000   0.00000   114:            $minTraffic = $netTraffic[$net];
        0   0.00000   0.00000   115:            $minTrafficNet = $net;
        0   0.00000   0.00000   116:        }
        0   0.00000   0.00000   117:        if($netTraffic[$net] > $maxTraffic){
        0   0.00000   0.00000   118:            $maxTraffic = $netTraffic[$net];;
        0   0.00000   0.00000   119:            $maxTrafficNet = $net;
        0   0.00000   0.00000   120:        }
        0   0.00000   0.00000   121:        $totalPacketCount +=
        0   0.00000   0.00000   122:        $totalTraffic += $netTraffic[$net];
        0   0.00000   0.00000   123:    }#}}}
        0   0.00000   0.00000   124:
        0   0.00000   0.00000   125:    my $averagePacketCount =
        0   0.00000   0.00000   126:    my $averageTraffic = $totalTraffic /
        0   0.00000   0.00000   127:    my $timeToConvergence = $lastTimeStamp-
        0   0.00000   0.00000   128:
        0   0.00000   0.00000   129:    # create result hash #{{{
        0   0.00000   0.00000   130:    $results{FAILURETIME} = $failureTime;
        0   0.00000   0.00000   131:    $results{FIRSTTIMESTAMP} =
        0   0.00000   0.00000   132:    $results{LASTTIMESTAMP} = $lastTimeStamp;
        0   0.00000   0.00000   133:    $results{AVERAGEPACKETCOUNT} =
        0   0.00000   0.00000   134:    $results{MOSTPACKETSNET} =
        0   0.00000   0.00000   135:    $results{MOSTPACKETSNETCOUNT} =
        0   0.00000   0.00000   136:    $results{LEASTPACKETSNET} =
        0   0.00000   0.00000   137:    $results{LEASTPACKETSNETCOUNT} =
        0   0.00000   0.00000   138:    $results{TOTALPACKETCOUNT} =
        0   0.00000   0.00000   139:    $results{TOTALTRAFFIC} =
        0   0.00000   0.00000   140:    $results{AVERAGETRAFFIC} =
        0   0.00000   0.00000   141:    $results{MAXTRAFFIC} = $maxTraffic/1024;
        0   0.00000   0.00000   142:    $results{MAXTRAFFICNET} = $maxTrafficNet;
        0   0.00000   0.00000   143:    $results{MINTRAFFIC} = $minTraffic/1024;
        0   0.00000   0.00000   144:    $results{MINTRAFFICNET} = $minTrafficNet;
        0   0.00000   0.00000   145:    $results{TOPOLOGYNAME} = $topology-
        0   0.00000   0.00000   146:    $results{TIMETOCONVERGENCE} =
        0   0.00000   0.00000   147:
        0   0.00000   0.00000   148:    return %results;
        0   0.00000   0.00000   149:
        0   0.00000   0.00000   150:}#}}}
        0   0.00000   0.00000   151:
        0   0.00000   0.00000   152:
        0   0.00000   0.00000   153:##
        0   0.00000   0.00000   154:# Sets necessary member variables and
        0   0.00000   0.00000   155:sub _initProtocolParser {#{{{
        4   0.00000   0.00000   156:    my $object = shift;
        4   0.00000   0.00000   157:    my $topology = shift;
        4   0.00000   0.00000   158:    my $options = shift;
        4   0.00000   0.00000   159:    my $failureTime = shift;
        4   0.00000   0.00000   160:    my @files = @_;
        0   0.00000   0.00000   161:
        4   0.00000   0.00000   162:    $object->{TOPOLOGY} = $topology;
        4   0.00000   0.00000   163:    $object->{OPTIONS} = $options;
        4   0.00000   0.00000   164:    $object->{FAILURETIME} = $failureTime;
        4   0.00000   0.00000   165:    $object->{NAME} = $topology->toZVF()-
        0   0.00000   0.00000   166:
        4   0.00000   0.00000   167:    my @allLines;
      128   0.00000   0.00000   168:    foreach my $file (@files){ next if not
           ================ SmallProf version 2.02 ================
                    Profile of ../modules/ProtocolParser.pm            Page 17
       =================================================================
    count wall tm  cpu time line
        4   0.00000   0.00000   169:    my %dumpHash = %{$object-
        4   0.00070   0.00000   170:    my @keys = keys %dumpHash;
        0   0.00000   0.00000   171:    #print "there are ".@keys." dumpHash
        4   0.00000   0.00000   172:    my @packetList;
        0   0.00000   0.00000   173:
        4   0.00116   0.00000   174:    foreach my $timeStamp (sort keys
     1256   0.01084   0.02000   175:        my ($router,$content,$lenght) =
     1256   0.00001   0.00000   176:        my $packet = 0;
        0   0.00000   0.00000   177:        # creating packet out of dump content
     1256   0.00008   0.01000   178:        $packet = RIPPacket-
     1256   0.00033   0.00000   179:        push(@packetList,$packet);
        0   0.00000   0.00000   180:    }
        0   0.00000   0.00000   181:    #print "there are ".@packetList."
        4   0.00380   0.00000   182:    $object->{PACKETS} = \@packetList;
        0   0.00000   0.00000   183:}#}}}
        0   0.00000   0.00000   184:
        0   0.00000   0.00000   185:##
        0   0.00000   0.00000   186:# Creates one line for each packet in dump.
        0   0.00000   0.00000   187:#
        0   0.00000   0.00000   188:# PARAMETERS:
        0   0.00000   0.00000   189:# $lineReference - list reference with lines
        0   0.00000   0.00000   190:#
        0   0.00000   0.00000   191:# RETURNS:
        0   0.00000   0.00000   192:# List reference of lines with one packet per
        0   0.00000   0.00000   193:sub _flattenDump {#{{{
        4   0.00000   0.00000   194:    my $object = shift;
        4   0.00000   0.00000   195: my $lineReference = shift;
        4   0.02018   0.02000   196:    my @lines = @{$lineReference};
        4   0.00000   0.00000   197: my @packets = ();
        4   0.00003   0.00000   198: my $actualLine = shift @lines;
        4   0.00001   0.00000   199:    my @lineSplit = split(" ",$actualLine);
        4   0.00008   0.00000   200:    my $actualTimeStamp =
        4   0.00000   0.00000   201: foreach my $line (@lines){
    18693   0.00299   0.15000   202:  chomp $line;
    18693   0.01109   0.24000   203:        @lineSplit = split(" ",$line);
    18693   0.01332   0.21000   204:  if($line =~ /^[0-9]+:[0-9]+:/){
     1624   0.00002   0.01000   205:            my $newTimeStamp =
     1624   0.00118   0.00000   206:                push(@packets,$actualLine);
     1624   0.00000   0.00000   207:                $actualLine = $line;
     1624   0.00002   0.00000   208:                $actualTimeStamp =
        0   0.00000   0.00000   209:  }else{
    17069   0.00236   0.16000   210:   $actualLine .= " ".$line;
        0   0.00000   0.00000   211:  }
        0   0.00000   0.00000   212: }
        4   0.00000   0.00000   213: push(@packets,$actualLine);
        0   0.00000   0.00000   214:    return \@packets
        4   0.00198   0.00000   215:}#}}}
        0   0.00000   0.00000   216:
        0   0.00000   0.00000   217:##
        0   0.00000   0.00000   218:# Removes packets from other services then
        0   0.00000   0.00000   219:#
        0   0.00000   0.00000   220:# Extracts the timestamp, sending ip, length
        0   0.00000   0.00000   221:#
        0   0.00000   0.00000   222:# PARAMETERS:
        0   0.00000   0.00000   223:# $packetReference - array reference with
        0   0.00000   0.00000   224:#
           ================ SmallProf version 2.02 ================
                    Profile of ../modules/ProtocolParser.pm            Page 18
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   225:# RETURNS:
        0   0.00000   0.00000   226:# Hash with
        0   0.00000   0.00000   227:# key - timestamp of packet
        0   0.00000   0.00000   228:# value - list with: sending router, content
        0   0.00000   0.00000   229:sub _getPacketProperties {#{{{
        4   0.00000   0.00000   230:    my $object = shift;
        4   0.00000   0.00000   231:    my $packetReference = shift;
        4   0.00538   0.01000   232:    my @packets = @{$packetReference};
        4   0.00000   0.00000   233:    my %resultHash;
        4   0.00000   0.00000   234:    foreach my $l (@packets){
     1628   0.00024   0.00000   235:        next if not $l =~ /RIPv2/;
     1256   0.00960   0.03000   236:        my ($length) = $l =~ m/length: ([0-
     1256   0.10581   0.11000   237:        my @split = split(" ",$l);
     1256   0.00003   0.03000   238:        my $timestamp =
     1256   0.00001   0.02000   239:        shift @split;
     1256   0.00088   0.01000   240:        my $router = shift @split;
     1256   0.00015   0.03000   241:        $router =~ s/([0-9]+\.[0-9]+\.[0-
        0   0.00000   0.00000   242:        #print "router = $router\n";
     1256   0.00004   0.03000   243:        my $content = "";
     1256   0.00045   0.02000   244:        foreach(@split){
   147669   0.03502   1.47000   245:            $content .= $_." " if /^[0-9a-fA-
   147669  17.53720  18.90000   246:            $content =~ s/([0-9a-fA-
        0   0.00000   0.00000   247:        }
     1256   0.00172   0.00000   248:        chomp $content;
     1256   0.00037   0.00000   249:        my @value =
     1256   0.01542   0.07000   250:        $resultHash{$timestamp} = \@value;
        0   0.00000   0.00000   251:    }
        0   0.00000   0.00000   252:
        4   0.00252   0.00000   253: return \%resultHash;
        0   0.00000   0.00000   254:}#}}}
        0   0.00000   0.00000   255:
        0   0.00000   0.00000   256:
        0   0.00000   0.00000   257:##
        0   0.00000   0.00000   258:# Determines first timestamp of the run
        0   0.00000   0.00000   259:#
        0   0.00000   0.00000   260:# RETURNS:
        0   0.00000   0.00000   261:# The first timestamp of all dumps from a run
        0   0.00000   0.00000   262:sub _getFirstTimeStamp {#{{{
        0   0.00000   0.00000   263:    my $object = shift;
        0   0.00000   0.00000   264: my @packets = @{$object->{PACKETS}};
        0   0.00000   0.00000   265:    my $firstPacket = $packets[0];
        0   0.00000   0.00000   266:    return -1 if not defined $firstPacket;
        0   0.00000   0.00000   267: return $firstPacket->getPacketTimeStamp();
        0   0.00000   0.00000   268:}#}}}
        0   0.00000   0.00000   269:
        0   0.00000   0.00000   270:
        0   0.00000   0.00000   271:# Generates a list of routing tables (router
        0   0.00000   0.00000   272:#
        0   0.00000   0.00000   273:# This Function sets only the connected nets
        0   0.00000   0.00000   274:#
        0   0.00000   0.00000   275:# RETURNS:
        0   0.00000   0.00000   276:# List of routing tables (as hash references)
        0   0.00000   0.00000   277:sub _prepareRoutingTables {#{{{
        4   0.00000   0.00000   278:    my $object = shift;
        4   0.00000   0.00000   279:    my $topology = $object->{TOPOLOGY};
        4   0.00000   0.00000   280:    my %routers = %{$topology->getRouters()};
           ================ SmallProf version 2.02 ================
                    Profile of ../modules/ProtocolParser.pm            Page 19
       =================================================================
    count wall tm  cpu time line
        4   0.00000   0.00000   281:    my @routerTables = ();
        4   0.00001   0.00000   282:    foreach my $router (sort keys %routers) {
       54   0.00000   0.00000   283:        my @nets =
       54   0.00000   0.00000   284:        my ($routerNumber) = $router =~
       54   0.00000   0.00000   285:        my %routerTable;
       54   0.00000   0.00000   286:        foreach my $net (@nets){
      124   0.00000   0.00000   287:            my ($netNumber) = $net =~
      124   0.00001   0.02000   288:            my @entry = (1,"self",0);
      124   0.00000   0.00000   289:
        0   0.00000   0.00000   290:        }
       54   0.00000   0.00000   291:        $routerTables[$routerNumber] =
        0   0.00000   0.00000   292:    }
        4   0.00000   0.00000   293:    return \@routerTables;
        0   0.00000   0.00000   294:}#}}}
        0   0.00000   0.00000   295:
        0   0.00000   0.00000   296:##
        0   0.00000   0.00000   297:# Calculates the timestamp of the packet that
        0   0.00000   0.00000   298:#
        0   0.00000   0.00000   299:# This function implements a small rip
        0   0.00000   0.00000   300:#
        0   0.00000   0.00000   301:# RETURNS:
        0   0.00000   0.00000   302:# Timestamp of packet that lead to
        0   0.00000   0.00000   303:#
        0   0.00000   0.00000   304:# TODO:
        0   0.00000   0.00000   305:# - comment code
        0   0.00000   0.00000   306:sub _getLastTimeStamp {#{{{
        4   0.00000   0.00000   307:    my $object = shift;
        4   0.00000   0.00000   308:    my $opt = $object->{OPTIONS};
        4   0.00000   0.00000   309:    my $topology = $object->{TOPOLOGY};
        4   0.00365   0.01000   310:    my @packets = @{$object->{PACKETS}};
        4   0.00000   0.00000   311:    my $config = Configuration::instance();
        4   0.00000   0.00000   312: my @results=();
        4   0.00000   0.00000   313: my $lastTimeStamp=0;
        4   0.00000   0.00000   314:    my @routerTables = @{$object-
        0   0.00000   0.00000   315:
        4   0.00000   0.00000   316:    foreach my $packet (@packets) {
     1256   0.00001   0.02000   317:        my $router = $packet->getRouter();
     1256   0.00045   0.01000   318:        my $net = $packet->getNet();
     1256   0.00002   0.03000   319:        my @routersInNet = @{$topology-
     1256   0.00000   0.03000   320:        my %packetHash = $packet-
     1256   0.00001   0.03000   321:        my $packetTimeStamp = $packet-
     1256   0.00116   0.05000   322:        foreach my $netIP (sort keys
    10396   0.00057   0.07000   323:            my $newMetric =
    10396   0.01099   0.03000   324:            foreach my $r (@routersInNet) { #
    20792   0.00724   0.24000   325:                my ($routerNumber) = $r =~
        0   0.00000   0.00000   326:
    20792   0.01409   0.21000   327:                my
    20792   0.00734   0.25000   328:               ($oldMetric, $oldRouter,
    20792   0.00195   0.17000   329:                die "not defined oldmetric"
    20792   0.00725   0.15000   330:                die "not defined oldrouter"
    20792   0.01139   0.14000   331:                die "not defined oldtime" if
    20792   0.00498   0.16000   332:                my @newEntry = ();
        0   0.00000   0.00000   333:
    20792   0.00947   0.09000   334:                if($oldMetric > $newMetric) {
     1122   0.00001   0.02000   335:                    @newEntry = ($newMetric,
     1122   0.00050   0.02000   336:                    $lastTimeStamp =
           ================ SmallProf version 2.02 ================
                    Profile of ../modules/ProtocolParser.pm            Page 20
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   337:                } elsif($oldMetric ==
        0   0.00000   0.00000   338:                    @newEntry = ($oldMetric,
        0   0.00000   0.00000   339:                } else { # look at sending
    11638   0.00115   0.08000   340:                    if($oldRouter eq
        0   0.00000   0.00000   341:                        @newEntry =
        0   0.00000   0.00000   342:                        $lastTimeStamp =
        0   0.00000   0.00000   343:                    } else { # if update came
        0   0.00000   0.00000   344:
        0   0.00000   0.00000   345:                        # take entry if
    11638   0.00323   0.09000   346:                        if($packetTimeStamp >
       17   0.00000   0.00000   347:                            @newEntry =
       17   0.00000   0.00000   348:                            $lastTimeStamp =
        0   0.00000   0.00000   349:                        } else { # else keep
    11621   0.00326   0.14000   350:                            @newEntry =
        0   0.00000   0.00000   351:                        }
        0   0.00000   0.00000   352:                    }
        0   0.00000   0.00000   353:                }
        0   0.00000   0.00000   354:
        0   0.00000   0.00000   355:                # delete entry if garbage
        0   0.00000   0.00000   356:                # TODO: correct (there must
        0   0.00000   0.00000   357:                # TODO: time is not correct
        0   0.00000   0.00000   358:                #@newEntry = () if $oldTime >
        0   0.00000   0.00000   359:
        0   0.00000   0.00000   360:                # save new entry
    20792   0.01157   0.20000   361:                $routerTables[$routerNumber]-
        0   0.00000   0.00000   362:            }
        0   0.00000   0.00000   363:        }
        0   0.00000   0.00000   364:    }
        4   0.00102   0.00000   365:    return $lastTimeStamp;
        0   0.00000   0.00000   366:}#}}}
        0   0.00000   0.00000   367:
        0   0.00000   0.00000   368:
        0   0.00000   0.00000   369:
        0   0.00000   0.00000   370:
        0   0.00000   0.00000   371:# BACKUP:
        0   0.00000   0.00000   372:#sub _getLastTimeStamp {#{{{
        0   0.00000   0.00000   373:#    my $object = shift;
        0   0.00000   0.00000   374:#    my $opt = $object->{OPTIONS};
        0   0.00000   0.00000   375:#    my $topology = $object->{TOPOLOGY};
        0   0.00000   0.00000   376:#    my @packets = @{$object->{PACKETS}};
        0   0.00000   0.00000   377:#    my $config = Configuration::instance();
        0   0.00000   0.00000   378:# my @results=();
        0   0.00000   0.00000   379:# my $lastTimeStamp=0;
        0   0.00000   0.00000   380:#    my @routerTables = @{$object-
        0   0.00000   0.00000   381:#
        0   0.00000   0.00000   382:#    foreach my $packet (@packets) {
        0   0.00000   0.00000   383:#        my $router = $packet->getRouter();
        0   0.00000   0.00000   384:#        my $net = $packet->getNet();
        0   0.00000   0.00000   385:#        my @routersInNet = @{$topology-
        0   0.00000   0.00000   386:#        my %packetHash = $packet-
        0   0.00000   0.00000   387:#        my $packetTimeStamp = $packet-
        0   0.00000   0.00000   388:#        foreach my $netIP (sort keys
        0   0.00000   0.00000   389:#            my $newMetric =
        0   0.00000   0.00000   390:#            foreach my $r (@routersInNet) {
        0   0.00000   0.00000   391:#                my ($routerNumber) = $r =~
        0   0.00000   0.00000   392:#                my %routerTable =
           ================ SmallProf version 2.02 ================
                    Profile of ../modules/ProtocolParser.pm            Page 21
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   393:#
        0   0.00000   0.00000   394:#
        0   0.00000   0.00000   395:#                my
        0   0.00000   0.00000   396:#               ($oldMetric, $oldRouter,
        0   0.00000   0.00000   397:#                die "not defined oldmetric"
        0   0.00000   0.00000   398:#                die "not defined oldrouter"
        0   0.00000   0.00000   399:#                die "not defined oldtime" if
        0   0.00000   0.00000   400:#                my @newEntry = ();
        0   0.00000   0.00000   401:#
        0   0.00000   0.00000   402:#                if($oldMetric > $newMetric)
        0   0.00000   0.00000   403:#                    @newEntry = ($newMetric,
        0   0.00000   0.00000   404:#                    $lastTimeStamp =
        0   0.00000   0.00000   405:#                    #print
        0   0.00000   0.00000   406:#                } elsif($oldMetric ==
        0   0.00000   0.00000   407:#                    @newEntry = ($oldMetric,
        0   0.00000   0.00000   408:#                } else { # look at sending
        0   0.00000   0.00000   409:#                    if($oldRouter eq
        0   0.00000   0.00000   410:#                        @newEntry =
        0   0.00000   0.00000   411:#                        $lastTimeStamp =
        0   0.00000   0.00000   412:##                        print
        0   0.00000   0.00000   413:#                    } else { # if update
        0   0.00000   0.00000   414:#
        0   0.00000   0.00000   415:#                        # take entry if
        0   0.00000   0.00000   416:#                        if($packetTimeStamp
        0   0.00000   0.00000   417:#                            @newEntry =
        0   0.00000   0.00000   418:#                            $lastTimeStamp =
        0   0.00000   0.00000   419:##                            print
        0   0.00000   0.00000   420:##                        print
        0   0.00000   0.00000   421:#                        } else { # else keep
        0   0.00000   0.00000   422:#                            @newEntry =
        0   0.00000   0.00000   423:#                        }
        0   0.00000   0.00000   424:#                    }
        0   0.00000   0.00000   425:#                }
        0   0.00000   0.00000   426:#
        0   0.00000   0.00000   427:#                # delete entry if garbage
        0   0.00000   0.00000   428:#                #@newEntry = () if $oldTime
        0   0.00000   0.00000   429:#                $routerTable{$netIP} =
        0   0.00000   0.00000   430:#                $routerTables[$routerNumber]
        0   0.00000   0.00000   431:#            }
        0   0.00000   0.00000   432:#        }
        0   0.00000   0.00000   433:#    }
        0   0.00000   0.00000   434:#    return $lastTimeStamp;
        0   0.00000   0.00000   435:#}#}}}
        0   0.00000   0.00000   436:
        0   0.00000   0.00000   437:##
        0   0.00000   0.00000   438:# Removes lines before the firts and after
        0   0.00000   0.00000   439:#
        0   0.00000   0.00000   440:# PARAMETERS:
        0   0.00000   0.00000   441:# $firstTimeStamp - minimal timestamp for a
        0   0.00000   0.00000   442:# $lastTimeStamp - maximal timestamp for a
        0   0.00000   0.00000   443:#
        0   0.00000   0.00000   444:# RETURNS:
        0   0.00000   0.00000   445:# Reference to new list of packets
        0   0.00000   0.00000   446:sub _removePackets {#{{{
        0   0.00000   0.00000   447:    my $object = shift;
        0   0.00000   0.00000   448:    my $firstTimeStamp = shift;
           ================ SmallProf version 2.02 ================
                    Profile of ../modules/ProtocolParser.pm            Page 22
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   449:    my $lastTimeStamp = shift;
        0   0.00000   0.00000   450:    my @packets = @{$object->{PACKETS}};
        0   0.00000   0.00000   451:
        0   0.00000   0.00000   452:    my @newList;
        0   0.00000   0.00000   453:    @newList = grep(($_->getPacketTimeStamp
        0   0.00000   0.00000   454:    return \@newList;
        0   0.00000   0.00000   455:}#}}}
        0   0.00000   0.00000   456:
        0   0.00000   0.00000   457:
        0   0.00000   0.00000   458:1;
        0   0.00000   0.00000   459:
        0   0.00000   0.00000   460:
        0   0.00000   0.00000   461:
        0   0.00000   0.00000   462:# for a better use with vim. All the
        0   0.00000   0.00000   463:# vim: foldmethod=marker
           ================ SmallProf version 2.02 ================
                      Profile of ../modules/RIPPacket.pm               Page 23
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:# vim: foldmethod=marker
        0   0.00000   0.00000     2:
        0   0.00000   0.00000     3:#
        0   0.00000   0.00000     4:# Package: RIPPacket
        0   0.00000   0.00000     5:#
        0   0.00000   0.00000     6:# computes tcpdumps with -x option
        0   0.00000   0.00000     7:package RIPPacket;
        0   0.00000   0.00000     8:#use Packet;
        0   0.00000   0.00000     9:#our @ISA = qw/Packet/;
        0   0.00000   0.00000    10:
        0   0.00000   0.00000    11:use warnings;
        0   0.00000   0.00000    12:use strict;
        0   0.00000   0.00000    13:
        0   0.00000   0.00000    14:use lib "modules";
        0   0.00000   0.00000    15:use Utilities;
        0   0.00000   0.00000    16:
        0   0.00000   0.00000    17:
        0   0.00000   0.00000    18:##
        0   0.00000   0.00000    19:# VARIABLES: Member variables
        0   0.00000   0.00000    20:# timestamp - timestamp of the packetHash
        0   0.00000   0.00000    21:# router - sending router
        0   0.00000   0.00000    22:# length - length in bytes with all headers
        0   0.00000   0.00000    23:# command - RIP command
        0   0.00000   0.00000    24:# version - RIP version
        0   0.00000   0.00000    25:# packethash - Hash (net => metric) with each
        0   0.00000   0.00000    26:
        0   0.00000   0.00000    27:##
        0   0.00000   0.00000    28:# Constructor of RIPPacket.
        0   0.00000   0.00000    29:#
        0   0.00000   0.00000    30:# PARAMETERS:
        0   0.00000   0.00000    31:# $timeStamp - timeStamp of the packet
        0   0.00000   0.00000    32:# $router - router that sent the packetHash
        0   0.00000   0.00000    33:# $content - string with hex values
        0   0.00000   0.00000    34:sub new {#{{{
     1256   0.00000   0.00000    35:    my $object = shift;
     1256   0.00001   0.06000    36:    my $timeStamp = shift;
     1256   0.00047   0.01000    37:    my $router = shift;
     1256   0.00049   0.00000    38:    my $content = shift;
     1256   0.00024   0.00000    39:    my $length = shift;
        0   0.00000   0.00000    40:#    my $reference = $object-
        0   0.00000   0.00000    41:
     1256   0.00006   0.00000    42:    my $reference = {};
     1256   0.00115   0.00000    43:    bless($reference,$object);
        0   0.00000   0.00000    44:
     1256   0.00799   0.01000    45:    $reference-
     1256   0.00003   0.01000    46:    return $reference;
        0   0.00000   0.00000    47:}#}}}
        0   0.00000   0.00000    48:
        0   0.00000   0.00000    49:
        0   0.00000   0.00000    50:##
        0   0.00000   0.00000    51:# Returns human readable string with time,
        0   0.00000   0.00000    52:sub print {#{{{
        0   0.00000   0.00000    53:    my $object = shift;
        0   0.00000   0.00000    54:    my $output = "";
        0   0.00000   0.00000    55:    $output.= Utilities::makeTime($object-
        0   0.00000   0.00000    56:    my %packetHash = %{$object-
           ================ SmallProf version 2.02 ================
                      Profile of ../modules/RIPPacket.pm               Page 24
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000    57:    foreach my $net (sort keys %packetHash) {
        0   0.00000   0.00000    58:        $output.= "\t$net with metric
        0   0.00000   0.00000    59:    }
        0   0.00000   0.00000    60:    $output.= "\n";
        0   0.00000   0.00000    61:    return $output;
        0   0.00000   0.00000    62:}#}}}
        0   0.00000   0.00000    63:
        0   0.00000   0.00000    64:##
        0   0.00000   0.00000    65:# Returns the packet hash with routes and
        0   0.00000   0.00000    66:sub getPacketHash {#{{{
     1256   0.00001   0.00000    67:    my $object = shift;
        0   0.00000   0.00000    68:
     1256   0.00595   0.01000    69:    return %{$object->{PACKETHASH}};
        0   0.00000   0.00000    70:}#}}}
        0   0.00000   0.00000    71:
        0   0.00000   0.00000    72:
        0   0.00000   0.00000    73:##
        0   0.00000   0.00000    74:# Returns timestamp of packet
        0   0.00000   0.00000    75:sub getPacketTimeStamp {#{{{
     1256   0.00002   0.02000    76:    my $object = shift;
     1256   0.00002   0.01000    77:    return $object->{TIMESTAMP};
        0   0.00000   0.00000    78:}#}}}
        0   0.00000   0.00000    79:
        0   0.00000   0.00000    80:##
        0   0.00000   0.00000    81:# Returns router that sent this packet
        0   0.00000   0.00000    82:sub getRouter {#{{{
     1256   0.00090   0.01000    83:    my $object = shift;
     1256   0.00002   0.03000    84:    return $object->{ROUTER};
        0   0.00000   0.00000    85:}#}}}
        0   0.00000   0.00000    86:
        0   0.00000   0.00000    87:sub getPacketLength {#{{{
        0   0.00000   0.00000    88:    my $object = shift;
        0   0.00000   0.00000    89:    return $object->{LENGTH};
        0   0.00000   0.00000    90:}#}}}
        0   0.00000   0.00000    91:
        0   0.00000   0.00000    92:sub getNet {#{{{
     1256   0.00002   0.02000    93:    my $object = shift;
     1256   0.00046   0.01000    94:    my ($net) = $object->{ROUTER} =~ m/[0-
     1256   0.00045   0.00000    95:    return $net;
        0   0.00000   0.00000    96:}#}}}
        0   0.00000   0.00000    97:
        0   0.00000   0.00000    98:##
        0   0.00000   0.00000    99:# Is called from constructor
        0   0.00000   0.00000   100:#
        0   0.00000   0.00000   101:# Generates packet hash with routes and
        0   0.00000   0.00000   102:sub _initPacket {#{{{
     1256   0.00046   0.01000   103:    my $object = shift;
     1256   0.00017   0.01000   104:    my $timeStamp = shift;
     1256   0.00056   0.00000   105:    my $router = shift;
     1256   0.00001   0.01000   106:    my $content = shift;
     1256   0.00007   0.03000   107:    my $length = shift;
        0   0.00000   0.00000   108:    #print "content: $content\n";
        0   0.00000   0.00000   109:
     1256   0.00028   0.01000   110:    $object->{TIMESTAMP} = $timeStamp;
     1256   0.00003   0.01000   111:    $object->{ROUTER} = $router;
     1256   0.00007   0.01000   112:    $object->{LENGTH} = $length;
           ================ SmallProf version 2.02 ================
                      Profile of ../modules/RIPPacket.pm               Page 25
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   113:
     1256   0.17646   0.16000   114:    my @bytes = split(" ",$content);
        0   0.00000   0.00000   115:    #print "bytes: @bytes\n";
     1256   0.20119   0.24000   116:    @bytes = @bytes[28..$#bytes]; # lsche
        0   0.00000   0.00000   117:
     1256   0.00046   0.00000   118:    $object->{COMMAND} = hex(shift @bytes);
     1256   0.00006   0.04000   119:    $object->{VERSION} = hex(shift @bytes);
        0   0.00000   0.00000   120:    #print "command: ".$object-
        0   0.00000   0.00000   121:    #print "version: ".$object-
     1256   0.00045   0.01000   122:    shift @bytes; # lsche Nullen
     1256   0.00002   0.02000   123:    shift @bytes; # lsche Nullen
        0   0.00000   0.00000   124:
     1256   0.00046   0.01000   125:    my %packetHash;                 # results
     1256   0.00002   0.01000   126:    while($#bytes>2){
    10396   0.00194   0.14000   127:        my $adressFamily = hex((shift
    10396   0.00133   0.11000   128:        shift @bytes; # lsche Nullen
    10396   0.00401   0.06000   129:        shift @bytes; # lsche Nullen
    10396   0.00221   0.10000   130:        my $netIP = join(".",hex(shift
    10396   0.00812   0.14000   131:        my $netMask = join(".",hex(shift
    10396   0.03096   0.11000   132:        my $nextHop = join(".",hex(shift
    10396   0.00538   0.09000   133:        my $metric = hex((shift
    10396   0.00361   0.12000   134:        $packetHash{$netIP} = $metric;
        0   0.00000   0.00000   135:        #print "Net $netIP has metric
        0   0.00000   0.00000   136:        #print "bytes = @bytes\n\n";
        0   0.00000   0.00000   137:    }
     1256   0.00098   0.03000   138:    $object->{PACKETHASH} = \%packetHash;
        0   0.00000   0.00000   139:}#}}}
        0   0.00000   0.00000   140:
        0   0.00000   0.00000   141:1;
           ================ SmallProf version 2.02 ================
                       Profile of ../modules/Topology.pm               Page 26
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:# Package: Topology
        0   0.00000   0.00000     2:#
        0   0.00000   0.00000     3:# Provides graph functions like <diameter> or
        0   0.00000   0.00000     4:package Topology;
        0   0.00000   0.00000     5:
        0   0.00000   0.00000     6:use strict;
        0   0.00000   0.00000     7:use warnings;
        0   0.00000   0.00000     8:use Graph::Undirected;
        0   0.00000   0.00000     9:use GraphViz;
        0   0.00000   0.00000    10:use lib ".";
        0   0.00000   0.00000    11:use File;
        0   0.00000   0.00000    12:use TopologyGenerationFunctions;
        0   0.00000   0.00000    13:use Configuration;
        0   0.00000   0.00000    14:
        0   0.00000   0.00000    15:
        0   0.00000   0.00000    16:##
        0   0.00000   0.00000    17:# VARIABLES: Member variables
        0   0.00000   0.00000    18:# topologyFile - file object of topology file
        0   0.00000   0.00000    19:# graph - Graph::Undirected object
        0   0.00000   0.00000    20:
        0   0.00000   0.00000    21:##
        0   0.00000   0.00000    22:# Constructor
        0   0.00000   0.00000    23:#
        0   0.00000   0.00000    24:# PARAMETERS:
        0   0.00000   0.00000    25:# $topologyFile - file object of topology
        0   0.00000   0.00000    26:# $g - graph representing topology (optional)
        0   0.00000   0.00000    27:sub new {#{{{
        4   0.00000   0.00000    28:    my $object = shift;
        4   0.00000   0.00000    29:    my $topologyFile = shift;
        4   0.00000   0.00000    30:    my $g = shift;
        4   0.00000   0.00000    31:    my $reference = {};
        4   0.00001   0.00000    32:    bless($reference,$object);
        4   0.00000   0.00000    33:    $reference-
        4   0.00001   0.00000    34:    return($reference);
        0   0.00000   0.00000    35:}#}}}
        0   0.00000   0.00000    36:
        0   0.00000   0.00000    37:##
        0   0.00000   0.00000    38:# Calls a generator function and and writes
        0   0.00000   0.00000    39:#
        0   0.00000   0.00000    40:# PARAMETERS:
        0   0.00000   0.00000    41:# $type - type of topology to be created
        0   0.00000   0.00000    42:# @args - list of arguments for the topology
        0   0.00000   0.00000    43:sub generateNew {#{{{
        0   0.00000   0.00000    44:    my $type = shift;
        0   0.00000   0.00000    45:    my @args = @_;
        0   0.00000   0.00000    46:    my $config = Configuration::instance();
        0   0.00000   0.00000    47:    my $outputFileName = $config-
        0   0.00000   0.00000    48:    $outputFileName = "temp.txt" if not
        0   0.00000   0.00000    49:    my $outputFile = new
        0   0.00000   0.00000    50:    my $verbose = $config-
        0   0.00000   0.00000    51:
        0   0.00000   0.00000    52:    my $topology = 0;
        0   0.00000   0.00000    53:    $outputFile->clearFile();
        0   0.00000   0.00000    54:
        0   0.00000   0.00000    55:    if($type eq "random"){ # create random
        0   0.00000   0.00000    56:        $outputFile-
           ================ SmallProf version 2.02 ================
                       Profile of ../modules/Topology.pm               Page 27
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000    57:        print "generating random topology
        0   0.00000   0.00000    58:        $topology =
        0   0.00000   0.00000    59:#}}}
        0   0.00000   0.00000    60:    }elsif($type eq "relativerandom"){ #
        0   0.00000   0.00000    61:        $outputFile->setFileName(
        0   0.00000   0.00000    62:        print "generating random topology
        0   0.00000   0.00000    63:        $topology =
        0   0.00000   0.00000    64:#}}}
        0   0.00000   0.00000    65:    }elsif($type eq "row"){ # create row
        0   0.00000   0.00000    66:        $outputFile-
        0   0.00000   0.00000    67:        print "generating row topology with
        0   0.00000   0.00000    68:        $topology =
        0   0.00000   0.00000    69:#}}}
        0   0.00000   0.00000    70:    }elsif($type eq "circle"){ # create
        0   0.00000   0.00000    71:        $outputFile-
        0   0.00000   0.00000    72:        print "generating circle topology
        0   0.00000   0.00000    73:        $topology =
        0   0.00000   0.00000    74:#}}}
        0   0.00000   0.00000    75:    }elsif($type eq "star2"){ # create star2
        0   0.00000   0.00000    76:        $outputFile-
        0   0.00000   0.00000    77:        print "generating star2 topology with
        0   0.00000   0.00000    78:        $topology =
        0   0.00000   0.00000    79:#}}}
        0   0.00000   0.00000    80:    }elsif($type eq "connectedstar2"){ #
        0   0.00000   0.00000    81:        $outputFile-
        0   0.00000   0.00000    82:        print "generating connected star2
        0   0.00000   0.00000    83:        $topology =
        0   0.00000   0.00000    84:#}}}
        0   0.00000   0.00000    85:    }elsif($type eq "star"){ # create star
        0   0.00000   0.00000    86:        $outputFile-
        0   0.00000   0.00000    87:        print "generating star topology with
        0   0.00000   0.00000    88:        $topology =
        0   0.00000   0.00000    89:#}}}
        0   0.00000   0.00000    90:    }elsif($type eq "square"){ # create
        0   0.00000   0.00000    91:        $outputFile-
        0   0.00000   0.00000    92:        print "generating aquare topology
        0   0.00000   0.00000    93:        $topology =
        0   0.00000   0.00000    94:        #}}}
        0   0.00000   0.00000    95:    }elsif($type eq "crown"){ # create crown
        0   0.00000   0.00000    96:        $outputFile-
        0   0.00000   0.00000    97:        print "generating crown $args[0]
        0   0.00000   0.00000    98:        $topology =
        0   0.00000   0.00000    99:#}}}
        0   0.00000   0.00000   100:    }elsif($type eq "circlex_rowy"){ # create
        0   0.00000   0.00000   101:        $outputFile-
        0   0.00000   0.00000   102:        print "generating topology consisting
        0   0.00000   0.00000   103:        $topology =
        0   0.00000   0.00000   104:#}}}
        0   0.00000   0.00000   105:    }elsif($type eq "squarerow"){ # create
        0   0.00000   0.00000   106:        $outputFile-
        0   0.00000   0.00000   107:        print "generating squarerow topology
        0   0.00000   0.00000   108:        $topology =
        0   0.00000   0.00000   109:#}}}
        0   0.00000   0.00000   110:    }elsif($type eq "mesh"){ # create mesh
        0   0.00000   0.00000   111:        my $g =
        0   0.00000   0.00000   112:        $outputFile-
           ================ SmallProf version 2.02 ================
                       Profile of ../modules/Topology.pm               Page 28
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   113:        print "generating full mesh topology
        0   0.00000   0.00000   114:        $topology = new
        0   0.00000   0.00000   115:        #}}}
        0   0.00000   0.00000   116:    }else{ # else die with error message #{{{
        0   0.00000   0.00000   117:        die "Cannot create topology
        0   0.00000   0.00000   118:    }#}}}
        0   0.00000   0.00000   119:
        0   0.00000   0.00000   120:    die "An Error occured, exiting\n" if not
        0   0.00000   0.00000   121:
        0   0.00000   0.00000   122:    return $topology;
        0   0.00000   0.00000   123:
        0   0.00000   0.00000   124:#    my $name = $outputFile->getName();
        0   0.00000   0.00000   125:#    $g->writeGraphImage($name.".png") if not
        0   0.00000   0.00000   126:#    print "image written\n" if not $name eq
        0   0.00000   0.00000   127:#    $outputFile = $g->toZVF();
        0   0.00000   0.00000   128:#    print $g->getPropertyText() if $verbose;
        0   0.00000   0.00000   129:#
        0   0.00000   0.00000   130:#    $outputFile->writeFile();
        0   0.00000   0.00000   131:#    print "$name.zvf created\n\n" if
        0   0.00000   0.00000   132:}#}}}
        0   0.00000   0.00000   133:
        0   0.00000   0.00000   134:
        0   0.00000   0.00000   135:##
        0   0.00000   0.00000   136:# Sets member variables.
        0   0.00000   0.00000   137:# - If topology file is empty a new graph is
        0   0.00000   0.00000   138:# - If a graph is given it is taken instead
        0   0.00000   0.00000   139:# - Else a graph is created from topology
        0   0.00000   0.00000   140:sub _initTopology {#{{{
        4   0.00000   0.00000   141:    my $object = shift;
        4   0.00000   0.00000   142:    my $topologyFile = shift;
        4   0.00000   0.00000   143:    my $graph = shift;
        4   0.00000   0.00000   144:    my $config = Configuration::instance();
        4   0.00000   0.00000   145:    $topologyFile->filterFile();
        4   0.00000   0.00000   146:    $object->{TOPOLOGYFILE} = $topologyFile;
        0   0.00000   0.00000   147:
        4   0.00000   0.00000   148:    if(defined $graph){
        0   0.00000   0.00000   149:        $object->{GRAPH} = $graph;
        0   0.00000   0.00000   150:    } elsif($topologyFile->getLength() < 2){
        0   0.00000   0.00000   151:        $object->{GRAPH} = new Graph();
        0   0.00000   0.00000   152:    }else {
        4   0.00000   0.00000   153:        die "\nSyntax Error in ZVF!\n" if not
        4   0.00000   0.00000   154:        my @lines = $topologyFile-
        4   0.00000   0.00000   155:        my $g = Graph::Undirected-
        4   0.00000   0.00000   156:        my $netline = shift @lines;
        0   0.00000   0.00000   157:        #chomp $netline;
        4   0.00001   0.00000   158:        my @nets = split(",",$netline);
        4   0.00000   0.00000   159:        foreach my $net (@nets){
       62   0.00000   0.00000   160:            my @routers = ();
       62   0.00000   0.00000   161:            foreach my $line (@lines){
        0   0.00000   0.00000   162:                #chomp $line;
     1026   0.00046   0.01000   163:                if($line =~ /\b$net\b/){
      124   0.00000   0.00000   164:                    my $r = $line;
      124   0.00052   0.00000   165:                    $r =~ s/(.*) .*/$1/;
      124   0.00000   0.00000   166:                    push(@routers,$r);
        0   0.00000   0.00000   167:                }
        0   0.00000   0.00000   168:            }
           ================ SmallProf version 2.02 ================
                       Profile of ../modules/Topology.pm               Page 29
       =================================================================
    count wall tm  cpu time line
       62   0.00000   0.00000   169:            $g->add_edge(@routers);
       62   0.00000   0.00000   170:            $g->set_edge_attribute(@routers,
        0   0.00000   0.00000   171:        }
        4   0.00001   0.00000   172:        $object->{GRAPH} = $g;
        0   0.00000   0.00000   173:    }
        0   0.00000   0.00000   174:}#}}}
        0   0.00000   0.00000   175:
        0   0.00000   0.00000   176:##
        0   0.00000   0.00000   177:# Returns reference to a list of nets
        0   0.00000   0.00000   178:sub getNets {#{{{
        0   0.00000   0.00000   179:    my $object = shift;
        0   0.00000   0.00000   180:    my $zvf = $object->toZVF();
        0   0.00000   0.00000   181:    my @nets = split(",",$zvf->getLine(0));
        0   0.00000   0.00000   182:    return \@nets;
        0   0.00000   0.00000   183:}#}}}
        0   0.00000   0.00000   184:
        0   0.00000   0.00000   185:##
        0   0.00000   0.00000   186:# Returns a reference to a hash with all
        0   0.00000   0.00000   187:sub getRouters {#{{{
        4   0.00000   0.00000   188:    my $object = shift;
        4   0.00000   0.00000   189:    my $zvf = $object->toZVF();
        4   0.00000   0.00000   190:    my @lines = $zvf->getLineArray();
        4   0.00000   0.00000   191:    shift @lines;
        4   0.00000   0.00000   192:    my %routers;
        4   0.00000   0.00000   193:    foreach my $line (@lines) {
       58   0.00000   0.00000   194:        next if not $line =~ /^r/;
       54   0.00000   0.00000   195:        my ($router,$nets) = split("
       54   0.00000   0.00000   196:        $routers{$router} = $nets;
        0   0.00000   0.00000   197:    }
        4   0.00007   0.00000   198:    return \%routers;
        0   0.00000   0.00000   199:}#}}}
        0   0.00000   0.00000   200:
        0   0.00000   0.00000   201:
        0   0.00000   0.00000   202:##
        0   0.00000   0.00000   203:# Returns all routers connected to a given
        0   0.00000   0.00000   204:#
        0   0.00000   0.00000   205:# PARAMETERS:
        0   0.00000   0.00000   206:# $netName - name of net to get routers
        0   0.00000   0.00000   207:#
        0   0.00000   0.00000   208:# RETURNS:
        0   0.00000   0.00000   209:# List of routers connected to the given net
        0   0.00000   0.00000   210:sub getRoutersInNet {#{{{
     1256   0.00001   0.01000   211:    my $object = shift;
     1256   0.00025   0.01000   212:    my $netName = shift;
     1256   0.00001   0.00000   213:    my $topologyFile = $object-
        0   0.00000   0.00000   214:
     1256   0.00004   0.00000   215:    my @routers = $topologyFile-
     1256   0.00004   0.03000   216:    shift @routers;
     1256   0.00002   0.01000   217:    foreach my $r (@routers) {
     2512   0.00108   0.07000   218:        $r =~ s/^(r[0-9]+).*/$1/;
        0   0.00000   0.00000   219:    }
     1256   0.00132   0.00000   220:    @routers = sort @routers;
     1256   0.00118   0.02000   221:    return \@routers;
        0   0.00000   0.00000   222:}#}}}
        0   0.00000   0.00000   223:
        0   0.00000   0.00000   224:
           ================ SmallProf version 2.02 ================
                       Profile of ../modules/Topology.pm               Page 30
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   225:##
        0   0.00000   0.00000   226:# Returns the Path to the topology file
        0   0.00000   0.00000   227:sub getPath {#{{{
        0   0.00000   0.00000   228:    my $object = shift;
        0   0.00000   0.00000   229:    my $zvf = $object->{TOPOLOGYFILE};
        0   0.00000   0.00000   230:    return $zvf->getPath();
        0   0.00000   0.00000   231:}#}}}
        0   0.00000   0.00000   232:
        0   0.00000   0.00000   233:##
        0   0.00000   0.00000   234:# Returns the topology name without suffix
        0   0.00000   0.00000   235:sub getName {#{{{
        0   0.00000   0.00000   236:    my $object = shift;
        0   0.00000   0.00000   237:    my $zvf = $object->{TOPOLOGYFILE};
        0   0.00000   0.00000   238:    return $zvf->getName();
        0   0.00000   0.00000   239:}#}}}
        0   0.00000   0.00000   240:
        0   0.00000   0.00000   241:##
        0   0.00000   0.00000   242:# Sets a new graph
        0   0.00000   0.00000   243:sub setGraph {#{{{
        0   0.00000   0.00000   244:    my $object = shift;
        0   0.00000   0.00000   245:    my $g = shift;
        0   0.00000   0.00000   246:    $object->{GRAPH} = $g;
        0   0.00000   0.00000   247:}#}}}
        0   0.00000   0.00000   248:
        0   0.00000   0.00000   249:##
        0   0.00000   0.00000   250:# Returns the graph
        0   0.00000   0.00000   251:sub getGraph {#{{{
        0   0.00000   0.00000   252:    my $object = shift;
        0   0.00000   0.00000   253:    return $object->{GRAPH};
        0   0.00000   0.00000   254:}#}}}
        0   0.00000   0.00000   255:
        0   0.00000   0.00000   256:
        0   0.00000   0.00000   257:##
        0   0.00000   0.00000   258:# Substitutes each hyperedge of the graph
        0   0.00000   0.00000   259:sub _convertToRegularEdges {#{{{
        8   0.00000   0.00000   260:    my $object = shift;
        8   0.00000   0.00000   261:    my $g = $object->{GRAPH};
        8   0.00000   0.00000   262:    my @edges = $g->edges();
        8   0.00000   0.00000   263:    foreach my $edge (@edges) {
      124   0.00001   0.00000   264:        my @r = @{$edge};
      124   0.00046   0.00000   265:        if($#r > 1){
        0   0.00000   0.00000   266:            $g->delete_edge(@r);
        0   0.00000   0.00000   267:            foreach my $first(@r){
        0   0.00000   0.00000   268:                foreach my $second(@r){
        0   0.00000   0.00000   269:                    $g-
        0   0.00000   0.00000   270:                }
        0   0.00000   0.00000   271:            }
        0   0.00000   0.00000   272:        }
        0   0.00000   0.00000   273:    }
        8   0.00000   0.00000   274:    $object->{GRAPH} = $g;
        0   0.00000   0.00000   275:}#}}}
        0   0.00000   0.00000   276:
        0   0.00000   0.00000   277:##
        0   0.00000   0.00000   278:# Writes the graph to png file
        0   0.00000   0.00000   279:#
        0   0.00000   0.00000   280:# PARAMETERS:
           ================ SmallProf version 2.02 ================
                       Profile of ../modules/Topology.pm               Page 31
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   281:# $file - name of file to store image
        0   0.00000   0.00000   282:sub writeGraphImage {#{{{
        0   0.00000   0.00000   283:    my $object = shift;
        0   0.00000   0.00000   284:    my $file = shift;
        0   0.00000   0.00000   285:    my $graph = $object->{GRAPH};
        0   0.00000   0.00000   286:    my @edges = $graph->edges();
        0   0.00000   0.00000   287:    my @vertices = $graph->vertices();
        0   0.00000   0.00000   288:    my $config = Configuration::instance();
        0   0.00000   0.00000   289:    my $verbose = $config-
        0   0.00000   0.00000   290:
        0   0.00000   0.00000   291:    print "writing image: $file\n" if
        0   0.00000   0.00000   292:
        0   0.00000   0.00000   293:    # generating GraphViz object
        0   0.00000   0.00000   294:    my $gv = GraphViz->new(directed => 0);
        0   0.00000   0.00000   295:    foreach(@vertices){ $gv->add_node($_); }
        0   0.00000   0.00000   296:    foreach(@edges){
        0   0.00000   0.00000   297:        my @edge = @{$_};
        0   0.00000   0.00000   298:        my $name = "";
        0   0.00000   0.00000   299:        $name = $graph-
        0   0.00000   0.00000   300:        #print "netnames: ".$config-
        0   0.00000   0.00000   301:        if($config-
        0   0.00000   0.00000   302:            $gv->add_edge($edge[0] =>
        0   0.00000   0.00000   303:        } else {
        0   0.00000   0.00000   304:            $gv->add_edge($edge[0] =>
        0   0.00000   0.00000   305:        }
        0   0.00000   0.00000   306:    }
        0   0.00000   0.00000   307:
        0   0.00000   0.00000   308:    # writing png
        0   0.00000   0.00000   309:    my $png = $gv->as_png();
        0   0.00000   0.00000   310:    open(FILE,">$file");# || return 0;
        0   0.00000   0.00000   311:    print FILE $png;
        0   0.00000   0.00000   312:    close(FILE);
        0   0.00000   0.00000   313:
        0   0.00000   0.00000   314:    # free memory
        0   0.00000   0.00000   315:    $png = undef;
        0   0.00000   0.00000   316:    $gv = undef;
        0   0.00000   0.00000   317:
        0   0.00000   0.00000   318:    return 1;
        0   0.00000   0.00000   319:}#}}}
        0   0.00000   0.00000   320:
        0   0.00000   0.00000   321:##
        0   0.00000   0.00000   322:# Returns topology file object created from
        0   0.00000   0.00000   323:sub toZVF{#{{{
        8   0.00000   0.00000   324:    my $object = shift;
        8   0.00000   0.00000   325:    my $g = $object->{GRAPH};
        8   0.00000   0.00000   326:    my $topologyFile = $object-
        8   0.00000   0.00000   327:    return $topologyFile if $topologyFile-
        8   0.00000   0.00000   328:    my $output = "";
        8   0.00000   0.00000   329:    my @nets = $g->edges();
        8   0.00000   0.00000   330:    my %routers;
        8   0.00000   0.00000   331:    my $config = Configuration::instance();
        8   0.00000   0.00000   332:    my $index = 1;
        8   0.00026   0.00000   333:    foreach my $net(sort @nets) {
      124   0.00001   0.00000   334:        my @router = @{$net};
      124   0.00000   0.00000   335:        my $netName;
      124   0.00000   0.00000   336:        if($g->has_edge_attribute(@router,
           ================ SmallProf version 2.02 ================
                       Profile of ../modules/Topology.pm               Page 32
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   337:            $netName = $g-
        0   0.00000   0.00000   338:        } else {
        0   0.00000   0.00000   339:            $netName = "net$index";
        0   0.00000   0.00000   340:            $g-
        0   0.00000   0.00000   341:        }
      124   0.00000   0.00000   342:            $output .= "$netName,";
      124   0.00001   0.01000   343:        foreach my $r(@router) {
      248   0.00000   0.00000   344:            push(@{$routers{$r}},$netName);
        0   0.00000   0.00000   345:        }
      124   0.00000   0.00000   346:        $index++;
        0   0.00000   0.00000   347:    }
        8   0.00000   0.00000   348:    chop $output;
        8   0.00000   0.00000   349:    $output .= "\n\n";
        8   0.00003   0.00000   350:    foreach my $r(sort keys %routers){
      108   0.00000   0.00000   351:        my @n = @{$routers{$r}};
      108   0.00000   0.00000   352:        $output .= $r." ";
      108   0.00000   0.00000   353:        foreach(@n){
      248   0.00046   0.00000   354:            $output .= $_.",";
        0   0.00000   0.00000   355:        }
      108   0.00000   0.00000   356:        chop $output;
      108   0.00000   0.00000   357:        $output .= "\n";
        0   0.00000   0.00000   358:    }
        8   0.00000   0.00000   359:    my $properties = $object-
        8   0.00000   0.00000   360:    $topologyFile->clearFile();
        8   0.00000   0.00000   361:    $topologyFile-
        8   0.00000   0.00000   362:    $topologyFile->addLine($output);
        8   0.00001   0.00000   363:    $topologyFile->filterFile();
        8   0.00000   0.00000   364:    $object->_beautifyZVF();
        0   0.00000   0.00000   365:
        8   0.00022   0.00000   366:    return $topologyFile;
        0   0.00000   0.00000   367:}#}}}
        0   0.00000   0.00000   368:
        0   0.00000   0.00000   369:##
        0   0.00000   0.00000   370:# Calculates all properties of a graph. The
        0   0.00000   0.00000   371:#
        0   0.00000   0.00000   372:# - number of vertices
        0   0.00000   0.00000   373:# - number of edges
        0   0.00000   0.00000   374:# - diameter
        0   0.00000   0.00000   375:# - number of cycles
        0   0.00000   0.00000   376:# - clustering coefficient
        0   0.00000   0.00000   377:# - leaves
        0   0.00000   0.00000   378:# - articulations
        0   0.00000   0.00000   379:#
        0   0.00000   0.00000   380:# PARAMETERS:
        0   0.00000   0.00000   381:# $g - graph object to get properties from
        0   0.00000   0.00000   382:#
        0   0.00000   0.00000   383:# RETURNS:
        0   0.00000   0.00000   384:# Hash with all properties
        0   0.00000   0.00000   385:sub getGraphProperties {#{{{
        8   0.00000   0.00000   386:    my $object = shift;
        8   0.00000   0.00000   387:    my $g = $object->{GRAPH};
        8   0.00000   0.00000   388:    my $scenarioName = shift;
        8   0.00000   0.00000   389:    my $e = $g->edges();
        8   0.00000   0.00000   390:    my $v = $g->vertices();
        0   0.00000   0.00000   391:
        8   0.00000   0.00000   392:    my %properties;
           ================ SmallProf version 2.02 ================
                       Profile of ../modules/Topology.pm               Page 33
       =================================================================
    count wall tm  cpu time line
        8   0.00000   0.00000   393:    $properties{VERTICES} = $v;
        8   0.00000   0.00000   394:    $properties{EDGES} = $e;
        8   0.00000   0.00000   395:    $properties{DIAMETER} = $object-
        8   0.00000   0.00000   396:    $properties{CIRLES} = $e-$v+1;
        8   0.00000   0.00000   397:    $properties{CC} = $object-
        8   0.00000   0.00000   398:    my @leaves = $object->_getLeaves();
        8   0.00000   0.00000   399:    $properties{LEAVES} = \@leaves;
        8   0.00000   0.00000   400:    $object->_convertToRegularEdges();
        8   0.00000   0.00000   401:    $g = $object->{GRAPH};
        8   0.00000   0.00000   402:    my @articulations = $g-
        8   0.00000   0.00000   403:    $properties{ARTICULATIONS} =
        0   0.00000   0.00000   404:
        8   0.00003   0.00000   405:    return %properties;
        0   0.00000   0.00000   406:}#}}}
        0   0.00000   0.00000   407:
        0   0.00000   0.00000   408:##
        0   0.00000   0.00000   409:# Creates VNUML XML file from zvf-file
        0   0.00000   0.00000   410:#
        0   0.00000   0.00000   411:# RETURNS:
        0   0.00000   0.00000   412:# File object with xml content for VNUML
        0   0.00000   0.00000   413:sub toXML {#{{{
        0   0.00000   0.00000   414:    my $object = shift;
        0   0.00000   0.00000   415:    my $topologyFile = $object-
        0   0.00000   0.00000   416:    my $config = Configuration::instance();
        0   0.00000   0.00000   417:    my $outfile = File->new($topologyFile-
        0   0.00000   0.00000   418:    $outfile->clearFile();
        0   0.00000   0.00000   419:    print "Creating".$outfile-
        0   0.00000   0.00000   420:
        0   0.00000   0.00000   421:
        0   0.00000   0.00000   422:# Defining variables (wird bald
        0   0.00000   0.00000   423:    my $global="<?xml version=\"1.0\"
        0   0.00000   0.00000   424:    <!DOCTYPE vnuml SYSTEM \"".$config-
        0   0.00000   0.00000   425:
        0   0.00000   0.00000   426:    <vnuml>
        0   0.00000   0.00000   427:      <global>
        0   0.00000   0.00000   428:        <version>1.8</version>
        0   0.00000   0.00000   429:        <simulation_name>".$topologyFile-
        0   0.00000   0.00000   430:        <ssh_version>2</ssh_version>
        0   0.00000   0.00000   431:        <ssh_key>".$config-
        0   0.00000   0.00000   432:        <automac/>
        0   0.00000   0.00000   433:        <vm_mgmt type=\"private\"
        0   0.00000   0.00000   434:           <host_mapping/>
        0   0.00000   0.00000   435:        </vm_mgmt>
        0   0.00000   0.00000   436:        <vm_defaults ".$config-
        0   0.00000   0.00000   437:           <filesystem
        0   0.00000   0.00000   438:           <kernel>".$config-
        0   0.00000   0.00000   439:        </vm_defaults>
        0   0.00000   0.00000   440:      </global>\n";
        0   0.00000   0.00000   441:
        0   0.00000   0.00000   442:# the prefix
        0   0.00000   0.00000   443:# <net name="nameofnet"
        0   0.00000   0.00000   444:# is added later
        0   0.00000   0.00000   445:    my $net=" mode=\"".$config-
        0   0.00000   0.00000   446:
        0   0.00000   0.00000   447:# the start tag
        0   0.00000   0.00000   448:# <vm name="routername">
           ================ SmallProf version 2.02 ================
                       Profile of ../modules/Topology.pm               Page 34
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   449:# and the nets are added later
        0   0.00000   0.00000   450:    my $router="\n<forwarding type=\"ipv4\"
        0   0.00000   0.00000   451:
        0   0.00000   0.00000   452:        <filetree root=\"/etc/quagga\"
        0   0.00000   0.00000   453:          <exec seq=\"start\"
        0   0.00000   0.00000   454:          <exec seq=\"start\"
        0   0.00000   0.00000   455:          <exec seq=\"start\"
        0   0.00000   0.00000   456:          <exec seq=\"rip\"
        0   0.00000   0.00000   457:          <exec seq=\"ospf\"
        0   0.00000   0.00000   458:          <exec seq=\"stop\"
        0   0.00000   0.00000   459:          <exec seq=\"stop\"
        0   0.00000   0.00000   460:          <exec seq=\"stop\"
        0   0.00000   0.00000   461:          <exec seq=\"stop\"
        0   0.00000   0.00000   462:
        0   0.00000   0.00000   463:          <exec seq=\"rpfilter\" type=
        0   0.00000   0.00000   464:          for f in
        0   0.00000   0.00000   465:          </exec>
        0   0.00000   0.00000   466:        </vm>\n\n";
        0   0.00000   0.00000   467:#}}}
        0   0.00000   0.00000   468:
        0   0.00000   0.00000   469:# --------- start --------------
        0   0.00000   0.00000   470:
        0   0.00000   0.00000   471:    # read the file and store the lines to
        0   0.00000   0.00000   472:    return 0 if not $object-
        0   0.00000   0.00000   473:    return 0 if not $topologyFile-
        0   0.00000   0.00000   474:    my @zvfLines=$topologyFile-
        0   0.00000   0.00000   475:    my $output = "";
        0   0.00000   0.00000   476:
        0   0.00000   0.00000   477:    # determine the line where the nets are
        0   0.00000   0.00000   478:    my $firstNetLine = shift @zvfLines;
        0   0.00000   0.00000   479:
        0   0.00000   0.00000   480:    # create an array of nets from netline
        0   0.00000   0.00000   481:    my @nets = split(",",$firstNetLine);
        0   0.00000   0.00000   482:
        0   0.00000   0.00000   483:    if($#nets>254){
        0   0.00000   0.00000   484:        print "\nToo many nets! max is
        0   0.00000   0.00000   485:        exit 1;
        0   0.00000   0.00000   486:    }
        0   0.00000   0.00000   487:
        0   0.00000   0.00000   488:    if($#zvfLines > 254) {
        0   0.00000   0.00000   489:        print "\nToo many routers! Max is
        0   0.00000   0.00000   490:        exit 1;
        0   0.00000   0.00000   491:    }
        0   0.00000   0.00000   492:
        0   0.00000   0.00000   493:    $output .= $global."\n\n";
        0   0.00000   0.00000   494:
        0   0.00000   0.00000   495:    foreach my $netName (@nets)
        0   0.00000   0.00000   496:    {
        0   0.00000   0.00000   497:        chomp $netName;
        0   0.00000   0.00000   498:        $output .= "<net
        0   0.00000   0.00000   499:    }
        0   0.00000   0.00000   500:    $output .= "\n\n";
        0   0.00000   0.00000   501:
        0   0.00000   0.00000   502:    # for each routerline (line where a
        0   0.00000   0.00000   503:    foreach my $line (@zvfLines)
        0   0.00000   0.00000   504:    {
           ================ SmallProf version 2.02 ================
                       Profile of ../modules/Topology.pm               Page 35
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   505:        next if(not($line =~ /^r[0-
        0   0.00000   0.00000   506:
        0   0.00000   0.00000   507:        # create variables routerName and
        0   0.00000   0.00000   508:        my ($routerName, $netLine) =
        0   0.00000   0.00000   509:
        0   0.00000   0.00000   510:        #begin xml router definition
        0   0.00000   0.00000   511:        $output .= "<vm
        0   0.00000   0.00000   512:
        0   0.00000   0.00000   513:        # all nets of actual router are
        0   0.00000   0.00000   514:        my @netlist = split(",",$netLine);
        0   0.00000   0.00000   515:        my $id=1;
        0   0.00000   0.00000   516:
        0   0.00000   0.00000   517:        # for each net of the actual router
        0   0.00000   0.00000   518:        foreach my $actualNet (@netlist)
        0   0.00000   0.00000   519:        {
        0   0.00000   0.00000   520:            $output .= "  <if id=\"$id\"
        0   0.00000   0.00000   521:            # get number of net and router
        0   0.00000   0.00000   522:            my ($netNumber) = $actualNet =~
        0   0.00000   0.00000   523:            my ($routerNumber) = $routerName
        0   0.00000   0.00000   524:            $output .= "    <ipv4
        0   0.00000   0.00000   525:            $id++;
        0   0.00000   0.00000   526:        }
        0   0.00000   0.00000   527:        $output .= $router."\n";
        0   0.00000   0.00000   528:    }
        0   0.00000   0.00000   529:    $output .= "\n</vnuml>\n";
        0   0.00000   0.00000   530:    $outfile->addLine($output);
        0   0.00000   0.00000   531:
        0   0.00000   0.00000   532:    return $outfile;
        0   0.00000   0.00000   533:}#}}}
        0   0.00000   0.00000   534:
        0   0.00000   0.00000   535:##
        0   0.00000   0.00000   536:# Reformats a topology file.
        0   0.00000   0.00000   537:sub _beautifyZVF{#{{{
        8   0.00000   0.00000   538:    my $object = shift;
        8   0.00000   0.00000   539:    my $topologyFile = $object-
        8   0.00000   0.00000   540:    my @lines = $topologyFile-
        8   0.00000   0.00000   541:    my $netLine = shift @lines;
        0   0.00000   0.00000   542:
        0   0.00000   0.00000   543:    # TODO: bei routern und Netzen 0
        8   0.00013   0.00000   544:    $netLine = join(",",sort
        0   0.00000   0.00000   545:
        8   0.00000   0.00000   546:    my @output;
        8   0.00000   0.00000   547:    push(@output,$netLine."\n\n");
        8   0.00000   0.00000   548:    foreach my $routerLine (sort @lines){
      108   0.00001   0.01000   549:        next if $routerLine =~ /^$/;
      108   0.00000   0.00000   550:        my ($r,$nets) = split("
      108   0.00045   0.00000   551:        $nets = join(",",sort
      108   0.00000   0.00000   552:        $routerLine = $r." ".$nets;
      108   0.00001   0.00000   553:        push(@output,$routerLine);
        0   0.00000   0.00000   554:    }
        0   0.00000   0.00000   555:
        8   0.00000   0.00000   556:    $topologyFile->setLineArray(@output);
        8   0.00000   0.00000   557:    $object->{TOPOLOGYFILE} = $topologyFile;
        0   0.00000   0.00000   558:    # free memory
        8   0.00000   0.00000   559:    $netLine = undef;
        8   0.00000   0.00000   560:    @lines = ();
           ================ SmallProf version 2.02 ================
                       Profile of ../modules/Topology.pm               Page 36
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   561:}#}}}
        0   0.00000   0.00000   562:
        0   0.00000   0.00000   563:##
        0   0.00000   0.00000   564:# Checks topology file for syntax errors
        0   0.00000   0.00000   565:#
        0   0.00000   0.00000   566:# RETURNS:
        0   0.00000   0.00000   567:# 1 if successfull. Printing error message
        0   0.00000   0.00000   568:sub _checkZVFSyntax {#{{{
        4   0.00000   0.00000   569:    my $object = shift;
        4   0.00000   0.00000   570:    my $topologyFile = $object-
        0   0.00000   0.00000   571:
        4   0.00000   0.00000   572:    return 0 if not $topologyFile-
        4   0.00000   0.00000   573:    my $netLine = $topologyFile-
        0   0.00000   0.00000   574:
        4   0.00000   0.00000   575:    print "Error in Line 1: line must end
        4   0.00000   0.00000   576:    print "Error in Line 1: not allowed
        4   0.00002   0.00000   577:    my @nets = split(",",$netLine);
        4   0.00000   0.00000   578:    my %nethash;
        4   0.00000   0.00000   579:    foreach my $net (@nets){
       62   0.00000   0.00000   580:        print "Error in Line 1: net name not
       62   0.00000   0.00000   581:        print "Error in Line 1: net is
       62   0.00000   0.00000   582:        $nethash{$net} = 1;
        0   0.00000   0.00000   583:    }
        0   0.00000   0.00000   584:
        4   0.00000   0.00000   585:    return 0 if not $topologyFile-
        0   0.00000   0.00000   586:
        4   0.00000   0.00000   587:    my $lineNumber = 2;
        4   0.00000   0.00000   588:    my %routers;
        0   0.00000   0.00000   589:    #foreach my $line (@lines) {
        4   0.00000   0.00000   590:    while($topologyFile->hasLines()){
       54   0.00000   0.00000   591:        my $line = $topologyFile-
       54   0.00000   0.00000   592:        my @words = split(/\s+/,$line);
       54   0.00001   0.00000   593:        print "Error in Line $lineNumber:
       54   0.00000   0.00000   594:        print "Error in Line $lineNumber:
       54   0.00000   0.00000   595:        print "Error in Line $lineNumber: not
       54   0.00000   0.00000   596:        print "Error in Line $lineNumber: too
       54   0.00000   0.00000   597:        print "Error in Line $lineNumber:
       54   0.00000   0.00000   598:        $routers{$words[0]} = 1;
       54   0.00000   0.00000   599:        $lineNumber++;
        0   0.00000   0.00000   600:    }
        0   0.00000   0.00000   601:
        4   0.00000   0.00000   602:    $topologyFile->resetLinePointer();
        4   0.00001   0.00000   603:    return 1;
        0   0.00000   0.00000   604:
        0   0.00000   0.00000   605:}#}}}
        0   0.00000   0.00000   606:
        0   0.00000   0.00000   607:##
        0   0.00000   0.00000   608:# Returns the comments text for a topology
        0   0.00000   0.00000   609:sub _getPropertyText {#{{{
        8   0.00000   0.00000   610:    my $object = shift;
        8   0.00000   0.00000   611:    my $g = $object->{GRAPH};
        8   0.00000   0.00000   612:    my $scenarioName = $object-
        8   0.00000   0.00000   613:    my %graphProperties = $object-
        0   0.00000   0.00000   614:
        8   0.00000   0.00000   615:    my $properties = "# $scenarioName\n#\n"
        8   0.00000   0.00000   616:    $properties .= "# number of vertices:
           ================ SmallProf version 2.02 ================
                       Profile of ../modules/Topology.pm               Page 37
       =================================================================
    count wall tm  cpu time line
        8   0.00000   0.00000   617:    $properties .= "# number of edges:
        8   0.00004   0.00000   618:    $properties .= "# diameter:
        8   0.00000   0.00000   619:    $properties .= "# number of cycles:
        8   0.00000   0.00000   620:    $properties .= "# clustering coefficient:
        8   0.00000   0.00000   621:    my @leaves = @{$graphProperties{LEAVES}};
        8   0.00000   0.00000   622:    $properties .= "# leaves:
        8   0.00000   0.00000   623:    my @articulations =
        8   0.00000   0.00000   624:    $properties .= "# articulations:
        8   0.00005   0.00000   625:    return $properties;
        0   0.00000   0.00000   626:}#}}}
        0   0.00000   0.00000   627:
        0   0.00000   0.00000   628:
        0   0.00000   0.00000   629:##
        0   0.00000   0.00000   630:# Returns the clustering coefficient of the
        0   0.00000   0.00000   631:sub _getClusteringCoefficient {#{{{
        8   0.00000   0.00000   632:    my $object = shift;
        8   0.00000   0.00000   633:    my $g = $object->{GRAPH};
        8   0.00000   0.00000   634:    my $e=$g->edges();
        8   0.00000   0.00000   635:    my $v=$g->vertices();
        0   0.00000   0.00000   636:    #my $cc=($e+1)-($#vertices+1)+1;
        8   0.00000   0.00000   637:    my $cc = ($e+1)/((($v+1)*$v)/2);
        8   0.00000   0.01000   638:    return $cc;
        0   0.00000   0.00000   639:}#}}}
        0   0.00000   0.00000   640:
        0   0.00000   0.00000   641:
        0   0.00000   0.00000   642:##
        0   0.00000   0.00000   643:# Returns diameter of Graph with dijsktra
        0   0.00000   0.00000   644:sub _getDiameter {#{{{
        8   0.00000   0.00000   645:    my $object = shift;
        8   0.00000   0.00000   646:    my $g = $object->{GRAPH};
        8   0.00000   0.00000   647:    my @vertices = $g->vertices();
        8   0.00000   0.00000   648:    my $longest = 0;
        8   0.00000   0.00000   649:    for (my $i = 0; $i <= $#vertices; $i++) {
      108   0.00001   0.00000   650:        for (my $j = 0; $j <= $#vertices;
     1764   0.00004   0.03000   651:            my @sp = $g-
     1764   0.00003   0.04000   652:            $longest = $#sp if $#sp >
        0   0.00000   0.00000   653:    #        print "$vertices[$i] =>
      108   0.00000   0.00000   654:        }
        0   0.00000   0.00000   655:
        8   0.00000   0.00000   656:    }
        8   0.00000   0.00000   657:    return $longest;
        0   0.00000   0.00000   658:}#}}}
        0   0.00000   0.00000   659:
        0   0.00000   0.00000   660:##
        0   0.00000   0.00000   661:# Returns a list of leaves of the graph
        0   0.00000   0.00000   662:sub _getLeaves {#{{{
        8   0.00000   0.00000   663:    my $object = shift;
        8   0.00000   0.00000   664:    my $g = $object->{GRAPH};
        8   0.00000   0.00000   665:    my @edges = $g->edges();
        8   0.00000   0.00000   666:    my %routers;
        8   0.00000   0.00000   667:    foreach my $edge (@edges) {
      124   0.00000   0.00000   668:        my @rs = @{$edge};
      124   0.00008   0.00000   669:        foreach my $r (@rs) {
      248   0.00000   0.00000   670:            $routers{$r}++;
        0   0.00000   0.00000   671:        }
        0   0.00000   0.00000   672:    }
           ================ SmallProf version 2.02 ================
                       Profile of ../modules/Topology.pm               Page 38
       =================================================================
    count wall tm  cpu time line
        8   0.00000   0.00000   673:    my @result = ();
        8   0.00000   0.00000   674:    foreach my $r (keys %routers) {
      108   0.00000   0.00000   675:        push(@result,$r) if $routers{$r} ==
        0   0.00000   0.00000   676:    }
        0   0.00000   0.00000   677:
        8   0.00001   0.00000   678:    return @result;
        0   0.00000   0.00000   679:}#}}}
        0   0.00000   0.00000   680:
        0   0.00000   0.00000   681:1;
        0   0.00000   0.00000   682:
        0   0.00000   0.00000   683:
        0   0.00000   0.00000   684:# for a better use with vim. All the
        0   0.00000   0.00000   685:# vim: foldmethod=marker
           ================ SmallProf version 2.02 ================
                      Profile of ../modules/Utilities.pm               Page 39
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:# vim: foldmethod=marker
        0   0.00000   0.00000     2:
        0   0.00000   0.00000     3:#
        0   0.00000   0.00000     4:# Package: Utilities
        0   0.00000   0.00000     5:#
        0   0.00000   0.00000     6:# Provides general functions like
        0   0.00000   0.00000     7:package Utilities;
        0   0.00000   0.00000     8:require Exporter;
        0   0.00000   0.00000     9:@ISA = qw(Exporter);
        0   0.00000   0.00000    10:@EXPORT =
        0   0.00000   0.00000    11:  qw(makeTimeStamp makeTime remove getTime
        0   0.00000   0.00000    12:
        0   0.00000   0.00000    13:use strict;
        0   0.00000   0.00000    14:use warnings;
        0   0.00000   0.00000    15:
        0   0.00000   0.00000    16:use lib ".";
        0   0.00000   0.00000    17:use File;
        0   0.00000   0.00000    18:
        0   0.00000   0.00000    19:##
        0   0.00000   0.00000    20:# Creates timestamp (time in s) from
        0   0.00000   0.00000    21:#
        0   0.00000   0.00000    22:# PARAMETERS:
        0   0.00000   0.00000    23:# $timestring - string with time from tcpdump
        0   0.00000   0.00000    24:#
        0   0.00000   0.00000    25:# RETURNS:
        0   0.00000   0.00000    26:# timestamp in s from 0:00 o'clock that day
        0   0.00000   0.00000    27:sub makeTimeStamp {#{{{
     2887   0.00118   0.01000    28: my $timestring=shift;
     2887   0.00011   0.03000    29:    return $timestring if not $timestring =~
     2887   0.00097   0.03000    30: my @timearray=split("[:\.]",$timestring);
     2887   0.00050   0.01000    31: my $timestamp=$timearray[0]*60*60*1000000;
     2887   0.00118   0.02000    32: $timestamp+=$timearray[1]*60*1000000;
     2887   0.00004   0.04000    33: $timestamp+=$timearray[2]*1000000;
        0   0.00000   0.00000    34:    #while(length($timearray[3])<6){
     2887   0.00001   0.00000    35: $timestamp+=$timearray[3];
        0   0.00000   0.00000    36:
     2887   0.00768   0.04000    37: return $timestamp;
        0   0.00000   0.00000    38:}#}}}
        0   0.00000   0.00000    39:
        0   0.00000   0.00000    40:##
        0   0.00000   0.00000    41:# Creates string with hour, min, sec, sec
        0   0.00000   0.00000    42:#
        0   0.00000   0.00000    43:# PARAMETERS:
        0   0.00000   0.00000    44:# $timestamp - timestamp generated with
        0   0.00000   0.00000    45:#
        0   0.00000   0.00000    46:# RETURNS:
        0   0.00000   0.00000    47:# human readable timestring
        0   0.00000   0.00000    48:sub makeTime {#{{{
        4   0.00000   0.00000    49: my $timestamp = shift;
        4   0.00000   0.00000    50:    return $timestamp if $timestamp =~ /:/;
        4   0.00000   0.00000    51: my $hour=int($timestamp/60/60/1000000);
        4   0.00000   0.00000    52: my $min=int($timestamp/60/1000000)-$hour*60;
        4   0.00000   0.00000    53: my $sec=int($timestamp/1000000)-$min*60-
        4   0.00000   0.00000    54: my $msec=int($timestamp)-$hour*3600*1000000-
        4   0.00000   0.00000    55: $hour = "0".$hour if(int($hour/10) == 0);
        4   0.00000   0.00000    56: $min = "0".$min if(int($min/10) == 0);
           ================ SmallProf version 2.02 ================
                      Profile of ../modules/Utilities.pm               Page 40
       =================================================================
    count wall tm  cpu time line
        4   0.00000   0.00000    57: $sec = "0".$sec if(int($sec/10) == 0);
        4   0.00000   0.00000    58:    while(length($msec)<6){ $msec =
        0   0.00000   0.00000    59:
        4   0.00000   0.00000    60: my $time =
        4   0.00171   0.00000    61: return ($time);
        0   0.00000   0.00000    62:}#}}}
        0   0.00000   0.00000    63:
        0   0.00000   0.00000    64:##
        0   0.00000   0.00000    65:# Removes all items of a list from another
        0   0.00000   0.00000    66:#
        0   0.00000   0.00000    67:# PARAMETERS:
        0   0.00000   0.00000    68:# $listReference - reference of list where
        0   0.00000   0.00000    69:# $deleteListReference - reference of list
        0   0.00000   0.00000    70:#
        0   0.00000   0.00000    71:# RETURNS:
        0   0.00000   0.00000    72:# list with removed items
        0   0.00000   0.00000    73:sub remove {#{{{
        0   0.00000   0.00000    74:    my ($listReference,$deleteListReference)
        0   0.00000   0.00000    75:    my @list = @{$listReference};
        0   0.00000   0.00000    76:    my @deleteList = @{$deleteListReference};
        0   0.00000   0.00000    77:    my @newList = ();
        0   0.00000   0.00000    78:
        0   0.00000   0.00000    79:    foreach my $item (@list) {
        0   0.00000   0.00000    80:        my $ok = 1;
        0   0.00000   0.00000    81:        foreach my $deleteItem (@deleteList)
        0   0.00000   0.00000    82:            if($item eq $deleteItem){
        0   0.00000   0.00000    83:                $ok = 0;
        0   0.00000   0.00000    84:                last;
        0   0.00000   0.00000    85:            }
        0   0.00000   0.00000    86:        }
        0   0.00000   0.00000    87:        push(@newList,$item) if $ok == 1;
        0   0.00000   0.00000    88:    }
        0   0.00000   0.00000    89:    return @newList;
        0   0.00000   0.00000    90:}#}}}
        0   0.00000   0.00000    91:
        0   0.00000   0.00000    92:##
        0   0.00000   0.00000    93:# Returns actual time as string
        0   0.00000   0.00000    94:sub getTime {#{{{
        0   0.00000   0.00000    95:    my $time = `date +"%H:%M:%S.%N"`;
        0   0.00000   0.00000    96:    chop $time;
        0   0.00000   0.00000    97:    chop $time;
        0   0.00000   0.00000    98:    chop $time;
        0   0.00000   0.00000    99:    chop $time;
        0   0.00000   0.00000   100:
        0   0.00000   0.00000   101:    return $time;
        0   0.00000   0.00000   102:}#}}}
        0   0.00000   0.00000   103:
        0   0.00000   0.00000   104:##
        0   0.00000   0.00000   105:# Returns actual time as timestamp
        0   0.00000   0.00000   106:sub getTimeStamp {#{{{
        0   0.00000   0.00000   107:    my $time = getTime();
        0   0.00000   0.00000   108:    my $timeStamp =
        0   0.00000   0.00000   109:
        0   0.00000   0.00000   110:    return $timeStamp;
        0   0.00000   0.00000   111:}#}}}
        0   0.00000   0.00000   112:
           ================ SmallProf version 2.02 ================
                      Profile of ../modules/Utilities.pm               Page 41
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   113:
        0   0.00000   0.00000   114:##
        0   0.00000   0.00000   115:# Merges multiple hashes together
        0   0.00000   0.00000   116:#
        0   0.00000   0.00000   117:# PARAMETERS:
        0   0.00000   0.00000   118:# @hashArray - list of hash references
        0   0.00000   0.00000   119:#
        0   0.00000   0.00000   120:# RETURNS:
        0   0.00000   0.00000   121:# hash containing the key-value pairs of each
        0   0.00000   0.00000   122:#sub mergeHashes {#{{{
        0   0.00000   0.00000   123:#    my @hashArray = @_;
        0   0.00000   0.00000   124:#    my %resultHash;
        0   0.00000   0.00000   125:#    foreach my $hash (@hashArray){
        0   0.00000   0.00000   126:#        my %actualHash = %{$hash};
        0   0.00000   0.00000   127:#        foreach my $timeStamp (sort keys
        0   0.00000   0.00000   128:#            my $offset = 0;
        0   0.00000   0.00000   129:#            while(defined
        0   0.00000   0.00000   130:#                $offset++;
        0   0.00000   0.00000   131:#            }
        0   0.00000   0.00000   132:#            $resultHash{$timeStamp+$offset}
        0   0.00000   0.00000   133:#        }
        0   0.00000   0.00000   134:#    }
        0   0.00000   0.00000   135:#    return %resultHash;
        0   0.00000   0.00000   136:#}#}}}
        0   0.00000   0.00000   137:
        0   0.00000   0.00000   138:
        0   0.00000   0.00000   139:sub getResultFiles {#{{{
        0   0.00000   0.00000   140:    my $zvfFile = shift;
        0   0.00000   0.00000   141:    my ($topologyName,$baseDirectory,@ls) =
        0   0.00000   0.00000   142:    my @result = ();
        0   0.00000   0.00000   143:    foreach my $dir (@ls) {
        0   0.00000   0.00000   144:        chomp $dir;
        0   0.00000   0.00000   145:        my $resultFileName =
        0   0.00000   0.00000   146:        #print "resultfile:
        0   0.00000   0.00000   147:        push(@result,new
        0   0.00000   0.00000   148:    }
        0   0.00000   0.00000   149:    return @result;
        0   0.00000   0.00000   150:}#}}}
        0   0.00000   0.00000   151:
        0   0.00000   0.00000   152:sub getSimulationDirectory {#{{{
        0   0.00000   0.00000   153:    my $zvfFile = shift;
        0   0.00000   0.00000   154:    my $topologyName = $zvfFile->getName();
        0   0.00000   0.00000   155:    my $baseDirectory = $zvfFile-
        0   0.00000   0.00000   156:    $baseDirectory = "" if not defined
        0   0.00000   0.00000   157:    my $executionString = "ls $baseDirectory
        0   0.00000   0.00000   158:    #print "execstring: $executionString\n";
        0   0.00000   0.00000   159:    my @ls = `$executionString`; # getting
        0   0.00000   0.00000   160:    return ($topologyName,$baseDirectory,@ls)
        0   0.00000   0.00000   161:#    if($#ls > 0){#{{{
        0   0.00000   0.00000   162:#        while(1){
        0   0.00000   0.00000   163:#
        0   0.00000   0.00000   164:#            my $choice = "";
        0   0.00000   0.00000   165:#            print "\n\nPlease choose
        0   0.00000   0.00000   166:#            my $x = 0;
        0   0.00000   0.00000   167:#            foreach my $d (@ls) {
        0   0.00000   0.00000   168:#                chomp $d;
           ================ SmallProf version 2.02 ================
                      Profile of ../modules/Utilities.pm               Page 42
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   169:#                $x++;
        0   0.00000   0.00000   170:#                print "\t[$x] : $d\n";
        0   0.00000   0.00000   171:#            }
        0   0.00000   0.00000   172:#            print "Press x to exit.\n";
        0   0.00000   0.00000   173:#            print "Insert number of
        0   0.00000   0.00000   174:#            $choice = <STDIN>;
        0   0.00000   0.00000   175:#            chomp $choice;
        0   0.00000   0.00000   176:#            print "choice: $choice\n";
        0   0.00000   0.00000   177:#
        0   0.00000   0.00000   178:#            print "\nExiting\n" and exit 0
        0   0.00000   0.00000   179:#            print "\nTaking all: @ls\n" and
        0   0.00000   0.00000   180:#            print "\nPlease choose one of
        0   0.00000   0.00000   181:#            print "\nPlease choose one of
        0   0.00000   0.00000   182:#
        0   0.00000   0.00000   183:#            if($choice =~ /[0-9]+/){
        0   0.00000   0.00000   184:#                print "\nTaking $x-2. item:
        0   0.00000   0.00000   185:#                return
        0   0.00000   0.00000   186:#            }
        0   0.00000   0.00000   187:#
        0   0.00000   0.00000   188:#        }
        0   0.00000   0.00000   189:#    } elsif($#ls==0){
        0   0.00000   0.00000   190:#                return
        0   0.00000   0.00000   191:#    } else {
        0   0.00000   0.00000   192:#        return 0;
        0   0.00000   0.00000   193:#    }#}}}
        0   0.00000   0.00000   194:}#}}}
        0   0.00000   0.00000   195:
        0   0.00000   0.00000   196:1;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 43
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:package Graph;
        0   0.00000   0.00000     2:
        0   0.00000   0.00000     3:use strict;
        0   0.00000   0.00000     4:
        0   0.00000   0.00000     5:BEGIN {
        0   0.00000   0.00000     6:    if (0) { # SET THIS TO ZERO FOR TESTING
        0   0.00000   0.00000     7: $SIG{__DIE__ } = \&__carp_confess;
        0   0.00000   0.00000     8: $SIG{__WARN__} = \&__carp_confess;
        0   0.00000   0.00000     9:    }
        0   0.00000   0.00000    10:    sub __carp_confess { require Carp;
        0   0.00000   0.00000    11:}
        0   0.00000   0.00000    12:
        0   0.00000   0.00000    13:use Graph::AdjacencyMap qw(:flags :fields);
        0   0.00000   0.00000    14:
        0   0.00000   0.00000    15:use vars qw($VERSION);
        0   0.00000   0.00000    16:
        0   0.00000   0.00000    17:$VERSION = '0.91';
        0   0.00000   0.00000    18:
        0   0.00000   0.00000    19:require 5.006; # Weak references are
        0   0.00000   0.00000    20:
        0   0.00000   0.00000    21:my $can_deep_copy_Storable =
        0   0.00000   0.00000    22:    eval 'require Storable; require
        0   0.00000   0.00000    23:
        0   0.00000   0.00000    24:sub _can_deep_copy_Storable () {
        0   0.00000   0.00000    25:    return $can_deep_copy_Storable;
        0   0.00000   0.00000    26:}
        0   0.00000   0.00000    27:
        0   0.00000   0.00000    28:use Graph::AdjacencyMap::Heavy;
        0   0.00000   0.00000    29:use Graph::AdjacencyMap::Light;
        0   0.00000   0.00000    30:use Graph::AdjacencyMap::Vertex;
        0   0.00000   0.00000    31:use Graph::UnionFind;
        0   0.00000   0.00000    32:use Graph::TransitiveClosure;
        0   0.00000   0.00000    33:use Graph::Traversal::DFS;
        0   0.00000   0.00000    34:use Graph::MSTHeapElem;
        0   0.00000   0.00000    35:use Graph::SPTHeapElem;
        0   0.00000   0.00000    36:use Graph::Undirected;
        0   0.00000   0.00000    37:
        0   0.00000   0.00000    38:use Heap071::Fibonacci;
        0   0.00000   0.00000    39:use List::Util qw(shuffle first);
        0   0.00000   0.00000    40:use Scalar::Util qw(weaken);
        0   0.00000   0.00000    41:
        0   0.00000   0.00000    42:use Safe;  # For deep_copy().
        0   0.00000   0.00000    43:
        0   0.00000   0.00000    44:sub _F () { 0 } # Flags.
        0   0.00000   0.00000    45:sub _G () { 1 } # Generation.
        0   0.00000   0.00000    46:sub _V () { 2 } # Vertices.
        0   0.00000   0.00000    47:sub _E () { 3 } # Edges.
        0   0.00000   0.00000    48:sub _A () { 4 } # Attributes.
        0   0.00000   0.00000    49:sub _U () { 5 } # Union-Find.
        0   0.00000   0.00000    50:sub _S () { 6 } # Successors.
        0   0.00000   0.00000    51:sub _P () { 7 } # Predecessors.
        0   0.00000   0.00000    52:
        0   0.00000   0.00000    53:my $Inf;
        0   0.00000   0.00000    54:
        0   0.00000   0.00000    55:BEGIN {
        0   0.00000   0.00000    56:    local $SIG{FPE};
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 44
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000    57:    eval { $Inf = exp(999) } ||
        0   0.00000   0.00000    58: eval { $Inf = 9**9**9 } ||
        0   0.00000   0.00000    59:     eval { $Inf = 1e+999 } ||
        0   0.00000   0.00000    60:  { $Inf = 1e+99 };  # Close enough for most
        0   0.00000   0.00000    61:}
        0   0.00000   0.00000    62:
        0   0.00000   0.00000    63:sub Infinity () { $Inf }
        0   0.00000   0.00000    64:
        0   0.00000   0.00000    65:# Graphs are blessed array references.
        0   0.00000   0.00000    66:# - The first element contains the flags.
        0   0.00000   0.00000    67:# - The second element is the vertices.
        0   0.00000   0.00000    68:# - The third element is the edges.
        0   0.00000   0.00000    69:# - The fourth element is the attributes of
        0   0.00000   0.00000    70:# The defined flags for Graph are:
        0   0.00000   0.00000    71:# - _COMPAT02 for user API compatibility with
        0   0.00000   0.00000    72:# The vertices are contained in either a
        0   0.00000   0.00000    73:# (if no hypervertices) or in a "map".
        0   0.00000   0.00000    74:# The edges are always in a "map".
        0   0.00000   0.00000    75:# The defined flags for maps are:
        0   0.00000   0.00000    76:# - _COUNT for countedness: more than one
        0   0.00000   0.00000    77:# - _HYPER for hyperness: a different number
        0   0.00000   0.00000    78:#   expects one for vertices and two for
        0   0.00000   0.00000    79:# - _UNORD for unordered coordinates (a set):
        0   0.00000   0.00000    80:#   the coordinates are assumed to be
        0   0.00000   0.00000    81:# - _UNIQ for unique coordinates: if set
        0   0.00000   0.00000    82:#   if not, duplicates are assumed to
        0   0.00000   0.00000    83:# - _UNORDUNIQ: just a union of _UNORD and
        0   0.00000   0.00000    84:# Vertices are assumed to be _UNORDUNIQ;
        0   0.00000   0.00000    85:
        0   0.00000   0.00000    86:use Graph::Attribute array => _A, map =>
        0   0.00000   0.00000    87:
        0   0.00000   0.00000    88:sub _COMPAT02 () { 0x00000001 }
        0   0.00000   0.00000    89:
        0   0.00000   0.00000    90:sub stringify {
        0   0.00000   0.00000    91:    my $g = shift;
        0   0.00000   0.00000    92:    my $u = $g->is_undirected;
        0   0.00000   0.00000    93:    my $e = $u ? '=' : '-';
        0   0.00000   0.00000    94:    my @e =
        0   0.00000   0.00000    95: map {
        0   0.00000   0.00000    96:     my @v =
        0   0.00000   0.00000    97:  map {
        0   0.00000   0.00000    98:      ref($_) eq 'ARRAY' ? "[" . join(" ",
        0   0.00000   0.00000    99:  }
        0   0.00000   0.00000   100:     @$_;
        0   0.00000   0.00000   101:     join($e, $u ? sort { "$a" cmp "$b" } @v
        0   0.00000   0.00000   102:    my @s = sort { "$a" cmp "$b" } @e;
        0   0.00000   0.00000   103:    push @s, sort { "$a" cmp "$b" } $g-
        0   0.00000   0.00000   104:    join(",", @s);
        0   0.00000   0.00000   105:}
        0   0.00000   0.00000   106:
        0   0.00000   0.00000   107:sub eq {
        0   0.00000   0.00000   108:    "$_[0]" eq "$_[1]"
        0   0.00000   0.00000   109:}
        0   0.00000   0.00000   110:
        0   0.00000   0.00000   111:sub ne {
        0   0.00000   0.00000   112:    "$_[0]" ne "$_[1]"
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 45
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   113:}
        0   0.00000   0.00000   114:
        0   0.00000   0.00000   115:use overload
        0   0.00000   0.00000   116:    '""' => \&stringify,
        0   0.00000   0.00000   117:    'eq' => \&eq,
        0   0.00000   0.00000   118:    'ne' => \&ne;
        0   0.00000   0.00000   119:
        0   0.00000   0.00000   120:sub _opt {
      174   0.00001   0.01000   121:    my ($opt, $flags, %flags) = @_;
      174   0.00004   0.00000   122:    while (my ($flag, $FLAG) = each %flags) {
      754   0.00002   0.01000   123: if (exists $opt->{$flag}) {
       62   0.00000   0.00000   124:     $$flags |= $FLAG if $opt->{$flag};
       62   0.00000   0.00000   125:     delete $opt->{$flag};
        0   0.00000   0.00000   126: }
      754   0.00002   0.01000   127: if (exists $opt->{my $non = "non$flag"}) {
        0   0.00000   0.00000   128:     $$flags &= ~$FLAG if $opt->{$non};
        0   0.00000   0.00000   129:     delete $opt->{$non};
        0   0.00000   0.00000   130: }
        0   0.00000   0.00000   131:    }
        0   0.00000   0.00000   132:}
        0   0.00000   0.00000   133:
        0   0.00000   0.00000   134:sub is_compat02 {
     2002   0.00002   0.03000   135:    my ($g) = @_;
     2002   0.00007   0.02000   136:    $g->[ _F ] & _COMPAT02;
        0   0.00000   0.00000   137:}
        0   0.00000   0.00000   138:
        0   0.00000   0.00000   139:*compat02 = \&is_compat02;
        0   0.00000   0.00000   140:
        0   0.00000   0.00000   141:sub has_union_find {
     1880   0.00003   0.04000   142:    my ($g) = @_;
     1880   0.00061   0.01000   143:    ($g->[ _F ] & _UNIONFIND) && defined $g-
        0   0.00000   0.00000   144:}
        0   0.00000   0.00000   145:
        0   0.00000   0.00000   146:sub _get_union_find {
        0   0.00000   0.00000   147:    my ($g) = @_;
        0   0.00000   0.00000   148:    $g->[ _U ];
        0   0.00000   0.00000   149:}
        0   0.00000   0.00000   150:
        0   0.00000   0.00000   151:sub _opt_get {
      116   0.00001   0.00000   152:    my ($opt, $key, $var) = @_;
      116   0.00000   0.00000   153:    if (exists $opt->{$key}) {
       58   0.00000   0.00000   154: $$var = $opt->{$key};
       58   0.00000   0.00000   155: delete $opt->{$key};
        0   0.00000   0.00000   156:    }
        0   0.00000   0.00000   157:}
        0   0.00000   0.00000   158:
        0   0.00000   0.00000   159:sub _opt_unknown {
       58   0.00000   0.00000   160:    my ($opt) = @_;
       58   0.00001   0.00000   161:    if (my @opt = keys %$opt) {
        0   0.00000   0.00000   162: my $f = (caller(1))[3];
        0   0.00000   0.00000   163: require Carp;
        0   0.00000   0.00000   164: Carp::confess(sprintf
        0   0.00000   0.00000   165:        "$f: Unknown option%s: @{[map {
        0   0.00000   0.00000   166:        @opt > 1 ? 's' : '');
        0   0.00000   0.00000   167:    }
        0   0.00000   0.00000   168:}
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 46
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   169:
        0   0.00000   0.00000   170:sub new {
       58   0.00000   0.00000   171:    my $class = shift;
       58   0.00000   0.00000   172:    my $gflags = 0;
       58   0.00000   0.00000   173:    my $vflags;
       58   0.00000   0.00000   174:    my $eflags;
       58   0.00000   0.00000   175:    my %opt = _get_options( \@_ );
        0   0.00000   0.00000   176:
       58   0.00000   0.00000   177:    if (ref $class && $class->isa('Graph')) {
        0   0.00000   0.00000   178: no strict 'refs';
        0   0.00000   0.00000   179:        for my $c (qw(undirected refvertexed
        0   0.00000   0.00000   180:                      hypervertexed
        0   0.00000   0.00000   181:                      hyperedged countedged
        0   0.00000   0.00000   182:#            $opt{$c}++ if $class->$c; #
        0   0.00000   0.00000   183:     if (&{"Graph::$c"}($class)) { $opt{$c}++
        0   0.00000   0.00000   184:        }
        0   0.00000   0.00000   185:#        $opt{unionfind}++ if $class-
        0   0.00000   0.00000   186: if (&{"Graph::has_union_find"}($class)) {
        0   0.00000   0.00000   187:    }
        0   0.00000   0.00000   188:
       58   0.00000   0.00000   189:    _opt_get(\%opt, undirected   =>
       58   0.00000   0.00000   190:    _opt_get(\%opt, omnidirected =>
        0   0.00000   0.00000   191:
       58   0.00000   0.00000   192:    if (exists $opt{directed}) {
        0   0.00000   0.00000   193: $opt{omniedged} = !$opt{directed};
        0   0.00000   0.00000   194: delete $opt{directed};
        0   0.00000   0.00000   195:    }
        0   0.00000   0.00000   196:
       58   0.00000   0.00000   197:    my $vnonomni =
        0   0.00000   0.00000   198: $opt{nonomnivertexed} ||
        0   0.00000   0.00000   199:     (exists $opt{omnivertexed} &&
       58   0.00000   0.00000   200:    my $vnonuniq =
        0   0.00000   0.00000   201: $opt{nonuniqvertexed} ||
        0   0.00000   0.00000   202:     (exists $opt{uniqvertexed} &&
        0   0.00000   0.00000   203:
       58   0.00001   0.00000   204:    _opt(\%opt, \$vflags,
        0   0.00000   0.00000   205:  countvertexed => _COUNT,
        0   0.00000   0.00000   206:  multivertexed => _MULTI,
        0   0.00000   0.00000   207:  hypervertexed => _HYPER,
        0   0.00000   0.00000   208:  omnivertexed => _UNORD,
        0   0.00000   0.00000   209:  uniqvertexed => _UNIQ,
        0   0.00000   0.00000   210:  refvertexed => _REF,
        0   0.00000   0.00000   211: );
        0   0.00000   0.00000   212:
       58   0.00001   0.01000   213:    _opt(\%opt, \$eflags,
        0   0.00000   0.00000   214:  countedged => _COUNT,
        0   0.00000   0.00000   215:  multiedged => _MULTI,
        0   0.00000   0.00000   216:  hyperedged => _HYPER,
        0   0.00000   0.00000   217:  omniedged => _UNORD,
        0   0.00000   0.00000   218:  uniqedged => _UNIQ,
        0   0.00000   0.00000   219: );
        0   0.00000   0.00000   220:
       58   0.00000   0.00000   221:    _opt(\%opt, \$gflags,
        0   0.00000   0.00000   222:  compat02      => _COMPAT02,
        0   0.00000   0.00000   223:  unionfind     => _UNIONFIND,
        0   0.00000   0.00000   224: );
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 47
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   225:
       58   0.00001   0.00000   226:    if (exists $opt{vertices_unsorted}) { #
        0   0.00000   0.00000   227: my $unsorted = $opt{vertices_unsorted};
        0   0.00000   0.00000   228: delete $opt{vertices_unsorted};
        0   0.00000   0.00000   229: require Carp;
        0   0.00000   0.00000   230: Carp::confess("Graph: vertices_unsorted must
        0   0.00000   0.00000   231:     unless $unsorted;
        0   0.00000   0.00000   232:    }
        0   0.00000   0.00000   233:
       58   0.00000   0.00000   234:    my @V;
       58   0.00001   0.00000   235:    if ($opt{vertices}) {
        0   0.00000   0.00000   236: require Carp;
        0   0.00000   0.00000   237: Carp::confess("Graph: vertices should be an
        0   0.00000   0.00000   238:     unless ref $opt{vertices} eq 'ARRAY';
        0   0.00000   0.00000   239: @V = @{ $opt{vertices} };
        0   0.00000   0.00000   240: delete $opt{vertices};
        0   0.00000   0.00000   241:    }
        0   0.00000   0.00000   242:
       58   0.00000   0.00000   243:    my @E;
       58   0.00000   0.00000   244:    if ($opt{edges}) {
        0   0.00000   0.00000   245: unless (ref $opt{edges} eq 'ARRAY') {
        0   0.00000   0.00000   246:     require Carp;
        0   0.00000   0.00000   247:     Carp::confess("Graph: edges should be an
        0   0.00000   0.00000   248: }
        0   0.00000   0.00000   249: @E = @{ $opt{edges} };
        0   0.00000   0.00000   250: delete $opt{edges};
        0   0.00000   0.00000   251:    }
        0   0.00000   0.00000   252:
       58   0.00000   0.00000   253:    _opt_unknown(\%opt);
        0   0.00000   0.00000   254:
       58   0.00000   0.00000   255:    my $uflags;
       58   0.00000   0.00000   256:    if (defined $vflags) {
        0   0.00000   0.00000   257: $uflags = $vflags;
        0   0.00000   0.00000   258: $uflags |= _UNORD unless $vnonomni;
        0   0.00000   0.00000   259: $uflags |= _UNIQ  unless $vnonuniq;
        0   0.00000   0.00000   260:    } else {
       58   0.00000   0.00000   261: $uflags = _UNORDUNIQ;
       58   0.00000   0.00000   262: $vflags = 0;
        0   0.00000   0.00000   263:    }
        0   0.00000   0.00000   264:
       58   0.00000   0.00000   265:    if (!($vflags & _HYPER) && ($vflags &
        0   0.00000   0.00000   266: my @but;
        0   0.00000   0.00000   267: push @but, 'unordered' if ($vflags &
        0   0.00000   0.00000   268: push @but, 'unique'    if ($vflags & _UNIQ);
        0   0.00000   0.00000   269: require Carp;
        0   0.00000   0.00000   270: Carp::confess(sprintf "Graph: not
        0   0.00000   0.00000   271:        join(' and ', @but));
        0   0.00000   0.00000   272:    }
        0   0.00000   0.00000   273:
       58   0.00000   0.00000   274:    unless (defined $eflags) {
        0   0.00000   0.00000   275: $eflags = ($gflags & _COMPAT02) ? _COUNT :
        0   0.00000   0.00000   276:    }
        0   0.00000   0.00000   277:
       58   0.00000   0.00000   278:    if (!($vflags & _HYPER) && ($vflags &
        0   0.00000   0.00000   279: require Carp;
        0   0.00000   0.00000   280: Carp::confess("Graph: not hypervertexed but
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 48
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   281:    }
        0   0.00000   0.00000   282:
       58   0.00000   0.00000   283:    if (($vflags & _COUNT) && ($vflags &
        0   0.00000   0.00000   284: require Carp;
        0   0.00000   0.00000   285: Carp::confess("Graph: both countvertexed and
        0   0.00000   0.00000   286:    }
        0   0.00000   0.00000   287:
       58   0.00000   0.00000   288:    if (($eflags & _COUNT) && ($eflags &
        0   0.00000   0.00000   289: require Carp;
        0   0.00000   0.00000   290: Carp::confess("Graph: both countedged and
        0   0.00000   0.00000   291:    }
        0   0.00000   0.00000   292:
       58   0.00006   0.00000   293:    my $g = bless [ ], ref $class || $class;
        0   0.00000   0.00000   294:
       58   0.00000   0.00000   295:    $g->[ _F ] = $gflags;
       58   0.00000   0.00000   296:    $g->[ _G ] = 0;
       58   0.00002   0.00000   297:    $g->[ _V ] = ($vflags & (_HYPER |
        0   0.00000   0.00000   298: Graph::AdjacencyMap::Heavy->_new($uflags, 1)
        0   0.00000   0.00000   299:     (($vflags & ~_UNORD) ?
        0   0.00000   0.00000   300:      Graph::AdjacencyMap::Vertex-
        0   0.00000   0.00000   301:      Graph::AdjacencyMap::Light->_new($g,
       58   0.00003   0.00000   302:    $g->[ _E ] = (($vflags & _HYPER) ||
        0   0.00000   0.00000   303: Graph::AdjacencyMap::Heavy->_new($eflags, 2)
        0   0.00000   0.00000   304:     Graph::AdjacencyMap::Light->_new($g,
        0   0.00000   0.00000   305:
       58   0.00000   0.00000   306:    $g->add_vertices(@V) if @V;
        0   0.00000   0.00000   307:
       58   0.00000   0.00000   308:    if (@E) {
        0   0.00000   0.00000   309: for my $e (@E) {
        0   0.00000   0.00000   310:     unless (ref $e eq 'ARRAY') {
        0   0.00000   0.00000   311:  require Carp;
        0   0.00000   0.00000   312:  Carp::confess("Graph: edges should be array
        0   0.00000   0.00000   313:     }
        0   0.00000   0.00000   314:     $g->add_edge(@$e);
        0   0.00000   0.00000   315: }
        0   0.00000   0.00000   316:    }
        0   0.00000   0.00000   317:
       58   0.00000   0.00000   318:    if (($gflags & _UNIONFIND)) {
        0   0.00000   0.00000   319: $g->[ _U ] = Graph::UnionFind->new;
        0   0.00000   0.00000   320:    }
        0   0.00000   0.00000   321:
       58   0.00009   0.00000   322:    return $g;
        0   0.00000   0.00000   323:}
        0   0.00000   0.00000   324:
     1796   0.00044   0.02000   325:sub countvertexed { $_[0]->[ _V ]->_is_COUNT
    10104   0.00331   0.11000   326:sub multivertexed { $_[0]->[ _V ]->_is_MULTI
        0   0.00000   0.00000   327:sub hypervertexed { $_[0]->[ _V ]->_is_HYPER
        0   0.00000   0.00000   328:sub omnivertexed  { $_[0]->[ _V ]->_is_UNORD
        0   0.00000   0.00000   329:sub uniqvertexed  { $_[0]->[ _V ]->_is_UNIQ
        0   0.00000   0.00000   330:sub refvertexed   { $_[0]->[ _V ]->_is_REF
        0   0.00000   0.00000   331:
      206   0.00000   0.00000   332:sub countedged    { $_[0]->[ _E ]->_is_COUNT
     3314   0.00052   0.01000   333:sub multiedged    { $_[0]->[ _E ]->_is_MULTI
        0   0.00000   0.00000   334:sub hyperedged    { $_[0]->[ _E ]->_is_HYPER
      944   0.00048   0.01000   335:sub omniedged     { $_[0]->[ _E ]->_is_UNORD
        0   0.00000   0.00000   336:sub uniqedged     { $_[0]->[ _E ]->_is_UNIQ
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 49
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   337:
        0   0.00000   0.00000   338:*undirected   = \&omniedged;
        0   0.00000   0.00000   339:*omnidirected = \&omniedged;
        0   0.00000   0.00000   340:sub directed { ! $_[0]->[ _E ]->_is_UNORD }
        0   0.00000   0.00000   341:
        0   0.00000   0.00000   342:*is_directed      = \&directed;
        0   0.00000   0.00000   343:*is_undirected    = \&undirected;
        0   0.00000   0.00000   344:
        0   0.00000   0.00000   345:*is_countvertexed = \&countvertexed;
        0   0.00000   0.00000   346:*is_multivertexed = \&multivertexed;
        0   0.00000   0.00000   347:*is_hypervertexed = \&hypervertexed;
        0   0.00000   0.00000   348:*is_omnidirected  = \&omnidirected;
        0   0.00000   0.00000   349:*is_uniqvertexed  = \&uniqvertexed;
        0   0.00000   0.00000   350:*is_refvertexed   = \&refvertexed;
        0   0.00000   0.00000   351:
        0   0.00000   0.00000   352:*is_countedged    = \&countedged;
        0   0.00000   0.00000   353:*is_multiedged    = \&multiedged;
        0   0.00000   0.00000   354:*is_hyperedged    = \&hyperedged;
        0   0.00000   0.00000   355:*is_omniedged     = \&omniedged;
        0   0.00000   0.00000   356:*is_uniqedged     = \&uniqedged;
        0   0.00000   0.00000   357:
        0   0.00000   0.00000   358:sub _union_find_add_vertex {
        0   0.00000   0.00000   359:    my ($g, $v) = @_;
        0   0.00000   0.00000   360:    my $UF = $g->[ _U ];
        0   0.00000   0.00000   361:    $UF->add( $g->[ _V ]->_get_path_id( $v )
        0   0.00000   0.00000   362:}
        0   0.00000   0.00000   363:
        0   0.00000   0.00000   364:sub add_vertex {
      936   0.00000   0.01000   365:    my $g = shift;
      936   0.00000   0.00000   366:    if ($g->is_multivertexed) {
        0   0.00000   0.00000   367: return $g->add_vertex_by_id(@_, _GEN_ID);
        0   0.00000   0.00000   368:    }
      936   0.00063   0.02000   369:    my @r;
      936   0.00000   0.00000   370:    if (@_ > 1) {
        0   0.00000   0.00000   371: unless ($g->is_countvertexed || $g-
        0   0.00000   0.00000   372:     require Carp;
        0   0.00000   0.00000   373:     Carp::croak("Graph::add_vertex: use
        0   0.00000   0.00000   374: }
        0   0.00000   0.00000   375: for my $v ( @_ ) {
        0   0.00000   0.00000   376:     if (defined $v) {
        0   0.00000   0.00000   377:  $g->[ _V ]->set_path( $v ) unless $g-
        0   0.00000   0.00000   378:     } else {
        0   0.00000   0.00000   379:  require Carp;
        0   0.00000   0.00000   380:  Carp::croak("Graph::add_vertex: undef
        0   0.00000   0.00000   381:     }
        0   0.00000   0.00000   382: }
        0   0.00000   0.00000   383:    }
      936   0.00001   0.00000   384:    for my $v ( @_ ) {
      936   0.00003   0.03000   385: unless (defined $v) {
        0   0.00000   0.00000   386:     require Carp;
        0   0.00000   0.00000   387:     Carp::croak("Graph::add_vertex: undef
        0   0.00000   0.00000   388: }
        0   0.00000   0.00000   389:    }
      936   0.00002   0.01000   390:    $g->[ _V ]->set_path( @_ );
      936   0.00003   0.01000   391:    $g->[ _G ]++;
      936   0.00161   0.00000   392:    $g->_union_find_add_vertex( @_ ) if $g-
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 50
       =================================================================
    count wall tm  cpu time line
      936   0.00001   0.02000   393:    return $g;
        0   0.00000   0.00000   394:}
        0   0.00000   0.00000   395:
        0   0.00000   0.00000   396:sub has_vertex {
     7372   0.01179   0.03000   397:    my $g = shift;
     7372   0.00154   0.08000   398:    my $V = $g->[ _V ];
     7372   0.00050   0.07000   399:    return exists $V->[ _s ]->{ $_[0] } if
     7318   0.00164   0.08000   400:    $V->has_path( @_ );
        0   0.00000   0.00000   401:}
        0   0.00000   0.00000   402:
        0   0.00000   0.00000   403:sub vertices05 {
     1854   0.00001   0.01000   404:    my $g = shift;
     1854   0.00010   0.03000   405:    my @v = $g->[ _V ]->paths( @_ );
     1854   0.05810   0.06000   406:    if (wantarray) {
        0   0.00000   0.00000   407: return $g->[ _V ]->_is_HYPER ?
        0   0.00000   0.00000   408:     @v : map { ref $_ eq 'ARRAY' ? @$_ : $_
        0   0.00000   0.00000   409:    } else {
        0   0.00000   0.00000   410: return scalar @v;
        0   0.00000   0.00000   411:    }
        0   0.00000   0.00000   412:}
        0   0.00000   0.00000   413:
        0   0.00000   0.00000   414:sub vertices {
     1796   0.00002   0.01000   415:    my $g = shift;
     1796   0.00972   0.01000   416:    my @v = $g->vertices05;
     1796   0.00852   0.02000   417:    if ($g->is_compat02) {
        0   0.00000   0.00000   418:        wantarray ? sort @v : scalar @v;
        0   0.00000   0.00000   419:    } else {
     1796   0.00007   0.03000   420: if ($g->is_multivertexed || $g-
        0   0.00000   0.00000   421:     if (wantarray) {
        0   0.00000   0.00000   422:  my @V;
        0   0.00000   0.00000   423:  for my $v ( @v ) {
        0   0.00000   0.00000   424:      push @V, ($v) x $g-
        0   0.00000   0.00000   425:  }
        0   0.00000   0.00000   426:  return @V;
        0   0.00000   0.00000   427:     } else {
        0   0.00000   0.00000   428:  my $V = 0;
        0   0.00000   0.00000   429:  for my $v ( @v ) {
        0   0.00000   0.00000   430:      $V += $g->get_vertex_count($v);
        0   0.00000   0.00000   431:  }
        0   0.00000   0.00000   432:  return $V;
        0   0.00000   0.00000   433:     }
        0   0.00000   0.00000   434: } else {
     1796   0.00790   0.02000   435:     return @v;
        0   0.00000   0.00000   436: }
        0   0.00000   0.00000   437:    }
        0   0.00000   0.00000   438:}
        0   0.00000   0.00000   439:
        0   0.00000   0.00000   440:*vertices_unsorted = \&vertices_unsorted; #
        0   0.00000   0.00000   441:
        0   0.00000   0.00000   442:sub unique_vertices {
        0   0.00000   0.00000   443:    my $g = shift;
        0   0.00000   0.00000   444:    my @v = $g->vertices05;
        0   0.00000   0.00000   445:    if ($g->is_compat02) {
        0   0.00000   0.00000   446:        wantarray ? sort @v : scalar @v;
        0   0.00000   0.00000   447:    } else {
        0   0.00000   0.00000   448: return @v;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 51
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   449:    }
        0   0.00000   0.00000   450:}
        0   0.00000   0.00000   451:
        0   0.00000   0.00000   452:sub has_vertices {
        0   0.00000   0.00000   453:    my $g = shift;
        0   0.00000   0.00000   454:    scalar $g->[ _V ]->has_paths( @_ );
        0   0.00000   0.00000   455:}
        0   0.00000   0.00000   456:
        0   0.00000   0.00000   457:sub _add_edge {
      944   0.00006   0.00000   458:    my $g = shift;
      944   0.00008   0.02000   459:    my $V = $g->[ _V ];
      944   0.00007   0.00000   460:    my @e;
      944   0.00005   0.01000   461:    if (($V->[ _f ]) & _LIGHT) {
       62   0.00000   0.01000   462: for my $v ( @_ ) {
      124   0.00000   0.00000   463:     $g->add_vertex( $v ) unless exists $V->[
      124   0.00000   0.00000   464:     push @e, $V->[ _s ]->{ $v };
        0   0.00000   0.00000   465: }
        0   0.00000   0.00000   466:    } else {
      882   0.00000   0.01000   467: my $h = $g->[ _V ]->_is_HYPER;
      882   0.00001   0.00000   468: for my $v ( @_ ) {
     1764   0.00001   0.02000   469:     my @v = ref $v eq 'ARRAY' && $h ? @$v :
     1764   0.00228   0.06000   470:     $g->add_vertex( @v ) unless $V-
     1764   0.00119   0.03000   471:     push @e, $V->_get_path_id( @v );
        0   0.00000   0.00000   472: }
        0   0.00000   0.00000   473:    }
      944   0.00002   0.02000   474:    return @e;
        0   0.00000   0.00000   475:}
        0   0.00000   0.00000   476:
        0   0.00000   0.00000   477:sub _union_find_add_edge {
        0   0.00000   0.00000   478:    my ($g, $u, $v) = @_;
        0   0.00000   0.00000   479:    $g->[ _U ]->union($u, $v);
        0   0.00000   0.00000   480:}
        0   0.00000   0.00000   481:
        0   0.00000   0.00000   482:sub add_edge {
      944   0.00000   0.00000   483:    my $g = shift;
      944   0.00001   0.00000   484:    if ($g->is_multiedged) {
        0   0.00000   0.00000   485: unless (@_ == 2 || $g->is_hyperedged) {
        0   0.00000   0.00000   486:     require Carp;
        0   0.00000   0.00000   487:     Carp::croak("Graph::add_edge: use
        0   0.00000   0.00000   488: }
        0   0.00000   0.00000   489: return $g->add_edge_by_id(@_, _GEN_ID);
        0   0.00000   0.00000   490:    }
      944   0.00020   0.00000   491:    unless (@_ == 2) {
        0   0.00000   0.00000   492: unless ($g->is_hyperedged) {
        0   0.00000   0.00000   493:     require Carp;
        0   0.00000   0.00000   494:     Carp::croak("Graph::add_edge: graph is
        0   0.00000   0.00000   495: }
        0   0.00000   0.00000   496:    }
      944   0.00001   0.02000   497:    my @e = $g->_add_edge( @_ );
      944   0.00002   0.00000   498:    $g->[ _E ]->set_path( @e );
      944   0.00001   0.00000   499:    $g->[ _G ]++;
      944   0.00001   0.01000   500:    $g->_union_find_add_edge( @e ) if $g-
      944   0.00005   0.00000   501:    return $g;
        0   0.00000   0.00000   502:}
        0   0.00000   0.00000   503:
        0   0.00000   0.00000   504:sub _vertex_ids {
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 52
       =================================================================
    count wall tm  cpu time line
     2992   0.00130   0.01000   505:    my $g = shift;
     2992   0.00011   0.04000   506:    my $V = $g->[ _V ];
     2992   0.00049   0.01000   507:    my @e;
     2992   0.00058   0.01000   508:    if (($V->[ _f ] & _LIGHT)) {
     1336   0.00002   0.04000   509: for my $v ( @_ ) {
     2672   0.00189   0.04000   510:     return () unless exists $V->[ _s ]->{ $v
     2672   0.00003   0.04000   511:     push @e, $V->[ _s ]->{ $v };
        0   0.00000   0.00000   512: }
        0   0.00000   0.00000   513:    } else {
     1656   0.00002   0.00000   514: my $h = $g->[ _V ]->_is_HYPER;
     1656   0.00009   0.03000   515: for my $v ( @_ ) {
     3258   0.00048   0.03000   516:     my @v = ref $v eq 'ARRAY' && $h ? @$v :
     3258   0.00057   0.00000   517:     return () unless $V->has_path( @v );
     3204   0.00046   0.03000   518:     push @e, $V->_get_path_id( @v );
        0   0.00000   0.00000   519: }
        0   0.00000   0.00000   520:    }
     2938   0.00259   0.02000   521:    return @e;
        0   0.00000   0.00000   522:}
        0   0.00000   0.00000   523:
        0   0.00000   0.00000   524:sub has_edge {
     2164   0.00005   0.03000   525:    my $g = shift;
     2164   0.00107   0.01000   526:    my $E = $g->[ _E ];
     2164   0.00048   0.01000   527:    my $V = $g->[ _V ];
     2164   0.00002   0.01000   528:    my @i;
     2164   0.00055   0.03000   529:    if (($V->[ _f ] & _LIGHT) && @_ == 2) {
     1336   0.00005   0.02000   530: return 0 unless
        0   0.00000   0.00000   531:     exists $V->[ _s ]->{ $_[0] } &&
        0   0.00000   0.00000   532:     exists $V->[ _s ]->{ $_[1] };
     1336   0.00048   0.03000   533: @i = @{ $V->[ _s ] }{ @_[ 0, 1 ] };
        0   0.00000   0.00000   534:    } else {
      828   0.00000   0.00000   535: @i = $g->_vertex_ids( @_ );
      828   0.00780   0.01000   536: return 0 if @i == 0 && @_;
        0   0.00000   0.00000   537:    }
     2110   0.00225   0.01000   538:    my $f = $E->[ _f ];
     2110   0.00003   0.04000   539:    if ($E->[ _a ] == 2 && @i == 2 && !($f &
      774   0.00002   0.01000   540: @i = sort @i if ($f & _UNORD);
      774   0.00000   0.00000   541: return exists $E->[ _s ]->{ $i[0] } &&
        0   0.00000   0.00000   542:        exists $E->[ _s ]->{ $i[0] }->{ $i[1]
        0   0.00000   0.00000   543:    } else {
     1336   0.00003   0.02000   544: return defined $E->_get_path_id( @i ) ? 1 :
        0   0.00000   0.00000   545:    }
        0   0.00000   0.00000   546:}
        0   0.00000   0.00000   547:
        0   0.00000   0.00000   548:sub edges05 {
      206   0.00001   0.00000   549:    my $g = shift;
      206   0.00000   0.00000   550:    my $V = $g->[ _V ];
      206   0.00000   0.00000   551:    my @e = $g->[ _E ]->paths( @_ );
        0   0.00000   0.00000   552:    wantarray ?
     1778   0.00001   0.01000   553: map { [ map { my @v = $V->_get_id_path($_);
     1030   0.00020   0.01000   554:        @v == 1 ? $v[0] : [ @v ] }
        0   0.00000   0.00000   555:  @$_ ] }
        0   0.00000   0.00000   556:            @e : @e;
        0   0.00000   0.00000   557:}
        0   0.00000   0.00000   558:
        0   0.00000   0.00000   559:sub edges02 {
        0   0.00000   0.00000   560:    my $g = shift;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 53
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   561:    if (@_ && defined $_[0]) {
        0   0.00000   0.00000   562: unless (defined $_[1]) {
        0   0.00000   0.00000   563:     my @e = $g->edges_at($_[0]);
        0   0.00000   0.00000   564:     wantarray ?
        0   0.00000   0.00000   565:  map { @$_ }
        0   0.00000   0.00000   566:                    sort { $a->[0] cmp $b-
        0   0.00000   0.00000   567:                : @e;
        0   0.00000   0.00000   568: } else {
        0   0.00000   0.00000   569:     die "edges02: unimplemented option";
        0   0.00000   0.00000   570: }
        0   0.00000   0.00000   571:    } else {
        0   0.00000   0.00000   572: my @e = map { ($_) x $g->get_edge_count(@$_)
        0   0.00000   0.00000   573: wantarray ?
        0   0.00000   0.00000   574:          map { @$_ }
        0   0.00000   0.00000   575:              sort { $a->[0] cmp $b->[0] ||
        0   0.00000   0.00000   576:          : @e;
        0   0.00000   0.00000   577:    }
        0   0.00000   0.00000   578:}
        0   0.00000   0.00000   579:
        0   0.00000   0.00000   580:sub unique_edges {
        0   0.00000   0.00000   581:    my $g = shift;
        0   0.00000   0.00000   582:    ($g->is_compat02) ? $g->edges02( @_ ) :
        0   0.00000   0.00000   583:}
        0   0.00000   0.00000   584:
        0   0.00000   0.00000   585:sub edges {
      206   0.00000   0.00000   586:    my $g = shift;
      206   0.00000   0.00000   587:    if ($g->is_compat02) {
        0   0.00000   0.00000   588: return $g->edges02( @_ );
        0   0.00000   0.00000   589:    } else {
      206   0.00049   0.00000   590: if ($g->is_multiedged || $g->is_countedged)
        0   0.00000   0.00000   591:     if (wantarray) {
        0   0.00000   0.00000   592:  my @E;
        0   0.00000   0.00000   593:  for my $e ( $g->edges05 ) {
        0   0.00000   0.00000   594:      push @E, ($e) x $g-
        0   0.00000   0.00000   595:  }
        0   0.00000   0.00000   596:  return @E;
        0   0.00000   0.00000   597:     } else {
        0   0.00000   0.00000   598:  my $E = 0;
        0   0.00000   0.00000   599:  for my $e ( $g->edges05 ) {
        0   0.00000   0.00000   600:      $E += $g->get_edge_count(@$e);
        0   0.00000   0.00000   601:  }
        0   0.00000   0.00000   602:  return $E;
        0   0.00000   0.00000   603:     }
        0   0.00000   0.00000   604: } else {
      206   0.00001   0.00000   605:     return $g->edges05;
        0   0.00000   0.00000   606: }
        0   0.00000   0.00000   607:    }
        0   0.00000   0.00000   608:}
        0   0.00000   0.00000   609:
        0   0.00000   0.00000   610:sub has_edges {
        0   0.00000   0.00000   611:    my $g = shift;
        0   0.00000   0.00000   612:    scalar $g->[ _E ]->has_paths( @_ );
        0   0.00000   0.00000   613:}
        0   0.00000   0.00000   614:
        0   0.00000   0.00000   615:###
        0   0.00000   0.00000   616:# by_id
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 54
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   617:#
        0   0.00000   0.00000   618:
        0   0.00000   0.00000   619:sub add_vertex_by_id {
        0   0.00000   0.00000   620:    my $g = shift;
        0   0.00000   0.00000   621:    $g->expect_multivertexed;
        0   0.00000   0.00000   622:    $g->[ _V ]->set_path_by_multi_id( @_ );
        0   0.00000   0.00000   623:    $g->[ _G ]++;
        0   0.00000   0.00000   624:    $g->_union_find_add_vertex( @_ ) if $g-
        0   0.00000   0.00000   625:    return $g;
        0   0.00000   0.00000   626:}
        0   0.00000   0.00000   627:
        0   0.00000   0.00000   628:sub add_vertex_get_id {
        0   0.00000   0.00000   629:    my $g = shift;
        0   0.00000   0.00000   630:    $g->expect_multivertexed;
        0   0.00000   0.00000   631:    my $id = $g->[ _V ]-
        0   0.00000   0.00000   632:    $g->[ _G ]++;
        0   0.00000   0.00000   633:    $g->_union_find_add_vertex( @_ ) if $g-
        0   0.00000   0.00000   634:    return $id;
        0   0.00000   0.00000   635:}
        0   0.00000   0.00000   636:
        0   0.00000   0.00000   637:sub has_vertex_by_id {
        0   0.00000   0.00000   638:    my $g = shift;
        0   0.00000   0.00000   639:    $g->expect_multivertexed;
        0   0.00000   0.00000   640:    $g->[ _V ]->has_path_by_multi_id( @_ );
        0   0.00000   0.00000   641:}
        0   0.00000   0.00000   642:
        0   0.00000   0.00000   643:sub delete_vertex_by_id {
        0   0.00000   0.00000   644:    my $g = shift;
        0   0.00000   0.00000   645:    $g->expect_multivertexed;
        0   0.00000   0.00000   646:    my $V = $g->[ _V ];
        0   0.00000   0.00000   647:    return unless $V->has_path_by_multi_id(
        0   0.00000   0.00000   648:    # TODO: what to about the edges at this
        0   0.00000   0.00000   649:    # If the multiness of this vertex goes to
        0   0.00000   0.00000   650:    $V->del_path_by_multi_id( @_ );
        0   0.00000   0.00000   651:    $g->[ _G ]++;
        0   0.00000   0.00000   652:    return $g;
        0   0.00000   0.00000   653:}
        0   0.00000   0.00000   654:
        0   0.00000   0.00000   655:sub get_multivertex_ids {
        0   0.00000   0.00000   656:    my $g = shift;
        0   0.00000   0.00000   657:    $g->expect_multivertexed;
        0   0.00000   0.00000   658:    $g->[ _V ]->get_multi_ids( @_ );
        0   0.00000   0.00000   659:}
        0   0.00000   0.00000   660:
        0   0.00000   0.00000   661:sub add_edge_by_id {
        0   0.00000   0.00000   662:    my $g = shift;
        0   0.00000   0.00000   663:    $g->expect_multiedged;
        0   0.00000   0.00000   664:    my $id = pop;
        0   0.00000   0.00000   665:    my @e = $g->_add_edge( @_ );
        0   0.00000   0.00000   666:    $g->[ _E ]->set_path_by_multi_id( @e, $id
        0   0.00000   0.00000   667:    $g->[ _G ]++;
        0   0.00000   0.00000   668:    $g->_union_find_add_edge( @e ) if $g-
        0   0.00000   0.00000   669:    return $g;
        0   0.00000   0.00000   670:}
        0   0.00000   0.00000   671:
        0   0.00000   0.00000   672:sub add_edge_get_id {
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 55
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   673:    my $g = shift;
        0   0.00000   0.00000   674:    $g->expect_multiedged;
        0   0.00000   0.00000   675:    my @i = $g->_add_edge( @_ );
        0   0.00000   0.00000   676:    my $id = $g->[ _E ]-
        0   0.00000   0.00000   677:    $g->_union_find_add_edge( @i ) if $g-
        0   0.00000   0.00000   678:    $g->[ _G ]++;
        0   0.00000   0.00000   679:    return $id;
        0   0.00000   0.00000   680:}
        0   0.00000   0.00000   681:
        0   0.00000   0.00000   682:sub has_edge_by_id {
        0   0.00000   0.00000   683:    my $g = shift;
        0   0.00000   0.00000   684:    $g->expect_multiedged;
        0   0.00000   0.00000   685:    my $id = pop;
        0   0.00000   0.00000   686:    my @i = $g->_vertex_ids( @_ );
        0   0.00000   0.00000   687:    return 0 if @i == 0 && @_;
        0   0.00000   0.00000   688:    $g->[ _E ]->has_path_by_multi_id( @i, $id
        0   0.00000   0.00000   689:}
        0   0.00000   0.00000   690:
        0   0.00000   0.00000   691:sub delete_edge_by_id {
        0   0.00000   0.00000   692:    my $g = shift;
        0   0.00000   0.00000   693:    $g->expect_multiedged;
        0   0.00000   0.00000   694:    my $V = $g->[ _E ];
        0   0.00000   0.00000   695:    my $id = pop;
        0   0.00000   0.00000   696:    my @i = $g->_vertex_ids( @_ );
        0   0.00000   0.00000   697:    return unless $V->has_path_by_multi_id(
        0   0.00000   0.00000   698:    $V->del_path_by_multi_id( @i, $id );
        0   0.00000   0.00000   699:    $g->[ _G ]++;
        0   0.00000   0.00000   700:    return $g;
        0   0.00000   0.00000   701:}
        0   0.00000   0.00000   702:
        0   0.00000   0.00000   703:sub get_multiedge_ids {
        0   0.00000   0.00000   704:    my $g = shift;
        0   0.00000   0.00000   705:    $g->expect_multiedged;
        0   0.00000   0.00000   706:    my @id = $g->_vertex_ids( @_ );
        0   0.00000   0.00000   707:    return unless @id;
        0   0.00000   0.00000   708:    $g->[ _E ]->get_multi_ids( @id );
        0   0.00000   0.00000   709:}
        0   0.00000   0.00000   710:
        0   0.00000   0.00000   711:###
        0   0.00000   0.00000   712:# Neighbourhood.
        0   0.00000   0.00000   713:#
        0   0.00000   0.00000   714:
        0   0.00000   0.00000   715:sub vertices_at {
        0   0.00000   0.00000   716:    my $g = shift;
        0   0.00000   0.00000   717:    my $V = $g->[ _V ];
        0   0.00000   0.00000   718:    return @_ unless ($V->[ _f ] & _HYPER);
        0   0.00000   0.00000   719:    my %v;
        0   0.00000   0.00000   720:    my @i;
        0   0.00000   0.00000   721:    for my $v ( @_ ) {
        0   0.00000   0.00000   722: my $i = $V->_get_path_id( $v );
        0   0.00000   0.00000   723: return unless defined $i;
        0   0.00000   0.00000   724: push @i, ( $v{ $v } = $i );
        0   0.00000   0.00000   725:    }
        0   0.00000   0.00000   726:    my $Vi = $V->_ids;
        0   0.00000   0.00000   727:    my @v;
        0   0.00000   0.00000   728:    while (my ($i, $v) = each %{ $Vi }) {
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 56
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   729: my %i;
        0   0.00000   0.00000   730: my $h = $V->[_f ] & _HYPER;
        0   0.00000   0.00000   731: @i{ @i } = @i if @i; # @todo: nonuniq hyper
        0   0.00000   0.00000   732: for my $u (ref $v eq 'ARRAY' && $h ? @$v :
        0   0.00000   0.00000   733:     my $j = exists $v{ $u } ? $v{ $u } : (
        0   0.00000   0.00000   734:     if (defined $j && exists $i{ $j }) {
        0   0.00000   0.00000   735:  delete $i{ $j };
        0   0.00000   0.00000   736:  unless (keys %i) {
        0   0.00000   0.00000   737:      push @v, $v;
        0   0.00000   0.00000   738:      last;
        0   0.00000   0.00000   739:  }
        0   0.00000   0.00000   740:     }
        0   0.00000   0.00000   741: }
        0   0.00000   0.00000   742:    }
        0   0.00000   0.00000   743:    return @v;
        0   0.00000   0.00000   744:}
        0   0.00000   0.00000   745:
        0   0.00000   0.00000   746:sub _edges_at {
        0   0.00000   0.00000   747:    my $g = shift;
        0   0.00000   0.00000   748:    my $V = $g->[ _V ];
        0   0.00000   0.00000   749:    my $E = $g->[ _E ];
        0   0.00000   0.00000   750:    my @e;
        0   0.00000   0.00000   751:    my $en = 0;
        0   0.00000   0.00000   752:    my %ev;
        0   0.00000   0.00000   753:    my $h = $V->[_f ] & _HYPER;
        0   0.00000   0.00000   754:    for my $v ( $h ? $g->vertices_at( @_ ) :
        0   0.00000   0.00000   755: my $vi = $V->_get_path_id( ref $v eq 'ARRAY'
        0   0.00000   0.00000   756: next unless defined $vi;
        0   0.00000   0.00000   757: my $Ei = $E->_ids;
        0   0.00000   0.00000   758: while (my ($ei, $ev) = each %{ $Ei }) {
        0   0.00000   0.00000   759:     if (wantarray) {
        0   0.00000   0.00000   760:  for my $j (@$ev) {
        0   0.00000   0.00000   761:      push @e, [ $ei, $ev ]
        0   0.00000   0.00000   762:   if $j == $vi && !$ev{$ei}++;
        0   0.00000   0.00000   763:  }
        0   0.00000   0.00000   764:     } else {
        0   0.00000   0.00000   765:  for my $j (@$ev) {
        0   0.00000   0.00000   766:      $en++ if $j == $vi;
        0   0.00000   0.00000   767:  }
        0   0.00000   0.00000   768:     }
        0   0.00000   0.00000   769: }
        0   0.00000   0.00000   770:    }
        0   0.00000   0.00000   771:    return wantarray ? @e : $en;
        0   0.00000   0.00000   772:}
        0   0.00000   0.00000   773:
        0   0.00000   0.00000   774:sub _edges {
      936   0.00001   0.03000   775:    my $g = shift;
      936   0.00045   0.02000   776:    my $n = pop;
      936   0.00000   0.01000   777:    my $i = $n == _S ? 0 : -1;  #
      936   0.00000   0.01000   778:    my $V = $g->[ _V ];
      936   0.00045   0.00000   779:    my $E = $g->[ _E ];
      936   0.00000   0.00000   780:    my $N = $g->[ $n ];
      936   0.00070   0.00000   781:    my $h = $V->[ _f ] & _HYPER;
      936   0.00004   0.01000   782:    unless (defined $N && $N->[ 0 ] == $g->[
        4   0.00000   0.00000   783: $g->[ $n ]->[ 1 ] = { };
        4   0.00000   0.00000   784: $N = $g->[ $n ];
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 57
       =================================================================
    count wall tm  cpu time line
        4   0.00000   0.00000   785: my $u = $E->[ _f ] & _UNORD;
        4   0.00000   0.00000   786: my $Ei = $E->_ids;
        4   0.00000   0.00000   787: while (my ($ei, $ev) = each %{ $Ei }) {
       62   0.00000   0.00000   788:     next unless @$ev;
       62   0.00001   0.01000   789:     my $e = [ $ei, $ev ];
       62   0.00000   0.00000   790:     if ($u) {
       62   0.00000   0.00000   791:  push @{ $N->[ 1 ]->{ $ev->[ 0] } }, $e;
       62   0.00000   0.00000   792:  push @{ $N->[ 1 ]->{ $ev->[-1] } }, $e;
        0   0.00000   0.00000   793:     } else {
        0   0.00000   0.00000   794:  my $e = [ $ei, $ev ];
        0   0.00000   0.00000   795:  push @{ $N->[ 1 ]->{ $ev->[$i] } }, $e;
        0   0.00000   0.00000   796:     }
        0   0.00000   0.00000   797: }
        4   0.00000   0.00000   798: $N->[ 0 ] = $g->[ _G ];
        0   0.00000   0.00000   799:    }
      936   0.00048   0.01000   800:    my @e;
      936   0.00026   0.00000   801:    my @at = $h ? $g->vertices_at( @_ ) : @_;
     1872   0.00004   0.03000   802:    my %at; @at{@at} = ();
      936   0.00071   0.01000   803:    for my $v ( @at ) {
      936   0.00000   0.00000   804: my $vi = $V->_get_path_id( ref $v eq 'ARRAY'
      936   0.00049   0.01000   805: next unless defined $vi && exists $N->[ 1 ]-
      936   0.00000   0.01000   806: push @e, @{ $N->[ 1 ]->{ $vi } };
        0   0.00000   0.00000   807:    }
      936   0.00046   0.00000   808:    if (wantarray && $g->is_undirected) {
     1872   0.00003   0.01000   809: my @i = map { $V->_get_path_id( $_ ) } @_;
      936   0.00045   0.00000   810: for my $e ( @e ) {
     2176   0.00061   0.01000   811:     unless ( $e->[ 1 ]->[ $i ] == $i[ $i ] )
        0   0.00000   0.00000   812:  $e = [ $e->[ 0 ], [ reverse @{ $e->[ 1 ] }
        0   0.00000   0.00000   813:     }
        0   0.00000   0.00000   814: }
        0   0.00000   0.00000   815:    }
      936   0.00029   0.01000   816:    return @e;
        0   0.00000   0.00000   817:}
        0   0.00000   0.00000   818:
        0   0.00000   0.00000   819:sub _edges_from {
      936   0.00048   0.02000   820:    push @_, _S;
      936   0.00001   0.00000   821:    goto &_edges;
        0   0.00000   0.00000   822:}
        0   0.00000   0.00000   823:
        0   0.00000   0.00000   824:sub _edges_to {
        0   0.00000   0.00000   825:    push @_, _P;
        0   0.00000   0.00000   826:    goto &_edges;
        0   0.00000   0.00000   827:}
        0   0.00000   0.00000   828:
        0   0.00000   0.00000   829:sub _edges_id_path {
        0   0.00000   0.00000   830:    my $g = shift;
        0   0.00000   0.00000   831:    my $V  = $g->[ _V ];
        0   0.00000   0.00000   832:    [ map { my @v = $V->_get_id_path($_);
        0   0.00000   0.00000   833:     @v == 1 ? $v[0] : [ @v ] }
        0   0.00000   0.00000   834:          @{ $_[0]->[1] } ];
        0   0.00000   0.00000   835:}
        0   0.00000   0.00000   836:
        0   0.00000   0.00000   837:sub edges_at {
        0   0.00000   0.00000   838:    my $g = shift;
        0   0.00000   0.00000   839:    map { $g->_edges_id_path($_ ) } $g-
        0   0.00000   0.00000   840:}
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 58
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   841:
        0   0.00000   0.00000   842:sub edges_from {
        0   0.00000   0.00000   843:    my $g = shift;
        0   0.00000   0.00000   844:    map { $g->_edges_id_path($_ ) } $g-
        0   0.00000   0.00000   845:}
        0   0.00000   0.00000   846:
        0   0.00000   0.00000   847:sub edges_to {
        0   0.00000   0.00000   848:    my $g = shift;
        0   0.00000   0.00000   849:    map { $g->_edges_id_path($_ ) } $g-
        0   0.00000   0.00000   850:}
        0   0.00000   0.00000   851:
        0   0.00000   0.00000   852:sub successors {
      936   0.00002   0.00000   853:    my $g = shift;
      936   0.00000   0.00000   854:    my $E = $g->[ _E ];
      936   0.00001   0.01000   855:    ($E->[ _f ] & _LIGHT) ?
        0   0.00000   0.00000   856: $E->_successors($g, @_) :
        0   0.00000   0.00000   857: Graph::AdjacencyMap::_successors($E, $g,
        0   0.00000   0.00000   858:}
        0   0.00000   0.00000   859:
        0   0.00000   0.00000   860:sub predecessors {
        0   0.00000   0.00000   861:    my $g = shift;
        0   0.00000   0.00000   862:    my $E = $g->[ _E ];
        0   0.00000   0.00000   863:    ($E->[ _f ] & _LIGHT) ?
        0   0.00000   0.00000   864: $E->_predecessors($g, @_) :
        0   0.00000   0.00000   865: Graph::AdjacencyMap::_predecessors($E, $g,
        0   0.00000   0.00000   866:}
        0   0.00000   0.00000   867:
        0   0.00000   0.00000   868:sub _all_successors {
        0   0.00000   0.00000   869:    my $g = shift;
        0   0.00000   0.00000   870:    my @init = @_;
        0   0.00000   0.00000   871:    my %todo;
        0   0.00000   0.00000   872:    @todo{@init} = @init;
        0   0.00000   0.00000   873:    my %seen;
        0   0.00000   0.00000   874:    while (keys %todo) {
        0   0.00000   0.00000   875: my @todo = keys %todo;
        0   0.00000   0.00000   876: for my $t (@todo) {
        0   0.00000   0.00000   877:     delete $todo{$t};
        0   0.00000   0.00000   878:     $seen{$t} = $t;
        0   0.00000   0.00000   879:     for my $s ($g->successors($t)) {
        0   0.00000   0.00000   880:  $todo{$s}++ unless exists $seen{$s};
        0   0.00000   0.00000   881:     }
        0   0.00000   0.00000   882: }
        0   0.00000   0.00000   883:    }
        0   0.00000   0.00000   884:    delete @seen{@init};
        0   0.00000   0.00000   885:    return values %seen;
        0   0.00000   0.00000   886:}
        0   0.00000   0.00000   887:
        0   0.00000   0.00000   888:sub all_successors {
        0   0.00000   0.00000   889:    my $g = shift;
        0   0.00000   0.00000   890:    $g->expect_directed;
        0   0.00000   0.00000   891:    return $g->_all_successors(@_);
        0   0.00000   0.00000   892:}
        0   0.00000   0.00000   893:
        0   0.00000   0.00000   894:sub _all_predecessors {
        0   0.00000   0.00000   895:    my $g = shift;
        0   0.00000   0.00000   896:    my @init = @_;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 59
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   897:    my %todo;
        0   0.00000   0.00000   898:    @todo{@init} = @init;
        0   0.00000   0.00000   899:    my %seen;
        0   0.00000   0.00000   900:    while (keys %todo) {
        0   0.00000   0.00000   901: my @todo = keys %todo;
        0   0.00000   0.00000   902: for my $t (@todo) {
        0   0.00000   0.00000   903:     delete $todo{$t};
        0   0.00000   0.00000   904:     $seen{$t} = $t;
        0   0.00000   0.00000   905:     for my $p ($g->predecessors($t)) {
        0   0.00000   0.00000   906:  $todo{$p}++ unless exists $seen{$p};
        0   0.00000   0.00000   907:     }
        0   0.00000   0.00000   908: }
        0   0.00000   0.00000   909:    }
        0   0.00000   0.00000   910:    delete @seen{@init};
        0   0.00000   0.00000   911:    return values %seen;
        0   0.00000   0.00000   912:}
        0   0.00000   0.00000   913:
        0   0.00000   0.00000   914:sub all_predecessors {
        0   0.00000   0.00000   915:    my $g = shift;
        0   0.00000   0.00000   916:    $g->expect_directed;
        0   0.00000   0.00000   917:    return $g->_all_predecessors(@_);
        0   0.00000   0.00000   918:}
        0   0.00000   0.00000   919:
        0   0.00000   0.00000   920:sub neighbours {
        0   0.00000   0.00000   921:    my $g = shift;
        0   0.00000   0.00000   922:    my $V  = $g->[ _V ];
        0   0.00000   0.00000   923:    my @s = map { my @v = @{ $_->[ 1 ] };
        0   0.00000   0.00000   924:    my @p = map { my @v = @{ $_->[ 1 ] }; pop
        0   0.00000   0.00000   925:    my %n;
        0   0.00000   0.00000   926:    @n{ @s } = @s;
        0   0.00000   0.00000   927:    @n{ @p } = @p;
        0   0.00000   0.00000   928:    map { $V->_get_id_path($_) } keys %n;
        0   0.00000   0.00000   929:}
        0   0.00000   0.00000   930:
        0   0.00000   0.00000   931:*neighbors = \&neighbours;
        0   0.00000   0.00000   932:
        0   0.00000   0.00000   933:sub all_neighbours {
        0   0.00000   0.00000   934:    my $g = shift;
        0   0.00000   0.00000   935:    my @init = @_;
        0   0.00000   0.00000   936:    my %n;
        0   0.00000   0.00000   937:    my @p = $g->_all_predecessors(@init);
        0   0.00000   0.00000   938:    my @s = $g->_all_successors(@init);
        0   0.00000   0.00000   939:    @n{@p} = @p;
        0   0.00000   0.00000   940:    @n{@s} = @s;
        0   0.00000   0.00000   941:    delete @n{@init};
        0   0.00000   0.00000   942:    return values %n;
        0   0.00000   0.00000   943:}
        0   0.00000   0.00000   944:
        0   0.00000   0.00000   945:*all_neighbors = \&all_neighbours;
        0   0.00000   0.00000   946:
        0   0.00000   0.00000   947:sub all_reachable {
        0   0.00000   0.00000   948:    my $g = shift;
        0   0.00000   0.00000   949:    $g->directed ? $g->successors(@_) : $g-
        0   0.00000   0.00000   950:}
        0   0.00000   0.00000   951:
        0   0.00000   0.00000   952:sub delete_edge {
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 60
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   953:    my $g = shift;
        0   0.00000   0.00000   954:    my @i = $g->_vertex_ids( @_ );
        0   0.00000   0.00000   955:    return $g unless @i;
        0   0.00000   0.00000   956:    my $i = $g->[ _E ]->_get_path_id( @i );
        0   0.00000   0.00000   957:    return $g unless defined $i;
        0   0.00000   0.00000   958:    $g->[ _E ]->_del_id( $i );
        0   0.00000   0.00000   959:    $g->[ _G ]++;
        0   0.00000   0.00000   960:    return $g;
        0   0.00000   0.00000   961:}
        0   0.00000   0.00000   962:
        0   0.00000   0.00000   963:sub delete_vertex {
        0   0.00000   0.00000   964:    my $g = shift;
        0   0.00000   0.00000   965:    my $V = $g->[ _V ];
        0   0.00000   0.00000   966:    return $g unless $V->has_path( @_ );
        0   0.00000   0.00000   967:    my $E = $g->[ _E ];
        0   0.00000   0.00000   968:    for my $e ( $g->_edges_at( @_ ) ) {
        0   0.00000   0.00000   969: $E->_del_id( $e->[ 0 ] );
        0   0.00000   0.00000   970:    }
        0   0.00000   0.00000   971:    $V->del_path( @_ );
        0   0.00000   0.00000   972:    $g->[ _G ]++;
        0   0.00000   0.00000   973:    return $g;
        0   0.00000   0.00000   974:}
        0   0.00000   0.00000   975:
        0   0.00000   0.00000   976:sub get_vertex_count {
        0   0.00000   0.00000   977:    my $g = shift;
        0   0.00000   0.00000   978:    $g->[ _V ]->_get_path_count( @_ ) || 0;
        0   0.00000   0.00000   979:}
        0   0.00000   0.00000   980:
        0   0.00000   0.00000   981:sub get_edge_count {
        0   0.00000   0.00000   982:    my $g = shift;
        0   0.00000   0.00000   983:    my @e = $g->_vertex_ids( @_ );
        0   0.00000   0.00000   984:    return 0 unless @e;
        0   0.00000   0.00000   985:    $g->[ _E ]->_get_path_count( @e ) || 0;
        0   0.00000   0.00000   986:}
        0   0.00000   0.00000   987:
        0   0.00000   0.00000   988:sub delete_vertices {
        0   0.00000   0.00000   989:    my $g = shift;
        0   0.00000   0.00000   990:    while (@_) {
        0   0.00000   0.00000   991: my $v = shift @_;
        0   0.00000   0.00000   992: $g->delete_vertex($v);
        0   0.00000   0.00000   993:    }
        0   0.00000   0.00000   994:    return $g;
        0   0.00000   0.00000   995:}
        0   0.00000   0.00000   996:
        0   0.00000   0.00000   997:sub delete_edges {
        0   0.00000   0.00000   998:    my $g = shift;
        0   0.00000   0.00000   999:    while (@_) {
        0   0.00000   0.00000  1000: my ($u, $v) = splice @_, 0, 2;
        0   0.00000   0.00000  1001: $g->delete_edge($u, $v);
        0   0.00000   0.00000  1002:    }
        0   0.00000   0.00000  1003:    return $g;
        0   0.00000   0.00000  1004:}
        0   0.00000   0.00000  1005:
        0   0.00000   0.00000  1006:###
        0   0.00000   0.00000  1007:# Degrees.
        0   0.00000   0.00000  1008:#
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 61
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1009:
        0   0.00000   0.00000  1010:sub _in_degree {
        0   0.00000   0.00000  1011:    my $g = shift;
        0   0.00000   0.00000  1012:    return undef unless @_ && $g->has_vertex(
        0   0.00000   0.00000  1013:    my $in = 0;
        0   0.00000   0.00000  1014:    $in += $g->get_edge_count( @$_ ) for $g-
        0   0.00000   0.00000  1015:    return $in;
        0   0.00000   0.00000  1016:}
        0   0.00000   0.00000  1017:
        0   0.00000   0.00000  1018:sub in_degree {
        0   0.00000   0.00000  1019:    my $g = shift;
        0   0.00000   0.00000  1020:    $g->_in_degree( @_ );
        0   0.00000   0.00000  1021:}
        0   0.00000   0.00000  1022:
        0   0.00000   0.00000  1023:sub _out_degree {
        0   0.00000   0.00000  1024:    my $g = shift;
        0   0.00000   0.00000  1025:    return undef unless @_ && $g->has_vertex(
        0   0.00000   0.00000  1026:    my $out = 0;
        0   0.00000   0.00000  1027:    $out += $g->get_edge_count( @$_ ) for $g-
        0   0.00000   0.00000  1028:    return $out;
        0   0.00000   0.00000  1029:}
        0   0.00000   0.00000  1030:
        0   0.00000   0.00000  1031:sub out_degree {
        0   0.00000   0.00000  1032:    my $g = shift;
        0   0.00000   0.00000  1033:    $g->_out_degree( @_ );
        0   0.00000   0.00000  1034:}
        0   0.00000   0.00000  1035:
        0   0.00000   0.00000  1036:sub _total_degree {
        0   0.00000   0.00000  1037:    my $g = shift;
        0   0.00000   0.00000  1038:    return undef unless @_ && $g->has_vertex(
        0   0.00000   0.00000  1039:    $g->is_undirected ?
        0   0.00000   0.00000  1040: $g->_in_degree( @_ ) :
        0   0.00000   0.00000  1041: $g-> in_degree( @_ ) - $g-> out_degree( @_
        0   0.00000   0.00000  1042:}
        0   0.00000   0.00000  1043:
        0   0.00000   0.00000  1044:sub degree {
        0   0.00000   0.00000  1045:    my $g = shift;
        0   0.00000   0.00000  1046:    if (@_) {
        0   0.00000   0.00000  1047: $g->_total_degree( @_ );
        0   0.00000   0.00000  1048:    } elsif ($g->is_undirected) {
        0   0.00000   0.00000  1049: my $total = 0;
        0   0.00000   0.00000  1050: $total += $g->_total_degree( $_ ) for $g-
        0   0.00000   0.00000  1051: return $total;
        0   0.00000   0.00000  1052:    } else {
        0   0.00000   0.00000  1053: return 0;
        0   0.00000   0.00000  1054:    }
        0   0.00000   0.00000  1055:}
        0   0.00000   0.00000  1056:
        0   0.00000   0.00000  1057:*vertex_degree = \&degree;
        0   0.00000   0.00000  1058:
        0   0.00000   0.00000  1059:sub is_sink_vertex {
        0   0.00000   0.00000  1060:    my $g = shift;
        0   0.00000   0.00000  1061:    return 0 unless @_;
        0   0.00000   0.00000  1062:    $g->successors( @_ ) == 0 && $g-
        0   0.00000   0.00000  1063:}
        0   0.00000   0.00000  1064:
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 62
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1065:sub is_source_vertex {
        0   0.00000   0.00000  1066:    my $g = shift;
        0   0.00000   0.00000  1067:    return 0 unless @_;
        0   0.00000   0.00000  1068:    $g->predecessors( @_ ) == 0 && $g-
        0   0.00000   0.00000  1069:}
        0   0.00000   0.00000  1070:
        0   0.00000   0.00000  1071:sub is_successorless_vertex {
        0   0.00000   0.00000  1072:    my $g = shift;
        0   0.00000   0.00000  1073:    return 0 unless @_;
        0   0.00000   0.00000  1074:    $g->successors( @_ ) == 0;
        0   0.00000   0.00000  1075:}
        0   0.00000   0.00000  1076:
        0   0.00000   0.00000  1077:sub is_predecessorless_vertex {
        0   0.00000   0.00000  1078:    my $g = shift;
        0   0.00000   0.00000  1079:    return 0 unless @_;
        0   0.00000   0.00000  1080:    $g->predecessors( @_ ) == 0;
        0   0.00000   0.00000  1081:}
        0   0.00000   0.00000  1082:
        0   0.00000   0.00000  1083:sub is_successorful_vertex {
        0   0.00000   0.00000  1084:    my $g = shift;
        0   0.00000   0.00000  1085:    return 0 unless @_;
        0   0.00000   0.00000  1086:    $g->successors( @_ ) > 0;
        0   0.00000   0.00000  1087:}
        0   0.00000   0.00000  1088:
        0   0.00000   0.00000  1089:sub is_predecessorful_vertex {
        0   0.00000   0.00000  1090:    my $g = shift;
        0   0.00000   0.00000  1091:    return 0 unless @_;
        0   0.00000   0.00000  1092:    $g->predecessors( @_ ) > 0;
        0   0.00000   0.00000  1093:}
        0   0.00000   0.00000  1094:
        0   0.00000   0.00000  1095:sub is_isolated_vertex {
        0   0.00000   0.00000  1096:    my $g = shift;
        0   0.00000   0.00000  1097:    return 0 unless @_;
        0   0.00000   0.00000  1098:    $g->predecessors( @_ ) == 0 && $g-
        0   0.00000   0.00000  1099:}
        0   0.00000   0.00000  1100:
        0   0.00000   0.00000  1101:sub is_interior_vertex {
        0   0.00000   0.00000  1102:    my $g = shift;
        0   0.00000   0.00000  1103:    return 0 unless @_;
        0   0.00000   0.00000  1104:    my $p = $g->predecessors( @_ );
        0   0.00000   0.00000  1105:    my $s = $g->successors( @_ );
        0   0.00000   0.00000  1106:    if ($g->is_self_loop_vertex( @_ )) {
        0   0.00000   0.00000  1107: $p--;
        0   0.00000   0.00000  1108: $s--;
        0   0.00000   0.00000  1109:    }
        0   0.00000   0.00000  1110:    $p > 0 && $s > 0;
        0   0.00000   0.00000  1111:}
        0   0.00000   0.00000  1112:
        0   0.00000   0.00000  1113:sub is_exterior_vertex {
        0   0.00000   0.00000  1114:    my $g = shift;
        0   0.00000   0.00000  1115:    return 0 unless @_;
        0   0.00000   0.00000  1116:    $g->predecessors( @_ ) == 0 || $g-
        0   0.00000   0.00000  1117:}
        0   0.00000   0.00000  1118:
        0   0.00000   0.00000  1119:sub is_self_loop_vertex {
        0   0.00000   0.00000  1120:    my $g = shift;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 63
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1121:    return 0 unless @_;
        0   0.00000   0.00000  1122:    for my $s ( $g->successors( @_ ) ) {
        0   0.00000   0.00000  1123: return 1 if $s eq $_[0]; # @todo:
        0   0.00000   0.00000  1124:    }
        0   0.00000   0.00000  1125:    return 0;
        0   0.00000   0.00000  1126:}
        0   0.00000   0.00000  1127:
        0   0.00000   0.00000  1128:sub sink_vertices {
        0   0.00000   0.00000  1129:    my $g = shift;
        0   0.00000   0.00000  1130:    grep { $g->is_sink_vertex($_) } $g-
        0   0.00000   0.00000  1131:}
        0   0.00000   0.00000  1132:
        0   0.00000   0.00000  1133:sub source_vertices {
        0   0.00000   0.00000  1134:    my $g = shift;
        0   0.00000   0.00000  1135:    grep { $g->is_source_vertex($_) } $g-
        0   0.00000   0.00000  1136:}
        0   0.00000   0.00000  1137:
        0   0.00000   0.00000  1138:sub successorless_vertices {
        0   0.00000   0.00000  1139:    my $g = shift;
        0   0.00000   0.00000  1140:    grep { $g->is_successorless_vertex($_) }
        0   0.00000   0.00000  1141:}
        0   0.00000   0.00000  1142:
        0   0.00000   0.00000  1143:sub predecessorless_vertices {
        0   0.00000   0.00000  1144:    my $g = shift;
        0   0.00000   0.00000  1145:    grep { $g->is_predecessorless_vertex($_)
        0   0.00000   0.00000  1146:}
        0   0.00000   0.00000  1147:
        0   0.00000   0.00000  1148:sub successorful_vertices {
        0   0.00000   0.00000  1149:    my $g = shift;
        0   0.00000   0.00000  1150:    grep { $g->is_successorful_vertex($_) }
        0   0.00000   0.00000  1151:}
        0   0.00000   0.00000  1152:
        0   0.00000   0.00000  1153:sub predecessorful_vertices {
        0   0.00000   0.00000  1154:    my $g = shift;
        0   0.00000   0.00000  1155:    grep { $g->is_predecessorful_vertex($_) }
        0   0.00000   0.00000  1156:}
        0   0.00000   0.00000  1157:
        0   0.00000   0.00000  1158:sub isolated_vertices {
        0   0.00000   0.00000  1159:    my $g = shift;
        0   0.00000   0.00000  1160:    grep { $g->is_isolated_vertex($_) } $g-
        0   0.00000   0.00000  1161:}
        0   0.00000   0.00000  1162:
        0   0.00000   0.00000  1163:sub interior_vertices {
        0   0.00000   0.00000  1164:    my $g = shift;
        0   0.00000   0.00000  1165:    grep { $g->is_interior_vertex($_) } $g-
        0   0.00000   0.00000  1166:}
        0   0.00000   0.00000  1167:
        0   0.00000   0.00000  1168:sub exterior_vertices {
        0   0.00000   0.00000  1169:    my $g = shift;
        0   0.00000   0.00000  1170:    grep { $g->is_exterior_vertex($_) } $g-
        0   0.00000   0.00000  1171:}
        0   0.00000   0.00000  1172:
        0   0.00000   0.00000  1173:sub self_loop_vertices {
        0   0.00000   0.00000  1174:    my $g = shift;
        0   0.00000   0.00000  1175:    grep { $g->is_self_loop_vertex($_) } $g-
        0   0.00000   0.00000  1176:}
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 64
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1177:
        0   0.00000   0.00000  1178:###
        0   0.00000   0.00000  1179:# Paths and cycles.
        0   0.00000   0.00000  1180:#
        0   0.00000   0.00000  1181:
        0   0.00000   0.00000  1182:sub add_path {
        0   0.00000   0.00000  1183:    my $g = shift;
        0   0.00000   0.00000  1184:    my $u = shift;
        0   0.00000   0.00000  1185:    while (@_) {
        0   0.00000   0.00000  1186: my $v = shift;
        0   0.00000   0.00000  1187: $g->add_edge($u, $v);
        0   0.00000   0.00000  1188: $u = $v;
        0   0.00000   0.00000  1189:    }
        0   0.00000   0.00000  1190:    return $g;
        0   0.00000   0.00000  1191:}
        0   0.00000   0.00000  1192:
        0   0.00000   0.00000  1193:sub delete_path {
        0   0.00000   0.00000  1194:    my $g = shift;
        0   0.00000   0.00000  1195:    my $u = shift;
        0   0.00000   0.00000  1196:    while (@_) {
        0   0.00000   0.00000  1197: my $v = shift;
        0   0.00000   0.00000  1198: $g->delete_edge($u, $v);
        0   0.00000   0.00000  1199: $u = $v;
        0   0.00000   0.00000  1200:    }
        0   0.00000   0.00000  1201:    return $g;
        0   0.00000   0.00000  1202:}
        0   0.00000   0.00000  1203:
        0   0.00000   0.00000  1204:sub has_path {
        0   0.00000   0.00000  1205:    my $g = shift;
        0   0.00000   0.00000  1206:    my $u = shift;
        0   0.00000   0.00000  1207:    while (@_) {
        0   0.00000   0.00000  1208: my $v = shift;
        0   0.00000   0.00000  1209: return 0 unless $g->has_edge($u, $v);
        0   0.00000   0.00000  1210: $u = $v;
        0   0.00000   0.00000  1211:    }
        0   0.00000   0.00000  1212:    return $g;
        0   0.00000   0.00000  1213:}
        0   0.00000   0.00000  1214:
        0   0.00000   0.00000  1215:sub add_cycle {
        0   0.00000   0.00000  1216:    my $g = shift;
        0   0.00000   0.00000  1217:    $g->add_path(@_, $_[0]);
        0   0.00000   0.00000  1218:}
        0   0.00000   0.00000  1219:
        0   0.00000   0.00000  1220:sub delete_cycle {
        0   0.00000   0.00000  1221:    my $g = shift;
        0   0.00000   0.00000  1222:    $g->delete_path(@_, $_[0]);
        0   0.00000   0.00000  1223:}
        0   0.00000   0.00000  1224:
        0   0.00000   0.00000  1225:sub has_cycle {
        0   0.00000   0.00000  1226:    my $g = shift;
        0   0.00000   0.00000  1227:    @_ ? ($g->has_path(@_, $_[0]) ? 1 : 0) :
        0   0.00000   0.00000  1228:}
        0   0.00000   0.00000  1229:
        0   0.00000   0.00000  1230:sub has_a_cycle {
        0   0.00000   0.00000  1231:    my $g = shift;
        0   0.00000   0.00000  1232:    my @r = ( back_edge =>
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 65
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1233:    push @r,
        0   0.00000   0.00000  1234:      down_edge =>
        0   0.00000   0.00000  1235:       if $g->is_undirected;
        0   0.00000   0.00000  1236:    my $t = Graph::Traversal::DFS->new($g,
        0   0.00000   0.00000  1237:    $t->dfs;
        0   0.00000   0.00000  1238:    return $t->get_state('has_a_cycle');
        0   0.00000   0.00000  1239:}
        0   0.00000   0.00000  1240:
        0   0.00000   0.00000  1241:sub find_a_cycle {
        0   0.00000   0.00000  1242:    my $g = shift;
        0   0.00000   0.00000  1243:    my @r = ( back_edge =>
        0   0.00000   0.00000  1244:    push @r,
        0   0.00000   0.00000  1245:      down_edge =>
        0   0.00000   0.00000  1246: if $g->is_undirected;
        0   0.00000   0.00000  1247:    my $t = Graph::Traversal::DFS->new($g,
        0   0.00000   0.00000  1248:    $t->dfs;
        0   0.00000   0.00000  1249:    $t->has_state('a_cycle') ? @{ $t-
        0   0.00000   0.00000  1250:}
        0   0.00000   0.00000  1251:
        0   0.00000   0.00000  1252:###
        0   0.00000   0.00000  1253:# Attributes.
        0   0.00000   0.00000  1254:
        0   0.00000   0.00000  1255:# Vertex attributes.
        0   0.00000   0.00000  1256:
        0   0.00000   0.00000  1257:sub set_vertex_attribute {
     1656   0.00002   0.03000  1258:    my $g = shift;
     1656   0.00046   0.02000  1259:    $g->expect_non_multivertexed;
     1656   0.00047   0.00000  1260:    my $value = pop;
     1656   0.00010   0.01000  1261:    my $attr  = pop;
     1656   0.00002   0.00000  1262:    $g->add_vertex( @_ ) unless $g-
     1656   0.00093   0.01000  1263:    $g->[ _V ]->_set_path_attr( @_, $attr,
        0   0.00000   0.00000  1264:}
        0   0.00000   0.00000  1265:
        0   0.00000   0.00000  1266:sub set_vertex_attribute_by_id {
        0   0.00000   0.00000  1267:    my $g = shift;
        0   0.00000   0.00000  1268:    $g->expect_multivertexed;
        0   0.00000   0.00000  1269:    my $value = pop;
        0   0.00000   0.00000  1270:    my $attr  = pop;
        0   0.00000   0.00000  1271:    $g->add_vertex_by_id( @_ ) unless $g-
        0   0.00000   0.00000  1272:    $g->[ _V ]->_set_path_attr( @_, $attr,
        0   0.00000   0.00000  1273:}
        0   0.00000   0.00000  1274:
        0   0.00000   0.00000  1275:sub set_vertex_attributes {
        0   0.00000   0.00000  1276:    my $g = shift;
        0   0.00000   0.00000  1277:    $g->expect_non_multivertexed;
        0   0.00000   0.00000  1278:    my $attr = pop;
        0   0.00000   0.00000  1279:    $g->add_vertex( @_ ) unless $g-
        0   0.00000   0.00000  1280:    $g->[ _V ]->_set_path_attrs( @_, $attr );
        0   0.00000   0.00000  1281:}
        0   0.00000   0.00000  1282:
        0   0.00000   0.00000  1283:sub set_vertex_attributes_by_id {
        0   0.00000   0.00000  1284:    my $g = shift;
        0   0.00000   0.00000  1285:    $g->expect_multivertexed;
        0   0.00000   0.00000  1286:    my $attr = pop;
        0   0.00000   0.00000  1287:    $g->add_vertex_by_id( @_ ) unless $g-
        0   0.00000   0.00000  1288:    $g->[ _V ]->_set_path_attrs( @_, $attr );
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 66
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1289:}
        0   0.00000   0.00000  1290:
        0   0.00000   0.00000  1291:sub has_vertex_attributes {
        0   0.00000   0.00000  1292:    my $g = shift;
        0   0.00000   0.00000  1293:    $g->expect_non_multivertexed;
        0   0.00000   0.00000  1294:    return 0 unless $g->has_vertex( @_ );
        0   0.00000   0.00000  1295:    $g->[ _V ]->_has_path_attrs( @_ );
        0   0.00000   0.00000  1296:}
        0   0.00000   0.00000  1297:
        0   0.00000   0.00000  1298:sub has_vertex_attributes_by_id {
        0   0.00000   0.00000  1299:    my $g = shift;
        0   0.00000   0.00000  1300:    $g->expect_multivertexed;
        0   0.00000   0.00000  1301:    return 0 unless $g->has_vertex_by_id( @_
        0   0.00000   0.00000  1302:    $g->[ _V ]->_has_path_attrs( @_ );
        0   0.00000   0.00000  1303:}
        0   0.00000   0.00000  1304:
        0   0.00000   0.00000  1305:sub has_vertex_attribute {
        0   0.00000   0.00000  1306:    my $g = shift;
        0   0.00000   0.00000  1307:    $g->expect_non_multivertexed;
        0   0.00000   0.00000  1308:    my $attr = pop;
        0   0.00000   0.00000  1309:    return 0 unless $g->has_vertex( @_ );
        0   0.00000   0.00000  1310:    $g->[ _V ]->_has_path_attr( @_, $attr );
        0   0.00000   0.00000  1311:}
        0   0.00000   0.00000  1312:
        0   0.00000   0.00000  1313:sub has_vertex_attribute_by_id {
        0   0.00000   0.00000  1314:    my $g = shift;
        0   0.00000   0.00000  1315:    $g->expect_multivertexed;
        0   0.00000   0.00000  1316:    my $attr = pop;
        0   0.00000   0.00000  1317:    return 0 unless $g->has_vertex_by_id( @_
        0   0.00000   0.00000  1318:    $g->[ _V ]->_has_path_attr( @_, $attr );
        0   0.00000   0.00000  1319:}
        0   0.00000   0.00000  1320:
        0   0.00000   0.00000  1321:sub get_vertex_attributes {
        0   0.00000   0.00000  1322:    my $g = shift;
        0   0.00000   0.00000  1323:    $g->expect_non_multivertexed;
        0   0.00000   0.00000  1324:    return unless $g->has_vertex( @_ );
        0   0.00000   0.00000  1325:    my $a = $g->[ _V ]->_get_path_attrs( @_
        0   0.00000   0.00000  1326:    ($g->is_compat02) ? (defined $a ? %{ $a }
        0   0.00000   0.00000  1327:}
        0   0.00000   0.00000  1328:
        0   0.00000   0.00000  1329:sub get_vertex_attributes_by_id {
        0   0.00000   0.00000  1330:    my $g = shift;
        0   0.00000   0.00000  1331:    $g->expect_multivertexed;
        0   0.00000   0.00000  1332:    return unless $g->has_vertex_by_id( @_ );
        0   0.00000   0.00000  1333:    $g->[ _V ]->_get_path_attrs( @_ );
        0   0.00000   0.00000  1334:}
        0   0.00000   0.00000  1335:
        0   0.00000   0.00000  1336:sub get_vertex_attribute {
     5716   0.00056   0.02000  1337:    my $g = shift;
     5716   0.00056   0.04000  1338:    $g->expect_non_multivertexed;
     5716   0.00872   0.04000  1339:    my $attr = pop;
     5716   0.00028   0.05000  1340:    return unless $g->has_vertex( @_ );
     5716   0.00139   0.04000  1341:    $g->[ _V ]->_get_path_attr( @_, $attr );
        0   0.00000   0.00000  1342:}
        0   0.00000   0.00000  1343:
        0   0.00000   0.00000  1344:sub get_vertex_attribute_by_id {
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 67
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1345:    my $g = shift;
        0   0.00000   0.00000  1346:    $g->expect_multivertexed;
        0   0.00000   0.00000  1347:    my $attr = pop;
        0   0.00000   0.00000  1348:    return unless $g->has_vertex_by_id( @_ );
        0   0.00000   0.00000  1349:    $g->[ _V ]->_get_path_attr( @_, $attr );
        0   0.00000   0.00000  1350:}
        0   0.00000   0.00000  1351:
        0   0.00000   0.00000  1352:sub get_vertex_attribute_names {
        0   0.00000   0.00000  1353:    my $g = shift;
        0   0.00000   0.00000  1354:    $g->expect_non_multivertexed;
        0   0.00000   0.00000  1355:    return unless $g->has_vertex( @_ );
        0   0.00000   0.00000  1356:    $g->[ _V ]->_get_path_attr_names( @_ );
        0   0.00000   0.00000  1357:}
        0   0.00000   0.00000  1358:
        0   0.00000   0.00000  1359:sub get_vertex_attribute_names_by_id {
        0   0.00000   0.00000  1360:    my $g = shift;
        0   0.00000   0.00000  1361:    $g->expect_multivertexed;
        0   0.00000   0.00000  1362:    return unless $g->has_vertex_by_id( @_ );
        0   0.00000   0.00000  1363:    $g->[ _V ]->_get_path_attr_names( @_ );
        0   0.00000   0.00000  1364:}
        0   0.00000   0.00000  1365:
        0   0.00000   0.00000  1366:sub get_vertex_attribute_values {
        0   0.00000   0.00000  1367:    my $g = shift;
        0   0.00000   0.00000  1368:    $g->expect_non_multivertexed;
        0   0.00000   0.00000  1369:    return unless $g->has_vertex( @_ );
        0   0.00000   0.00000  1370:    $g->[ _V ]->_get_path_attr_values( @_ );
        0   0.00000   0.00000  1371:}
        0   0.00000   0.00000  1372:
        0   0.00000   0.00000  1373:sub get_vertex_attribute_values_by_id {
        0   0.00000   0.00000  1374:    my $g = shift;
        0   0.00000   0.00000  1375:    $g->expect_multivertexed;
        0   0.00000   0.00000  1376:    return unless $g->has_vertex_by_id( @_ );
        0   0.00000   0.00000  1377:    $g->[ _V ]->_get_path_attr_values( @_ );
        0   0.00000   0.00000  1378:}
        0   0.00000   0.00000  1379:
        0   0.00000   0.00000  1380:sub delete_vertex_attributes {
        0   0.00000   0.00000  1381:    my $g = shift;
        0   0.00000   0.00000  1382:    $g->expect_non_multivertexed;
        0   0.00000   0.00000  1383:    return undef unless $g->has_vertex( @_ );
        0   0.00000   0.00000  1384:    $g->[ _V ]->_del_path_attrs( @_ );
        0   0.00000   0.00000  1385:}
        0   0.00000   0.00000  1386:
        0   0.00000   0.00000  1387:sub delete_vertex_attributes_by_id {
        0   0.00000   0.00000  1388:    my $g = shift;
        0   0.00000   0.00000  1389:    $g->expect_multivertexed;
        0   0.00000   0.00000  1390:    return undef unless $g->has_vertex_by_id(
        0   0.00000   0.00000  1391:    $g->[ _V ]->_del_path_attrs( @_ );
        0   0.00000   0.00000  1392:}
        0   0.00000   0.00000  1393:
        0   0.00000   0.00000  1394:sub delete_vertex_attribute {
        0   0.00000   0.00000  1395:    my $g = shift;
        0   0.00000   0.00000  1396:    $g->expect_non_multivertexed;
        0   0.00000   0.00000  1397:    my $attr = pop;
        0   0.00000   0.00000  1398:    return undef unless $g->has_vertex( @_ );
        0   0.00000   0.00000  1399:    $g->[ _V ]->_del_path_attr( @_, $attr );
        0   0.00000   0.00000  1400:}
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 68
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1401:
        0   0.00000   0.00000  1402:sub delete_vertex_attribute_by_id {
        0   0.00000   0.00000  1403:    my $g = shift;
        0   0.00000   0.00000  1404:    $g->expect_multivertexed;
        0   0.00000   0.00000  1405:    my $attr = pop;
        0   0.00000   0.00000  1406:    return undef unless $g->has_vertex_by_id(
        0   0.00000   0.00000  1407:    $g->[ _V ]->_del_path_attr( @_, $attr );
        0   0.00000   0.00000  1408:}
        0   0.00000   0.00000  1409:
        0   0.00000   0.00000  1410:# Edge attributes.
        0   0.00000   0.00000  1411:
        0   0.00000   0.00000  1412:sub _set_edge_attribute {
        0   0.00000   0.00000  1413:    my $g = shift;
        0   0.00000   0.00000  1414:    my $value = pop;
        0   0.00000   0.00000  1415:    my $attr  = pop;
        0   0.00000   0.00000  1416:    my $E = $g->[ _E ];
        0   0.00000   0.00000  1417:    my $f = $E->[ _f ];
        0   0.00000   0.00000  1418:    my @i;
        0   0.00000   0.00000  1419:    if ($E->[ _a ] == 2 && @_ == 2 && !($f &
        0   0.00000   0.00000  1420: @_ = sort @_ if ($f & _UNORD);
        0   0.00000   0.00000  1421: my $s = $E->[ _s ];
        0   0.00000   0.00000  1422: $g->add_edge( @_ ) unless exists $s->{ $_[0]
        0   0.00000   0.00000  1423: @i = @{ $g->[ _V ]->[ _s ] }{ @_ };
        0   0.00000   0.00000  1424:    } else {
        0   0.00000   0.00000  1425: $g->add_edge( @_ ) unless $g->has_edge( @_
        0   0.00000   0.00000  1426: @i = $g->_vertex_ids( @_ );
        0   0.00000   0.00000  1427:    }
        0   0.00000   0.00000  1428:    $g->[ _E ]->_set_path_attr( @i, $attr,
        0   0.00000   0.00000  1429:}
        0   0.00000   0.00000  1430:
        0   0.00000   0.00000  1431:sub set_edge_attribute {
      890   0.00006   0.01000  1432:    my $g = shift;
      890   0.00032   0.00000  1433:    $g->expect_non_multiedged;
      890   0.00021   0.01000  1434:    my $value = pop;
      890   0.00048   0.01000  1435:    my $attr  = pop;
      890   0.00000   0.00000  1436:    my $E = $g->[ _E ];
      890   0.00046   0.01000  1437:    $g->add_edge( @_ ) unless $g->has_edge(
      890   0.00027   0.00000  1438:    $E->_set_path_attr( $g->_vertex_ids( @_
        0   0.00000   0.00000  1439:}
        0   0.00000   0.00000  1440:
        0   0.00000   0.00000  1441:sub set_edge_attribute_by_id {
        0   0.00000   0.00000  1442:    my $g = shift;
        0   0.00000   0.00000  1443:    $g->expect_multiedged;
        0   0.00000   0.00000  1444:    my $value = pop;
        0   0.00000   0.00000  1445:    my $attr  = pop;
        0   0.00000   0.00000  1446:    # $g->add_edge_by_id( @_ ) unless $g-
        0   0.00000   0.00000  1447:    my $id = pop;
        0   0.00000   0.00000  1448:    $g->[ _E ]->_set_path_attr( $g-
        0   0.00000   0.00000  1449:}
        0   0.00000   0.00000  1450:
        0   0.00000   0.00000  1451:sub set_edge_attributes {
        0   0.00000   0.00000  1452:    my $g = shift;
        0   0.00000   0.00000  1453:    $g->expect_non_multiedged;
        0   0.00000   0.00000  1454:    my $attr = pop;
        0   0.00000   0.00000  1455:    $g->add_edge( @_ ) unless $g->has_edge(
        0   0.00000   0.00000  1456:    $g->[ _E ]->_set_path_attrs( $g-
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 69
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1457:}
        0   0.00000   0.00000  1458:
        0   0.00000   0.00000  1459:sub set_edge_attributes_by_id {
        0   0.00000   0.00000  1460:    my $g = shift;
        0   0.00000   0.00000  1461:    $g->expect_multiedged;
        0   0.00000   0.00000  1462:    my $attr = pop;
        0   0.00000   0.00000  1463:    $g->add_edge_by_id( @_ ) unless $g-
        0   0.00000   0.00000  1464:    my $id = pop;
        0   0.00000   0.00000  1465:    $g->[ _E ]->_set_path_attrs( $g-
        0   0.00000   0.00000  1466:}
        0   0.00000   0.00000  1467:
        0   0.00000   0.00000  1468:sub has_edge_attributes {
        0   0.00000   0.00000  1469:    my $g = shift;
        0   0.00000   0.00000  1470:    $g->expect_non_multiedged;
        0   0.00000   0.00000  1471:    return 0 unless $g->has_edge( @_ );
        0   0.00000   0.00000  1472:    $g->[ _E ]->_has_path_attrs( $g-
        0   0.00000   0.00000  1473:}
        0   0.00000   0.00000  1474:
        0   0.00000   0.00000  1475:sub has_edge_attributes_by_id {
        0   0.00000   0.00000  1476:    my $g = shift;
        0   0.00000   0.00000  1477:    $g->expect_multiedged;
        0   0.00000   0.00000  1478:    return 0 unless $g->has_edge_by_id( @_ );
        0   0.00000   0.00000  1479:    my $id = pop;
        0   0.00000   0.00000  1480:    $g->[ _E ]->_has_path_attrs( $g-
        0   0.00000   0.00000  1481:}
        0   0.00000   0.00000  1482:
        0   0.00000   0.00000  1483:sub has_edge_attribute {
      124   0.00043   0.00000  1484:    my $g = shift;
      124   0.00025   0.00000  1485:    $g->expect_non_multiedged;
      124   0.00000   0.00000  1486:    my $attr = pop;
      124   0.00000   0.01000  1487:    return 0 unless $g->has_edge( @_ );
      124   0.00000   0.00000  1488:    $g->[ _E ]->_has_path_attr( $g-
        0   0.00000   0.00000  1489:}
        0   0.00000   0.00000  1490:
        0   0.00000   0.00000  1491:sub has_edge_attribute_by_id {
        0   0.00000   0.00000  1492:    my $g = shift;
        0   0.00000   0.00000  1493:    $g->expect_multiedged;
        0   0.00000   0.00000  1494:    my $attr = pop;
        0   0.00000   0.00000  1495:    return 0 unless $g->has_edge_by_id( @_ );
        0   0.00000   0.00000  1496:    my $id = pop;
        0   0.00000   0.00000  1497:    $g->[ _E ]->_has_path_attr( $g-
        0   0.00000   0.00000  1498:}
        0   0.00000   0.00000  1499:
        0   0.00000   0.00000  1500:sub get_edge_attributes {
        0   0.00000   0.00000  1501:    my $g = shift;
        0   0.00000   0.00000  1502:    $g->expect_non_multiedged;
        0   0.00000   0.00000  1503:    return unless $g->has_edge( @_ );
        0   0.00000   0.00000  1504:    my $a = $g->[ _E ]->_get_path_attrs( $g-
        0   0.00000   0.00000  1505:    ($g->is_compat02) ? (defined $a ? %{ $a }
        0   0.00000   0.00000  1506:}
        0   0.00000   0.00000  1507:
        0   0.00000   0.00000  1508:sub get_edge_attributes_by_id {
        0   0.00000   0.00000  1509:    my $g = shift;
        0   0.00000   0.00000  1510:    $g->expect_multiedged;
        0   0.00000   0.00000  1511:    return unless $g->has_edge_by_id( @_ );
        0   0.00000   0.00000  1512:    my $id = pop;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 70
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1513:    return $g->[ _E ]->_get_path_attrs( $g-
        0   0.00000   0.00000  1514:}
        0   0.00000   0.00000  1515:
        0   0.00000   0.00000  1516:sub _get_edge_attribute { # Fast path; less
        0   0.00000   0.00000  1517:    my $g = shift;
        0   0.00000   0.00000  1518:    my $attr = pop;
        0   0.00000   0.00000  1519:    my $E = $g->[ _E ];
        0   0.00000   0.00000  1520:    my $f = $E->[ _f ];
        0   0.00000   0.00000  1521:    if ($E->[ _a ] == 2 && @_ == 2 && !($f &
        0   0.00000   0.00000  1522: @_ = sort @_ if ($f & _UNORD);
        0   0.00000   0.00000  1523: my $s = $E->[ _s ];
        0   0.00000   0.00000  1524: return unless exists $s->{ $_[0] } && exists
        0   0.00000   0.00000  1525:    } else {
        0   0.00000   0.00000  1526: return unless $g->has_edge( @_ );
        0   0.00000   0.00000  1527:    }
        0   0.00000   0.00000  1528:    my @i = $g->_vertex_ids( @_ );
        0   0.00000   0.00000  1529:    $E->_get_path_attr( @i, $attr );
        0   0.00000   0.00000  1530:}
        0   0.00000   0.00000  1531:
        0   0.00000   0.00000  1532:sub get_edge_attribute {
     1150   0.00001   0.01000  1533:    my $g = shift;
     1150   0.00001   0.01000  1534:    $g->expect_non_multiedged;
     1150   0.00000   0.00000  1535:    my $attr = pop;
     1150   0.00029   0.01000  1536:    return undef unless $g->has_edge( @_ );
     1150   0.00079   0.00000  1537:    my @i = $g->_vertex_ids( @_ );
     1150   0.00001   0.02000  1538:    return undef if @i == 0 && @_;
     1150   0.00001   0.01000  1539:    my $E = $g->[ _E ];
     1150   0.00091   0.03000  1540:    $E->_get_path_attr( @i, $attr );
        0   0.00000   0.00000  1541:}
        0   0.00000   0.00000  1542:
        0   0.00000   0.00000  1543:sub get_edge_attribute_by_id {
        0   0.00000   0.00000  1544:    my $g = shift;
        0   0.00000   0.00000  1545:    $g->expect_multiedged;
        0   0.00000   0.00000  1546:    my $attr = pop;
        0   0.00000   0.00000  1547:    return unless $g->has_edge_by_id( @_ );
        0   0.00000   0.00000  1548:    my $id = pop;
        0   0.00000   0.00000  1549:    $g->[ _E ]->_get_path_attr( $g-
        0   0.00000   0.00000  1550:}
        0   0.00000   0.00000  1551:
        0   0.00000   0.00000  1552:sub get_edge_attribute_names {
        0   0.00000   0.00000  1553:    my $g = shift;
        0   0.00000   0.00000  1554:    $g->expect_non_multiedged;
        0   0.00000   0.00000  1555:    return unless $g->has_edge( @_ );
        0   0.00000   0.00000  1556:    $g->[ _E ]->_get_path_attr_names( $g-
        0   0.00000   0.00000  1557:}
        0   0.00000   0.00000  1558:
        0   0.00000   0.00000  1559:sub get_edge_attribute_names_by_id {
        0   0.00000   0.00000  1560:    my $g = shift;
        0   0.00000   0.00000  1561:    $g->expect_multiedged;
        0   0.00000   0.00000  1562:    return unless $g->has_edge_by_id( @_ );
        0   0.00000   0.00000  1563:    my $id = pop;
        0   0.00000   0.00000  1564:    $g->[ _E ]->_get_path_attr_names( $g-
        0   0.00000   0.00000  1565:}
        0   0.00000   0.00000  1566:
        0   0.00000   0.00000  1567:sub get_edge_attribute_values {
        0   0.00000   0.00000  1568:    my $g = shift;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 71
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1569:    $g->expect_non_multiedged;
        0   0.00000   0.00000  1570:    return unless $g->has_edge( @_ );
        0   0.00000   0.00000  1571:    $g->[ _E ]->_get_path_attr_values( $g-
        0   0.00000   0.00000  1572:}
        0   0.00000   0.00000  1573:
        0   0.00000   0.00000  1574:sub get_edge_attribute_values_by_id {
        0   0.00000   0.00000  1575:    my $g = shift;
        0   0.00000   0.00000  1576:    $g->expect_multiedged;
        0   0.00000   0.00000  1577:    return unless $g->has_edge_by_id( @_ );
        0   0.00000   0.00000  1578:    my $id = pop;
        0   0.00000   0.00000  1579:    $g->[ _E ]->_get_path_attr_values( $g-
        0   0.00000   0.00000  1580:}
        0   0.00000   0.00000  1581:
        0   0.00000   0.00000  1582:sub delete_edge_attributes {
        0   0.00000   0.00000  1583:    my $g = shift;
        0   0.00000   0.00000  1584:    $g->expect_non_multiedged;
        0   0.00000   0.00000  1585:    return unless $g->has_edge( @_ );
        0   0.00000   0.00000  1586:    $g->[ _E ]->_del_path_attrs( $g-
        0   0.00000   0.00000  1587:}
        0   0.00000   0.00000  1588:
        0   0.00000   0.00000  1589:sub delete_edge_attributes_by_id {
        0   0.00000   0.00000  1590:    my $g = shift;
        0   0.00000   0.00000  1591:    $g->expect_multiedged;
        0   0.00000   0.00000  1592:    return unless $g->has_edge_by_id( @_ );
        0   0.00000   0.00000  1593:    my $id = pop;
        0   0.00000   0.00000  1594:    $g->[ _E ]->_del_path_attrs( $g-
        0   0.00000   0.00000  1595:}
        0   0.00000   0.00000  1596:
        0   0.00000   0.00000  1597:sub delete_edge_attribute {
        0   0.00000   0.00000  1598:    my $g = shift;
        0   0.00000   0.00000  1599:    $g->expect_non_multiedged;
        0   0.00000   0.00000  1600:    my $attr = pop;
        0   0.00000   0.00000  1601:    return unless $g->has_edge( @_ );
        0   0.00000   0.00000  1602:    $g->[ _E ]->_del_path_attr( $g-
        0   0.00000   0.00000  1603:}
        0   0.00000   0.00000  1604:
        0   0.00000   0.00000  1605:sub delete_edge_attribute_by_id {
        0   0.00000   0.00000  1606:    my $g = shift;
        0   0.00000   0.00000  1607:    $g->expect_multiedged;
        0   0.00000   0.00000  1608:    my $attr = pop;
        0   0.00000   0.00000  1609:    return unless $g->has_edge_by_id( @_ );
        0   0.00000   0.00000  1610:    my $id = pop;
        0   0.00000   0.00000  1611:    $g->[ _E ]->_del_path_attr( $g-
        0   0.00000   0.00000  1612:}
        0   0.00000   0.00000  1613:
        0   0.00000   0.00000  1614:###
        0   0.00000   0.00000  1615:# Compat.
        0   0.00000   0.00000  1616:#
        0   0.00000   0.00000  1617:
        0   0.00000   0.00000  1618:sub vertex {
        0   0.00000   0.00000  1619:    my $g = shift;
        0   0.00000   0.00000  1620:    $g->has_vertex( @_ ) ? @_ : undef;
        0   0.00000   0.00000  1621:}
        0   0.00000   0.00000  1622:
        0   0.00000   0.00000  1623:sub out_edges {
        0   0.00000   0.00000  1624:    my $g = shift;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 72
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1625:    return unless @_ && $g->has_vertex( @_ );
        0   0.00000   0.00000  1626:    my @e = $g->edges_from( @_ );
        0   0.00000   0.00000  1627:    wantarray ? map { @$_ } @e : @e;
        0   0.00000   0.00000  1628:}
        0   0.00000   0.00000  1629:
        0   0.00000   0.00000  1630:sub in_edges {
        0   0.00000   0.00000  1631:    my $g = shift;
        0   0.00000   0.00000  1632:    return unless @_ && $g->has_vertex( @_ );
        0   0.00000   0.00000  1633:    my @e = $g->edges_to( @_ );
        0   0.00000   0.00000  1634:    wantarray ? map { @$_ } @e : @e;
        0   0.00000   0.00000  1635:}
        0   0.00000   0.00000  1636:
        0   0.00000   0.00000  1637:sub add_vertices {
        0   0.00000   0.00000  1638:    my $g = shift;
        0   0.00000   0.00000  1639:    $g->add_vertex( $_ ) for @_;
        0   0.00000   0.00000  1640:    return $g;
        0   0.00000   0.00000  1641:}
        0   0.00000   0.00000  1642:
        0   0.00000   0.00000  1643:sub add_edges {
       54   0.00000   0.00000  1644:    my $g = shift;
       54   0.00000   0.00000  1645:    while (@_) {
       54   0.00000   0.00000  1646: my $u = shift @_;
       54   0.00000   0.00000  1647: if (ref $u eq 'ARRAY') {
        0   0.00000   0.00000  1648:     $g->add_edge( @$u );
        0   0.00000   0.00000  1649: } else {
        0   0.00000   0.00000  1650:     if (@_) {
        0   0.00000   0.00000  1651:  my $v = shift @_;
        0   0.00000   0.00000  1652:  $g->add_edge( $u, $v );
        0   0.00000   0.00000  1653:     } else {
        0   0.00000   0.00000  1654:  require Carp;
        0   0.00000   0.00000  1655:  Carp::croak("Graph::add_edges: missing end
        0   0.00000   0.00000  1656:     }
        0   0.00000   0.00000  1657: }
        0   0.00000   0.00000  1658:    }
       54   0.00000   0.00000  1659:    return $g;
        0   0.00000   0.00000  1660:}
        0   0.00000   0.00000  1661:
        0   0.00000   0.00000  1662:###
        0   0.00000   0.00000  1663:# More constructors.
        0   0.00000   0.00000  1664:#
        0   0.00000   0.00000  1665:
        0   0.00000   0.00000  1666:sub copy {
        0   0.00000   0.00000  1667:    my $g = shift;
        0   0.00000   0.00000  1668:    my %opt = _get_options( \@_ );
        0   0.00000   0.00000  1669:
        0   0.00000   0.00000  1670:    my $c =
        0   0.00000   0.00000  1671: (ref $g)->new(map { $_ => $g->$_ ? 1 : 0 }
        0   0.00000   0.00000  1672:        qw(directed
        0   0.00000   0.00000  1673:    compat02
        0   0.00000   0.00000  1674:    refvertexed
        0   0.00000   0.00000  1675:    hypervertexed
        0   0.00000   0.00000  1676:    countvertexed
        0   0.00000   0.00000  1677:    multivertexed
        0   0.00000   0.00000  1678:    hyperedged
        0   0.00000   0.00000  1679:    countedged
        0   0.00000   0.00000  1680:    multiedged
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 73
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1681:    omniedged));
        0   0.00000   0.00000  1682:    for my $v ($g->isolated_vertices) { $c-
        0   0.00000   0.00000  1683:    for my $e ($g->edges05)           { $c-
        0   0.00000   0.00000  1684:
        0   0.00000   0.00000  1685:    return $c;
        0   0.00000   0.00000  1686:}
        0   0.00000   0.00000  1687:
        0   0.00000   0.00000  1688:*copy_graph = \&copy;
        0   0.00000   0.00000  1689:
        0   0.00000   0.00000  1690:sub _deep_copy_Storable {
        0   0.00000   0.00000  1691:    my $g = shift;
        0   0.00000   0.00000  1692:    my $safe = new Safe;
        0   0.00000   0.00000  1693:    local $Storable::Deparse = 1;
        0   0.00000   0.00000  1694:    local $Storable::Eval = sub { $safe-
        0   0.00000   0.00000  1695:    return
        0   0.00000   0.00000  1696:}
        0   0.00000   0.00000  1697:
        0   0.00000   0.00000  1698:sub _deep_copy_DataDumper {
        0   0.00000   0.00000  1699:    my $g = shift;
        0   0.00000   0.00000  1700:    my $d = Data::Dumper->new([$g]);
        0   0.00000   0.00000  1701:    use vars qw($VAR1);
        0   0.00000   0.00000  1702:    $d->Purity(1)->Terse(1)->Deepcopy(1);
        0   0.00000   0.00000  1703:    $d->Deparse(1) if $] >= 5.008;
        0   0.00000   0.00000  1704:    eval $d->Dump;
        0   0.00000   0.00000  1705:}
        0   0.00000   0.00000  1706:
        0   0.00000   0.00000  1707:sub deep_copy {
        0   0.00000   0.00000  1708:    if (_can_deep_copy_Storable()) {
        0   0.00000   0.00000  1709: return _deep_copy_Storable(@_);
        0   0.00000   0.00000  1710:    } else {
        0   0.00000   0.00000  1711: return _deep_copy_DataDumper(@_);
        0   0.00000   0.00000  1712:    }
        0   0.00000   0.00000  1713:}
        0   0.00000   0.00000  1714:
        0   0.00000   0.00000  1715:*deep_copy_graph = \&deep_copy;
        0   0.00000   0.00000  1716:
        0   0.00000   0.00000  1717:sub transpose_edge {
        0   0.00000   0.00000  1718:    my $g = shift;
        0   0.00000   0.00000  1719:    if ($g->is_directed) {
        0   0.00000   0.00000  1720: return undef unless $g->has_edge( @_ );
        0   0.00000   0.00000  1721: my $c = $g->get_edge_count( @_ );
        0   0.00000   0.00000  1722: my $a = $g->get_edge_attributes( @_ );
        0   0.00000   0.00000  1723: my @e = reverse @_;
        0   0.00000   0.00000  1724: $g->delete_edge( @_ ) unless $g->has_edge(
        0   0.00000   0.00000  1725: $g->add_edge( @e ) for 1..$c;
        0   0.00000   0.00000  1726: $g->set_edge_attributes(@e, $a) if $a;
        0   0.00000   0.00000  1727:    }
        0   0.00000   0.00000  1728:    return $g;
        0   0.00000   0.00000  1729:}
        0   0.00000   0.00000  1730:
        0   0.00000   0.00000  1731:sub transpose_graph {
        0   0.00000   0.00000  1732:    my $g = shift;
        0   0.00000   0.00000  1733:    my $t = $g->copy;
        0   0.00000   0.00000  1734:    if ($t->directed) {
        0   0.00000   0.00000  1735: for my $e ($t->edges05) {
        0   0.00000   0.00000  1736:     $t->transpose_edge(@$e);
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 74
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1737: }
        0   0.00000   0.00000  1738:    }
        0   0.00000   0.00000  1739:    return $t;
        0   0.00000   0.00000  1740:}
        0   0.00000   0.00000  1741:
        0   0.00000   0.00000  1742:*transpose = \&transpose_graph;
        0   0.00000   0.00000  1743:
        0   0.00000   0.00000  1744:sub complete_graph {
        0   0.00000   0.00000  1745:    my $g = shift;
        0   0.00000   0.00000  1746:    my $c = $g->new( directed => $g->directed
        0   0.00000   0.00000  1747:    my @v = $g->vertices05;
        0   0.00000   0.00000  1748:    for (my $i = 0; $i <= $#v; $i++ ) {
        0   0.00000   0.00000  1749: for (my $j = 0; $j <= $#v; $j++ ) {
        0   0.00000   0.00000  1750:     next if $i >= $j;
        0   0.00000   0.00000  1751:     if ($g->is_undirected) {
        0   0.00000   0.00000  1752:  $c->add_edge($v[$i], $v[$j]);
        0   0.00000   0.00000  1753:     } else {
        0   0.00000   0.00000  1754:  $c->add_edge($v[$i], $v[$j]);
        0   0.00000   0.00000  1755:  $c->add_edge($v[$j], $v[$i]);
        0   0.00000   0.00000  1756:     }
        0   0.00000   0.00000  1757: }
        0   0.00000   0.00000  1758:    }
        0   0.00000   0.00000  1759:    return $c;
        0   0.00000   0.00000  1760:}
        0   0.00000   0.00000  1761:
        0   0.00000   0.00000  1762:*complement = \&complement_graph;
        0   0.00000   0.00000  1763:
        0   0.00000   0.00000  1764:sub complement_graph {
        0   0.00000   0.00000  1765:    my $g = shift;
        0   0.00000   0.00000  1766:    my $c = $g->new( directed => $g->directed
        0   0.00000   0.00000  1767:    my @v = $g->vertices05;
        0   0.00000   0.00000  1768:    for (my $i = 0; $i <= $#v; $i++ ) {
        0   0.00000   0.00000  1769: for (my $j = 0; $j <= $#v; $j++ ) {
        0   0.00000   0.00000  1770:     next if $i >= $j;
        0   0.00000   0.00000  1771:     if ($g->is_undirected) {
        0   0.00000   0.00000  1772:  $c->add_edge($v[$i], $v[$j])
        0   0.00000   0.00000  1773:      unless $g->has_edge($v[$i], $v[$j]);
        0   0.00000   0.00000  1774:     } else {
        0   0.00000   0.00000  1775:  $c->add_edge($v[$i], $v[$j])
        0   0.00000   0.00000  1776:      unless $g->has_edge($v[$i], $v[$j]);
        0   0.00000   0.00000  1777:  $c->add_edge($v[$j], $v[$i])
        0   0.00000   0.00000  1778:      unless $g->has_edge($v[$j], $v[$i]);
        0   0.00000   0.00000  1779:     }
        0   0.00000   0.00000  1780: }
        0   0.00000   0.00000  1781:    }
        0   0.00000   0.00000  1782:    return $c;
        0   0.00000   0.00000  1783:}
        0   0.00000   0.00000  1784:
        0   0.00000   0.00000  1785:*complete = \&complete_graph;
        0   0.00000   0.00000  1786:
        0   0.00000   0.00000  1787:###
        0   0.00000   0.00000  1788:# Transitivity.
        0   0.00000   0.00000  1789:#
        0   0.00000   0.00000  1790:
        0   0.00000   0.00000  1791:sub is_transitive {
        0   0.00000   0.00000  1792:    my $g = shift;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 75
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1793:
        0   0.00000   0.00000  1794:}
        0   0.00000   0.00000  1795:
        0   0.00000   0.00000  1796:###
        0   0.00000   0.00000  1797:# Weighted vertices.
        0   0.00000   0.00000  1798:#
        0   0.00000   0.00000  1799:
        0   0.00000   0.00000  1800:my $defattr = 'weight';
        0   0.00000   0.00000  1801:
        0   0.00000   0.00000  1802:sub _defattr {
        0   0.00000   0.00000  1803:    return $defattr;
        0   0.00000   0.00000  1804:}
        0   0.00000   0.00000  1805:
        0   0.00000   0.00000  1806:sub add_weighted_vertex {
        0   0.00000   0.00000  1807:    my $g = shift;
        0   0.00000   0.00000  1808:    $g->expect_non_multivertexed;
        0   0.00000   0.00000  1809:    my $w = pop;
        0   0.00000   0.00000  1810:    $g->add_vertex(@_);
        0   0.00000   0.00000  1811:    $g->set_vertex_attribute(@_, $defattr,
        0   0.00000   0.00000  1812:}
        0   0.00000   0.00000  1813:
        0   0.00000   0.00000  1814:sub add_weighted_vertices {
        0   0.00000   0.00000  1815:    my $g = shift;
        0   0.00000   0.00000  1816:    $g->expect_non_multivertexed;
        0   0.00000   0.00000  1817:    while (@_) {
        0   0.00000   0.00000  1818: my ($v, $w) = splice @_, 0, 2;
        0   0.00000   0.00000  1819: $g->add_vertex($v);
        0   0.00000   0.00000  1820: $g->set_vertex_attribute($v, $defattr, $w);
        0   0.00000   0.00000  1821:    }
        0   0.00000   0.00000  1822:}
        0   0.00000   0.00000  1823:
        0   0.00000   0.00000  1824:sub get_vertex_weight {
        0   0.00000   0.00000  1825:    my $g = shift;
        0   0.00000   0.00000  1826:    $g->expect_non_multivertexed;
        0   0.00000   0.00000  1827:    $g->get_vertex_attribute(@_, $defattr);
        0   0.00000   0.00000  1828:}
        0   0.00000   0.00000  1829:
        0   0.00000   0.00000  1830:sub has_vertex_weight {
        0   0.00000   0.00000  1831:    my $g = shift;
        0   0.00000   0.00000  1832:    $g->expect_non_multivertexed;
        0   0.00000   0.00000  1833:    $g->has_vertex_attribute(@_, $defattr);
        0   0.00000   0.00000  1834:}
        0   0.00000   0.00000  1835:
        0   0.00000   0.00000  1836:sub set_vertex_weight {
        0   0.00000   0.00000  1837:    my $g = shift;
        0   0.00000   0.00000  1838:    $g->expect_non_multivertexed;
        0   0.00000   0.00000  1839:    my $w = pop;
        0   0.00000   0.00000  1840:    $g->set_vertex_attribute(@_, $defattr,
        0   0.00000   0.00000  1841:}
        0   0.00000   0.00000  1842:
        0   0.00000   0.00000  1843:sub delete_vertex_weight {
        0   0.00000   0.00000  1844:    my $g = shift;
        0   0.00000   0.00000  1845:    $g->expect_non_multivertexed;
        0   0.00000   0.00000  1846:    $g->delete_vertex_attribute(@_,
        0   0.00000   0.00000  1847:}
        0   0.00000   0.00000  1848:
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 76
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1849:sub add_weighted_vertex_by_id {
        0   0.00000   0.00000  1850:    my $g = shift;
        0   0.00000   0.00000  1851:    $g->expect_multivertexed;
        0   0.00000   0.00000  1852:    my $w = pop;
        0   0.00000   0.00000  1853:    $g->add_vertex_by_id(@_);
        0   0.00000   0.00000  1854:    $g->set_vertex_attribute_by_id(@_,
        0   0.00000   0.00000  1855:}
        0   0.00000   0.00000  1856:
        0   0.00000   0.00000  1857:sub add_weighted_vertices_by_id {
        0   0.00000   0.00000  1858:    my $g = shift;
        0   0.00000   0.00000  1859:    $g->expect_multivertexed;
        0   0.00000   0.00000  1860:    my $id = pop;
        0   0.00000   0.00000  1861:    while (@_) {
        0   0.00000   0.00000  1862: my ($v, $w) = splice @_, 0, 2;
        0   0.00000   0.00000  1863: $g->add_vertex_by_id($v, $id);
        0   0.00000   0.00000  1864: $g->set_vertex_attribute_by_id($v, $id,
        0   0.00000   0.00000  1865:    }
        0   0.00000   0.00000  1866:}
        0   0.00000   0.00000  1867:
        0   0.00000   0.00000  1868:sub get_vertex_weight_by_id {
        0   0.00000   0.00000  1869:    my $g = shift;
        0   0.00000   0.00000  1870:    $g->expect_multivertexed;
        0   0.00000   0.00000  1871:    $g->get_vertex_attribute_by_id(@_,
        0   0.00000   0.00000  1872:}
        0   0.00000   0.00000  1873:
        0   0.00000   0.00000  1874:sub has_vertex_weight_by_id {
        0   0.00000   0.00000  1875:    my $g = shift;
        0   0.00000   0.00000  1876:    $g->expect_multivertexed;
        0   0.00000   0.00000  1877:    $g->has_vertex_attribute_by_id(@_,
        0   0.00000   0.00000  1878:}
        0   0.00000   0.00000  1879:
        0   0.00000   0.00000  1880:sub set_vertex_weight_by_id {
        0   0.00000   0.00000  1881:    my $g = shift;
        0   0.00000   0.00000  1882:    $g->expect_multivertexed;
        0   0.00000   0.00000  1883:    my $w = pop;
        0   0.00000   0.00000  1884:    $g->set_vertex_attribute_by_id(@_,
        0   0.00000   0.00000  1885:}
        0   0.00000   0.00000  1886:
        0   0.00000   0.00000  1887:sub delete_vertex_weight_by_id {
        0   0.00000   0.00000  1888:    my $g = shift;
        0   0.00000   0.00000  1889:    $g->expect_multivertexed;
        0   0.00000   0.00000  1890:    $g->delete_vertex_attribute_by_id(@_,
        0   0.00000   0.00000  1891:}
        0   0.00000   0.00000  1892:
        0   0.00000   0.00000  1893:###
        0   0.00000   0.00000  1894:# Weighted edges.
        0   0.00000   0.00000  1895:#
        0   0.00000   0.00000  1896:
        0   0.00000   0.00000  1897:sub add_weighted_edge {
        0   0.00000   0.00000  1898:    my $g = shift;
        0   0.00000   0.00000  1899:    $g->expect_non_multiedged;
        0   0.00000   0.00000  1900:    if ($g->is_compat02) {
        0   0.00000   0.00000  1901: my $w = splice @_, 1, 1;
        0   0.00000   0.00000  1902: $g->add_edge(@_);
        0   0.00000   0.00000  1903: $g->set_edge_attribute(@_, $defattr, $w);
        0   0.00000   0.00000  1904:    } else {
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 77
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1905: my $w = pop;
        0   0.00000   0.00000  1906: $g->add_edge(@_);
        0   0.00000   0.00000  1907: $g->set_edge_attribute(@_, $defattr, $w);
        0   0.00000   0.00000  1908:    }
        0   0.00000   0.00000  1909:}
        0   0.00000   0.00000  1910:
        0   0.00000   0.00000  1911:sub add_weighted_edges {
        0   0.00000   0.00000  1912:    my $g = shift;
        0   0.00000   0.00000  1913:    $g->expect_non_multiedged;
        0   0.00000   0.00000  1914:    if ($g->is_compat02) {
        0   0.00000   0.00000  1915: while (@_) {
        0   0.00000   0.00000  1916:     my ($u, $w, $v) = splice @_, 0, 3;
        0   0.00000   0.00000  1917:     $g->add_edge($u, $v);
        0   0.00000   0.00000  1918:     $g->set_edge_attribute($u, $v, $defattr,
        0   0.00000   0.00000  1919: }
        0   0.00000   0.00000  1920:    } else {
        0   0.00000   0.00000  1921: while (@_) {
        0   0.00000   0.00000  1922:     my ($u, $v, $w) = splice @_, 0, 3;
        0   0.00000   0.00000  1923:     $g->add_edge($u, $v);
        0   0.00000   0.00000  1924:     $g->set_edge_attribute($u, $v, $defattr,
        0   0.00000   0.00000  1925: }
        0   0.00000   0.00000  1926:    }
        0   0.00000   0.00000  1927:}
        0   0.00000   0.00000  1928:
        0   0.00000   0.00000  1929:sub add_weighted_edges_by_id {
        0   0.00000   0.00000  1930:    my $g = shift;
        0   0.00000   0.00000  1931:    $g->expect_multiedged;
        0   0.00000   0.00000  1932:    my $id = pop;
        0   0.00000   0.00000  1933:    while (@_) {
        0   0.00000   0.00000  1934: my ($u, $v, $w) = splice @_, 0, 3;
        0   0.00000   0.00000  1935: $g->add_edge_by_id($u, $v, $id);
        0   0.00000   0.00000  1936: $g->set_edge_attribute_by_id($u, $v, $id,
        0   0.00000   0.00000  1937:    }
        0   0.00000   0.00000  1938:}
        0   0.00000   0.00000  1939:
        0   0.00000   0.00000  1940:sub add_weighted_path {
        0   0.00000   0.00000  1941:    my $g = shift;
        0   0.00000   0.00000  1942:    $g->expect_non_multiedged;
        0   0.00000   0.00000  1943:    my $u = shift;
        0   0.00000   0.00000  1944:    while (@_) {
        0   0.00000   0.00000  1945: my ($w, $v) = splice @_, 0, 2;
        0   0.00000   0.00000  1946: $g->add_edge($u, $v);
        0   0.00000   0.00000  1947: $g->set_edge_attribute($u, $v, $defattr,
        0   0.00000   0.00000  1948: $u = $v;
        0   0.00000   0.00000  1949:    }
        0   0.00000   0.00000  1950:}
        0   0.00000   0.00000  1951:
        0   0.00000   0.00000  1952:sub get_edge_weight {
        0   0.00000   0.00000  1953:    my $g = shift;
        0   0.00000   0.00000  1954:    $g->expect_non_multiedged;
        0   0.00000   0.00000  1955:    $g->get_edge_attribute(@_, $defattr);
        0   0.00000   0.00000  1956:}
        0   0.00000   0.00000  1957:
        0   0.00000   0.00000  1958:sub has_edge_weight {
        0   0.00000   0.00000  1959:    my $g = shift;
        0   0.00000   0.00000  1960:    $g->expect_non_multiedged;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 78
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1961:    $g->has_edge_attribute(@_, $defattr);
        0   0.00000   0.00000  1962:}
        0   0.00000   0.00000  1963:
        0   0.00000   0.00000  1964:sub set_edge_weight {
        0   0.00000   0.00000  1965:    my $g = shift;
        0   0.00000   0.00000  1966:    $g->expect_non_multiedged;
        0   0.00000   0.00000  1967:    my $w = pop;
        0   0.00000   0.00000  1968:    $g->set_edge_attribute(@_, $defattr, $w);
        0   0.00000   0.00000  1969:}
        0   0.00000   0.00000  1970:
        0   0.00000   0.00000  1971:sub delete_edge_weight {
        0   0.00000   0.00000  1972:    my $g = shift;
        0   0.00000   0.00000  1973:    $g->expect_non_multiedged;
        0   0.00000   0.00000  1974:    $g->delete_edge_attribute(@_, $defattr);
        0   0.00000   0.00000  1975:}
        0   0.00000   0.00000  1976:
        0   0.00000   0.00000  1977:sub add_weighted_edge_by_id {
        0   0.00000   0.00000  1978:    my $g = shift;
        0   0.00000   0.00000  1979:    $g->expect_multiedged;
        0   0.00000   0.00000  1980:    if ($g->is_compat02) {
        0   0.00000   0.00000  1981: my $w = splice @_, 1, 1;
        0   0.00000   0.00000  1982: $g->add_edge_by_id(@_);
        0   0.00000   0.00000  1983: $g->set_edge_attribute_by_id(@_, $defattr,
        0   0.00000   0.00000  1984:    } else {
        0   0.00000   0.00000  1985: my $w = pop;
        0   0.00000   0.00000  1986: $g->add_edge_by_id(@_);
        0   0.00000   0.00000  1987: $g->set_edge_attribute_by_id(@_, $defattr,
        0   0.00000   0.00000  1988:    }
        0   0.00000   0.00000  1989:}
        0   0.00000   0.00000  1990:
        0   0.00000   0.00000  1991:sub add_weighted_path_by_id {
        0   0.00000   0.00000  1992:    my $g = shift;
        0   0.00000   0.00000  1993:    $g->expect_multiedged;
        0   0.00000   0.00000  1994:    my $id = pop;
        0   0.00000   0.00000  1995:    my $u = shift;
        0   0.00000   0.00000  1996:    while (@_) {
        0   0.00000   0.00000  1997: my ($w, $v) = splice @_, 0, 2;
        0   0.00000   0.00000  1998: $g->add_edge_by_id($u, $v, $id);
        0   0.00000   0.00000  1999: $g->set_edge_attribute_by_id($u, $v, $id,
        0   0.00000   0.00000  2000: $u = $v;
        0   0.00000   0.00000  2001:    }
        0   0.00000   0.00000  2002:}
        0   0.00000   0.00000  2003:
        0   0.00000   0.00000  2004:sub get_edge_weight_by_id {
        0   0.00000   0.00000  2005:    my $g = shift;
        0   0.00000   0.00000  2006:    $g->expect_multiedged;
        0   0.00000   0.00000  2007:    $g->get_edge_attribute_by_id(@_,
        0   0.00000   0.00000  2008:}
        0   0.00000   0.00000  2009:
        0   0.00000   0.00000  2010:sub has_edge_weight_by_id {
        0   0.00000   0.00000  2011:    my $g = shift;
        0   0.00000   0.00000  2012:    $g->expect_multiedged;
        0   0.00000   0.00000  2013:    $g->has_edge_attribute_by_id(@_,
        0   0.00000   0.00000  2014:}
        0   0.00000   0.00000  2015:
        0   0.00000   0.00000  2016:sub set_edge_weight_by_id {
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 79
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2017:    my $g = shift;
        0   0.00000   0.00000  2018:    $g->expect_multiedged;
        0   0.00000   0.00000  2019:    my $w = pop;
        0   0.00000   0.00000  2020:    $g->set_edge_attribute_by_id(@_,
        0   0.00000   0.00000  2021:}
        0   0.00000   0.00000  2022:
        0   0.00000   0.00000  2023:sub delete_edge_weight_by_id {
        0   0.00000   0.00000  2024:    my $g = shift;
        0   0.00000   0.00000  2025:    $g->expect_multiedged;
        0   0.00000   0.00000  2026:    $g->delete_edge_attribute_by_id(@_,
        0   0.00000   0.00000  2027:}
        0   0.00000   0.00000  2028:
        0   0.00000   0.00000  2029:###
        0   0.00000   0.00000  2030:# Error helpers.
        0   0.00000   0.00000  2031:#
        0   0.00000   0.00000  2032:
        0   0.00000   0.00000  2033:my %expected;
        0   0.00000   0.00000  2034:@expected{qw(directed undirected acyclic)} =
        0   0.00000   0.00000  2035:
        0   0.00000   0.00000  2036:sub _expected {
        0   0.00000   0.00000  2037:    my $exp = shift;
        0   0.00000   0.00000  2038:    my $got = @_ ? shift : $expected{$exp};
        0   0.00000   0.00000  2039:    $got = defined $got ? ", got $got" : "";
        0   0.00000   0.00000  2040:    if (my @caller2 = caller(2)) {
        0   0.00000   0.00000  2041: die "$caller2[3]: expected $exp graph$got,
        0   0.00000   0.00000  2042:    } else {
        0   0.00000   0.00000  2043: my @caller1 = caller(1);
        0   0.00000   0.00000  2044: die "$caller1[3]: expected $exp graph$got,
        0   0.00000   0.00000  2045:    }
        0   0.00000   0.00000  2046:}
        0   0.00000   0.00000  2047:
        0   0.00000   0.00000  2048:sub expect_undirected {
        8   0.00000   0.00000  2049:    my $g = shift;
        8   0.00000   0.00000  2050:    _expected('undirected') unless $g-
        0   0.00000   0.00000  2051:}
        0   0.00000   0.00000  2052:
        0   0.00000   0.00000  2053:sub expect_directed {
        0   0.00000   0.00000  2054:    my $g = shift;
        0   0.00000   0.00000  2055:    _expected('directed') unless $g-
        0   0.00000   0.00000  2056:}
        0   0.00000   0.00000  2057:
        0   0.00000   0.00000  2058:sub expect_acyclic {
        0   0.00000   0.00000  2059:    my $g = shift;
        0   0.00000   0.00000  2060:    _expected('acyclic') unless $g-
        0   0.00000   0.00000  2061:}
        0   0.00000   0.00000  2062:
        0   0.00000   0.00000  2063:sub expect_dag {
        0   0.00000   0.00000  2064:    my $g = shift;
        0   0.00000   0.00000  2065:    my @got;
        0   0.00000   0.00000  2066:    push @got, 'undirected' unless $g-
        0   0.00000   0.00000  2067:    push @got, 'cyclic'     unless $g-
        0   0.00000   0.00000  2068:    _expected('directed acyclic', "@got") if
        0   0.00000   0.00000  2069:}
        0   0.00000   0.00000  2070:
        0   0.00000   0.00000  2071:sub expect_multivertexed {
        0   0.00000   0.00000  2072:    my $g = shift;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 80
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2073:    _expected('multivertexed') unless $g-
        0   0.00000   0.00000  2074:}
        0   0.00000   0.00000  2075:
        0   0.00000   0.00000  2076:sub expect_non_multivertexed {
     7372   0.00070   0.09000  2077:    my $g = shift;
     7372   0.00094   0.05000  2078:    _expected('non-multivertexed') if $g-
        0   0.00000   0.00000  2079:}
        0   0.00000   0.00000  2080:
        0   0.00000   0.00000  2081:sub expect_non_multiedged {
     2164   0.00002   0.01000  2082:    my $g = shift;
     2164   0.00095   0.01000  2083:    _expected('non-multiedged') if $g-
        0   0.00000   0.00000  2084:}
        0   0.00000   0.00000  2085:
        0   0.00000   0.00000  2086:sub expect_multiedged {
        0   0.00000   0.00000  2087:    my $g = shift;
        0   0.00000   0.00000  2088:    _expected('multiedged') unless $g-
        0   0.00000   0.00000  2089:}
        0   0.00000   0.00000  2090:
        0   0.00000   0.00000  2091:sub _get_options {
      116   0.00000   0.00000  2092:    my @caller = caller(1);
      116   0.00001   0.02000  2093:    unless (@_ == 1 && ref $_[0] eq 'ARRAY')
        0   0.00000   0.00000  2094: die "$caller[3]: internal error: should be
        0   0.00000   0.00000  2095:    }
      116   0.00000   0.00000  2096:    my @opt = @{ $_[0] };
      116   0.00001   0.00000  2097:    unless (@opt  % 2 == 0) {
        0   0.00000   0.00000  2098: die "$caller[3]: expected an options hash,
        0   0.00000   0.00000  2099:    }
      116   0.00000   0.00000  2100:    return @opt;
        0   0.00000   0.00000  2101:}
        0   0.00000   0.00000  2102:
        0   0.00000   0.00000  2103:###
        0   0.00000   0.00000  2104:# Random constructors and accessors.
        0   0.00000   0.00000  2105:#
        0   0.00000   0.00000  2106:
        0   0.00000   0.00000  2107:sub __fisher_yates_shuffle (@) {
        0   0.00000   0.00000  2108:    # From perlfaq4, but modified to be non-
        0   0.00000   0.00000  2109:    my @a = @_;
        0   0.00000   0.00000  2110:    my $i = @a;
        0   0.00000   0.00000  2111:    while ($i--) {
        0   0.00000   0.00000  2112: my $j = int rand ($i+1);
        0   0.00000   0.00000  2113: @a[$i,$j] = @a[$j,$i];
        0   0.00000   0.00000  2114:    }
        0   0.00000   0.00000  2115:    return @a;
        0   0.00000   0.00000  2116:}
        0   0.00000   0.00000  2117:
        0   0.00000   0.00000  2118:BEGIN {
        0   0.00000   0.00000  2119:    sub _shuffle(@);
        0   0.00000   0.00000  2120:    # Workaround for the Perl bug [perl
        0   0.00000   0.00000  2121:    # List::Util::shuffle do not like each
        0   0.00000   0.00000  2122:    # (-d) flags are on, fall back to our own
        0   0.00000   0.00000  2123:    # The bug was fixed by perl changes
        0   0.00000   0.00000  2124:    # went to Perl 5.9.3.  If someone tests
        0   0.00000   0.00000  2125:    # bleadperl that calls itself 5.9.3 but
        0   0.00000   0.00000  2126:    # patches, oh, well.
        0   0.00000   0.00000  2127:    *_shuffle = $^P && $] < 5.009003 ?
        0   0.00000   0.00000  2128: \&__fisher_yates_shuffle :
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 81
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2129:}
        0   0.00000   0.00000  2130:
        0   0.00000   0.00000  2131:sub random_graph {
        0   0.00000   0.00000  2132:    my $class = (@_ % 2) == 0 ? 'Graph' :
        0   0.00000   0.00000  2133:    my %opt = _get_options( \@_ );
        0   0.00000   0.00000  2134:    my $random_edge;
        0   0.00000   0.00000  2135:    unless (exists $opt{vertices} && defined
        0   0.00000   0.00000  2136: require Carp;
        0   0.00000   0.00000  2137: Carp::croak("Graph::random_graph: argument
        0   0.00000   0.00000  2138:    }
        0   0.00000   0.00000  2139:    if (exists $opt{random_seed}) {
        0   0.00000   0.00000  2140: srand($opt{random_seed});
        0   0.00000   0.00000  2141: delete $opt{random_seed};
        0   0.00000   0.00000  2142:    }
        0   0.00000   0.00000  2143:    if (exists $opt{random_edge}) {
        0   0.00000   0.00000  2144: $random_edge = $opt{random_edge};
        0   0.00000   0.00000  2145: delete $opt{random_edge};
        0   0.00000   0.00000  2146:    }
        0   0.00000   0.00000  2147:    my @V;
        0   0.00000   0.00000  2148:    if (my $ref = ref $opt{vertices}) {
        0   0.00000   0.00000  2149: if ($ref eq 'ARRAY') {
        0   0.00000   0.00000  2150:     @V = @{ $opt{vertices} };
        0   0.00000   0.00000  2151: } else {
        0   0.00000   0.00000  2152:     Carp::croak("Graph::random_graph:
        0   0.00000   0.00000  2153: }
        0   0.00000   0.00000  2154:    } else {
        0   0.00000   0.00000  2155: @V = 0..($opt{vertices} - 1);
        0   0.00000   0.00000  2156:    }
        0   0.00000   0.00000  2157:    delete $opt{vertices};
        0   0.00000   0.00000  2158:    my $V = @V;
        0   0.00000   0.00000  2159:    my $C = $V * ($V - 1) / 2;
        0   0.00000   0.00000  2160:    my $E;
        0   0.00000   0.00000  2161:    if (exists $opt{edges} && exists
        0   0.00000   0.00000  2162: Carp::croak("Graph::random_graph: both
        0   0.00000   0.00000  2163:    }
        0   0.00000   0.00000  2164:    $E = exists $opt{edges_fill} ?
        0   0.00000   0.00000  2165:    delete $opt{edges};
        0   0.00000   0.00000  2166:    delete $opt{edges_fill};
        0   0.00000   0.00000  2167:    my $g = $class->new(%opt);
        0   0.00000   0.00000  2168:    $g->add_vertices(@V);
        0   0.00000   0.00000  2169:    return $g if $V < 2;
        0   0.00000   0.00000  2170:    $C *= 2 if $g->directed;
        0   0.00000   0.00000  2171:    $E = $C / 2 unless defined $E;
        0   0.00000   0.00000  2172:    $E = int($E + 0.5);
        0   0.00000   0.00000  2173:    my $p = $E / $C;
        0   0.00000   0.00000  2174:    $random_edge = sub { $p } unless defined
        0   0.00000   0.00000  2175:    # print "V = $V, E = $E, C = $C, p =
        0   0.00000   0.00000  2176:    if ($p > 1.0 && !($g->countedged || $g-
        0   0.00000   0.00000  2177: require Carp;
        0   0.00000   0.00000  2178: Carp::croak("Graph::random_graph: needs to
        0   0.00000   0.00000  2179:    }
        0   0.00000   0.00000  2180:    my @V1 = @V;
        0   0.00000   0.00000  2181:    my @V2 = @V;
        0   0.00000   0.00000  2182:    # Shuffle the vertex lists so that the
        0   0.00000   0.00000  2183:    # the beginning of the lists are not more
        0   0.00000   0.00000  2184:    @V1 = _shuffle @V1;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 82
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2185:    @V2 = _shuffle @V2;
        0   0.00000   0.00000  2186: LOOP:
        0   0.00000   0.00000  2187:    while ($E) {
        0   0.00000   0.00000  2188: for my $v1 (@V1) {
        0   0.00000   0.00000  2189:     for my $v2 (@V2) {
        0   0.00000   0.00000  2190:  next if $v1 eq $v2; # TODO: allow self-
        0   0.00000   0.00000  2191:  my $q = $random_edge->($g, $v1, $v2, $p);
        0   0.00000   0.00000  2192:  if ($q && ($q == 1 || rand() <= $q) &&
        0   0.00000   0.00000  2193:      !$g->has_edge($v1, $v2)) {
        0   0.00000   0.00000  2194:      $g->add_edge($v1, $v2);
        0   0.00000   0.00000  2195:      $E--;
        0   0.00000   0.00000  2196:      last LOOP unless $E;
        0   0.00000   0.00000  2197:  }
        0   0.00000   0.00000  2198:     }
        0   0.00000   0.00000  2199: }
        0   0.00000   0.00000  2200:    }
        0   0.00000   0.00000  2201:    return $g;
        0   0.00000   0.00000  2202:}
        0   0.00000   0.00000  2203:
        0   0.00000   0.00000  2204:sub random_vertex {
        0   0.00000   0.00000  2205:    my $g = shift;
        0   0.00000   0.00000  2206:    my @V = $g->vertices05;
        0   0.00000   0.00000  2207:    @V[rand @V];
        0   0.00000   0.00000  2208:}
        0   0.00000   0.00000  2209:
        0   0.00000   0.00000  2210:sub random_edge {
        0   0.00000   0.00000  2211:    my $g = shift;
        0   0.00000   0.00000  2212:    my @E = $g->edges05;
        0   0.00000   0.00000  2213:    @E[rand @E];
        0   0.00000   0.00000  2214:}
        0   0.00000   0.00000  2215:
        0   0.00000   0.00000  2216:sub random_successor {
        0   0.00000   0.00000  2217:    my ($g, $v) = @_;
        0   0.00000   0.00000  2218:    my @S = $g->successors($v);
        0   0.00000   0.00000  2219:    @S[rand @S];
        0   0.00000   0.00000  2220:}
        0   0.00000   0.00000  2221:
        0   0.00000   0.00000  2222:sub random_predecessor {
        0   0.00000   0.00000  2223:    my ($g, $v) = @_;
        0   0.00000   0.00000  2224:    my @P = $g->predecessors($v);
        0   0.00000   0.00000  2225:    @P[rand @P];
        0   0.00000   0.00000  2226:}
        0   0.00000   0.00000  2227:
        0   0.00000   0.00000  2228:###
        0   0.00000   0.00000  2229:# Algorithms.
        0   0.00000   0.00000  2230:#
        0   0.00000   0.00000  2231:
        0   0.00000   0.00000  2232:my $MST_comparator = sub { ($_[0] || 0) <=>
        0   0.00000   0.00000  2233:
        0   0.00000   0.00000  2234:sub _MST_attr {
        0   0.00000   0.00000  2235:    my $attr = shift;
        0   0.00000   0.00000  2236:    my $attribute =
        0   0.00000   0.00000  2237: exists $attr->{attribute}  ?
        0   0.00000   0.00000  2238:     $attr->{attribute}  : $defattr;
        0   0.00000   0.00000  2239:    my $comparator =
        0   0.00000   0.00000  2240: exists $attr->{comparator} ?
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 83
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2241:     $attr->{comparator} : $MST_comparator;
        0   0.00000   0.00000  2242:    return ($attribute, $comparator);
        0   0.00000   0.00000  2243:}
        0   0.00000   0.00000  2244:
        0   0.00000   0.00000  2245:sub _MST_edges {
        0   0.00000   0.00000  2246:    my ($g, $attr) = @_;
        0   0.00000   0.00000  2247:    my ($attribute, $comparator) =
        0   0.00000   0.00000  2248:    map { $_->[1] }
        0   0.00000   0.00000  2249:        sort { $comparator->($a->[0], $b-
        0   0.00000   0.00000  2250:             map { [ $g-
        0   0.00000   0.00000  2251:                 $g->edges05;
        0   0.00000   0.00000  2252:}
        0   0.00000   0.00000  2253:
        0   0.00000   0.00000  2254:sub MST_Kruskal {
        0   0.00000   0.00000  2255:    my ($g, %attr) = @_;
        0   0.00000   0.00000  2256:
        0   0.00000   0.00000  2257:    $g->expect_undirected;
        0   0.00000   0.00000  2258:
        0   0.00000   0.00000  2259:    my $MST = Graph::Undirected->new;
        0   0.00000   0.00000  2260:
        0   0.00000   0.00000  2261:    my $UF  = Graph::UnionFind->new;
        0   0.00000   0.00000  2262:    for my $v ($g->vertices05) { $UF->add($v)
        0   0.00000   0.00000  2263:
        0   0.00000   0.00000  2264:    for my $e ($g->_MST_edges(\%attr)) {
        0   0.00000   0.00000  2265: my ($u, $v) = @$e; # TODO: hyperedges
        0   0.00000   0.00000  2266: my $t0 = $UF->find( $u );
        0   0.00000   0.00000  2267: my $t1 = $UF->find( $v );
        0   0.00000   0.00000  2268: unless ($t0 eq $t1) {
        0   0.00000   0.00000  2269:     $UF->union($u, $v);
        0   0.00000   0.00000  2270:     $MST->add_edge($u, $v);
        0   0.00000   0.00000  2271: }
        0   0.00000   0.00000  2272:    }
        0   0.00000   0.00000  2273:
        0   0.00000   0.00000  2274:    return $MST;
        0   0.00000   0.00000  2275:}
        0   0.00000   0.00000  2276:
        0   0.00000   0.00000  2277:sub _MST_add {
        0   0.00000   0.00000  2278:    my ($g, $h, $HF, $r, $attr, $unseen) =
        0   0.00000   0.00000  2279:    for my $s ( grep { exists $unseen->{ $_ }
        0   0.00000   0.00000  2280: $HF->add( Graph::MSTHeapElem->new( $r, $s,
        0   0.00000   0.00000  2281:    }
        0   0.00000   0.00000  2282:}
        0   0.00000   0.00000  2283:
        0   0.00000   0.00000  2284:sub _next_alphabetic { shift; (sort
        0   0.00000   0.00000  2285:sub _next_numeric    { shift; (sort { $a <=>
      108   0.00000   0.00000  2286:sub _next_random     { shift; (values %{
        0   0.00000   0.00000  2287:
        0   0.00000   0.00000  2288:sub _root_opt {
       58   0.00000   0.00000  2289:    my $g = shift;
       58   0.00000   0.00000  2290:    my %opt = @_ == 1 ? ( first_root => $_[0]
       58   0.00000   0.00000  2291:    my %unseen;
       58   0.00006   0.00000  2292:    my @unseen = $g->vertices05;
       58   0.00047   0.00000  2293:    @unseen{ @unseen } = @unseen;
       58   0.00056   0.00000  2294:    @unseen = _shuffle @unseen;
       58   0.00000   0.00000  2295:    my $r;
       58   0.00000   0.00000  2296:    if (exists $opt{ start }) {
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 84
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2297: $opt{ first_root } = $opt{ start };
        0   0.00000   0.00000  2298: $opt{ next_root  } = undef;
        0   0.00000   0.00000  2299:    }
       58   0.00000   0.00000  2300:    if (exists $opt{ get_next_root }) {
        0   0.00000   0.00000  2301: $opt{ next_root  } = $opt{ get_next_root };
        0   0.00000   0.00000  2302:    }
       58   0.00000   0.00000  2303:    if (exists $opt{ first_root }) {
        0   0.00000   0.00000  2304: if (ref $opt{ first_root } eq 'CODE') {
        0   0.00000   0.00000  2305:     $r = $opt{ first_root }->( $g, \%unseen
        0   0.00000   0.00000  2306: } else {
       54   0.00000   0.00000  2307:     $r = $opt{ first_root };
        0   0.00000   0.00000  2308: }
        0   0.00000   0.00000  2309:    } else {
        4   0.00000   0.00000  2310: $r = shift @unseen;
        0   0.00000   0.00000  2311:    }
        0   0.00000   0.00000  2312:    my $next =
        0   0.00000   0.00000  2313: exists $opt{ next_root } ?
        0   0.00000   0.00000  2314:     $opt{ next_root } :
        0   0.00000   0.00000  2315:  $opt{ next_alphabetic } ?
        0   0.00000   0.00000  2316:      \&_next_alphabetic :
       58   0.00000   0.00000  2317:   $opt{ next_numeric } ? \&_next_numeric :
        0   0.00000   0.00000  2318:       \&_next_random;
       58   0.00000   0.00000  2319:    my $code = ref $next eq 'CODE';
       58   0.00000   0.00000  2320:    my $attr = exists $opt{ attribute } ?
       58   0.00000   0.00000  2321:    return ( \%opt, \%unseen, \@unseen, $r,
        0   0.00000   0.00000  2322:}
        0   0.00000   0.00000  2323:
        0   0.00000   0.00000  2324:sub _heap_walk {
       54   0.00000   0.00000  2325:    my ($g, $h, $add, $etc) = splice @_, 0,
        0   0.00000   0.00000  2326:
       54   0.00000   0.00000  2327:    my ($opt, $unseenh, $unseena, $r, $next,
       54   0.00000   0.00000  2328:    my $HF = Heap071::Fibonacci->new;
        0   0.00000   0.00000  2329:
       54   0.00001   0.00000  2330:    while (defined $r) {
        0   0.00000   0.00000  2331: # print "r = $r\n";
       54   0.00000   0.00000  2332: $add->($g, $h, $HF, $r, $attr, $unseenh,
       54   0.00000   0.00000  2333: delete $unseenh->{ $r };
       54   0.00000   0.00000  2334: while (defined $HF->top) {
      828   0.00001   0.02000  2335:     my $t = $HF->extract_top;
        0   0.00000   0.00000  2336:     # use Data::Dumper; print "t = ",
      828   0.00000   0.00000  2337:     if (defined $t) {
      828   0.00001   0.03000  2338:  my ($u, $v, $w) = $t->val;
        0   0.00000   0.00000  2339:  # print "extracted top: $u $v $w\n";
      828   0.00000   0.00000  2340:  if (exists $unseenh->{ $v }) {
      828   0.00001   0.03000  2341:      $h->set_edge_attribute($u, $v, $attr,
      828   0.00054   0.00000  2342:      delete $unseenh->{ $v };
      828   0.00074   0.01000  2343:      $add->($g, $h, $HF, $v, $attr,
        0   0.00000   0.00000  2344:  }
        0   0.00000   0.00000  2345:     }
        0   0.00000   0.00000  2346: }
       54   0.00000   0.00000  2347: return $h unless defined $next;
       54   0.00000   0.00000  2348: $r = $code ? $next->( $g, $unseenh ) : shift
        0   0.00000   0.00000  2349:    }
        0   0.00000   0.00000  2350:
       54   0.00000   0.00000  2351:    return $h;
        0   0.00000   0.00000  2352:}
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 85
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2353:
        0   0.00000   0.00000  2354:sub MST_Prim {
        0   0.00000   0.00000  2355:    my $g = shift;
        0   0.00000   0.00000  2356:    $g->expect_undirected;
        0   0.00000   0.00000  2357:    $g->_heap_walk(Graph::Undirected->new(),
        0   0.00000   0.00000  2358:}
        0   0.00000   0.00000  2359:
        0   0.00000   0.00000  2360:*MST_Dijkstra = \&MST_Prim;
        0   0.00000   0.00000  2361:
        0   0.00000   0.00000  2362:*minimum_spanning_tree = \&MST_Prim;
        0   0.00000   0.00000  2363:
        0   0.00000   0.00000  2364:###
        0   0.00000   0.00000  2365:# Cycle detection.
        0   0.00000   0.00000  2366:#
        0   0.00000   0.00000  2367:
        0   0.00000   0.00000  2368:*is_cyclic = \&has_a_cycle;
        0   0.00000   0.00000  2369:
        0   0.00000   0.00000  2370:sub is_acyclic {
        0   0.00000   0.00000  2371:    my $g = shift;
        0   0.00000   0.00000  2372:    return !$g->is_cyclic;
        0   0.00000   0.00000  2373:}
        0   0.00000   0.00000  2374:
        0   0.00000   0.00000  2375:sub is_dag {
        0   0.00000   0.00000  2376:    my $g = shift;
        0   0.00000   0.00000  2377:    return $g->is_directed && $g->is_acyclic
        0   0.00000   0.00000  2378:}
        0   0.00000   0.00000  2379:
        0   0.00000   0.00000  2380:*is_directed_acyclic_graph = \&is_dag;
        0   0.00000   0.00000  2381:
        0   0.00000   0.00000  2382:###
        0   0.00000   0.00000  2383:# Backward compat.
        0   0.00000   0.00000  2384:#
        0   0.00000   0.00000  2385:
        0   0.00000   0.00000  2386:sub average_degree {
        0   0.00000   0.00000  2387:    my $g = shift;
        0   0.00000   0.00000  2388:    my $V = $g->vertices05;
        0   0.00000   0.00000  2389:
        0   0.00000   0.00000  2390:    return $V ? $g->degree / $V : 0;
        0   0.00000   0.00000  2391:}
        0   0.00000   0.00000  2392:
        0   0.00000   0.00000  2393:sub density_limits {
        0   0.00000   0.00000  2394:    my $g = shift;
        0   0.00000   0.00000  2395:
        0   0.00000   0.00000  2396:    my $V = $g->vertices05;
        0   0.00000   0.00000  2397:    my $M = $V * ($V - 1);
        0   0.00000   0.00000  2398:
        0   0.00000   0.00000  2399:    $M /= 2 if $g->is_undirected;
        0   0.00000   0.00000  2400:
        0   0.00000   0.00000  2401:    return ( 0.25 * $M, 0.75 * $M, $M );
        0   0.00000   0.00000  2402:}
        0   0.00000   0.00000  2403:
        0   0.00000   0.00000  2404:sub density {
        0   0.00000   0.00000  2405:    my $g = shift;
        0   0.00000   0.00000  2406:    my ($sparse, $dense, $complete) = $g-
        0   0.00000   0.00000  2407:
        0   0.00000   0.00000  2408:    return $complete ? $g->edges / $complete
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 86
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2409:}
        0   0.00000   0.00000  2410:
        0   0.00000   0.00000  2411:###
        0   0.00000   0.00000  2412:# Attribute backward compat
        0   0.00000   0.00000  2413:#
        0   0.00000   0.00000  2414:
        0   0.00000   0.00000  2415:sub _attr02_012 {
        0   0.00000   0.00000  2416:    my ($g, $op, $ga, $va, $ea) = splice @_,
        0   0.00000   0.00000  2417:    if ($g->is_compat02) {
        0   0.00000   0.00000  2418: if    (@_ == 0) { return $ga->( $g ) }
        0   0.00000   0.00000  2419: elsif (@_ == 1) { return $va->( $g, @_ ) }
        0   0.00000   0.00000  2420: elsif (@_ == 2) { return $ea->( $g, @_ ) }
        0   0.00000   0.00000  2421: else {
        0   0.00000   0.00000  2422:     die sprintf "$op: wrong number of
        0   0.00000   0.00000  2423: }
        0   0.00000   0.00000  2424:    } else {
        0   0.00000   0.00000  2425: die "$op: not a compat02 graph"
        0   0.00000   0.00000  2426:    }
        0   0.00000   0.00000  2427:}
        0   0.00000   0.00000  2428:
        0   0.00000   0.00000  2429:sub _attr02_123 {
        0   0.00000   0.00000  2430:    my ($g, $op, $ga, $va, $ea) = splice @_,
        0   0.00000   0.00000  2431:    if ($g->is_compat02) {
        0   0.00000   0.00000  2432: if    (@_ == 1) { return $ga->( $g, @_ ) }
        0   0.00000   0.00000  2433: elsif (@_ == 2) { return $va->( $g, @_[1, 0]
        0   0.00000   0.00000  2434: elsif (@_ == 3) { return $ea->( $g, @_[1, 2,
        0   0.00000   0.00000  2435: else {
        0   0.00000   0.00000  2436:     die sprintf "$op: wrong number of
        0   0.00000   0.00000  2437: }
        0   0.00000   0.00000  2438:    } else {
        0   0.00000   0.00000  2439: die "$op: not a compat02 graph"
        0   0.00000   0.00000  2440:    }
        0   0.00000   0.00000  2441:}
        0   0.00000   0.00000  2442:
        0   0.00000   0.00000  2443:sub _attr02_234 {
        0   0.00000   0.00000  2444:    my ($g, $op, $ga, $va, $ea) = splice @_,
        0   0.00000   0.00000  2445:    if ($g->is_compat02) {
        0   0.00000   0.00000  2446: if    (@_ == 2) { return $ga->( $g, @_ ) }
        0   0.00000   0.00000  2447: elsif (@_ == 3) { return $va->( $g, @_[1, 0,
        0   0.00000   0.00000  2448: elsif (@_ == 4) { return $ea->( $g, @_[1, 2,
        0   0.00000   0.00000  2449: else {
        0   0.00000   0.00000  2450:     die sprintf "$op: wrong number of
        0   0.00000   0.00000  2451: }
        0   0.00000   0.00000  2452:    } else {
        0   0.00000   0.00000  2453: die "$op: not a compat02 graph";
        0   0.00000   0.00000  2454:    }
        0   0.00000   0.00000  2455:}
        0   0.00000   0.00000  2456:
        0   0.00000   0.00000  2457:sub set_attribute {
        0   0.00000   0.00000  2458:    my $g = shift;
        0   0.00000   0.00000  2459:    $g->_attr02_234('set_attribute',
        0   0.00000   0.00000  2460:      \&Graph::set_graph_attribute,
        0   0.00000   0.00000  2461:      \&Graph::set_vertex_attribute,
        0   0.00000   0.00000  2462:      \&Graph::set_edge_attribute,
        0   0.00000   0.00000  2463:      @_);
        0   0.00000   0.00000  2464:
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 87
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2465:}
        0   0.00000   0.00000  2466:
        0   0.00000   0.00000  2467:sub set_attributes {
        0   0.00000   0.00000  2468:    my $g = shift;
        0   0.00000   0.00000  2469:    my $a = pop;
        0   0.00000   0.00000  2470:    $g->_attr02_123('set_attributes',
        0   0.00000   0.00000  2471:      \&Graph::set_graph_attributes,
        0   0.00000   0.00000  2472:      \&Graph::set_vertex_attributes,
        0   0.00000   0.00000  2473:      \&Graph::set_edge_attributes,
        0   0.00000   0.00000  2474:      $a, @_);
        0   0.00000   0.00000  2475:
        0   0.00000   0.00000  2476:}
        0   0.00000   0.00000  2477:
        0   0.00000   0.00000  2478:sub get_attribute {
        0   0.00000   0.00000  2479:    my $g = shift;
        0   0.00000   0.00000  2480:    $g->_attr02_123('get_attribute',
        0   0.00000   0.00000  2481:      \&Graph::get_graph_attribute,
        0   0.00000   0.00000  2482:      \&Graph::get_vertex_attribute,
        0   0.00000   0.00000  2483:      \&Graph::get_edge_attribute,
        0   0.00000   0.00000  2484:      @_);
        0   0.00000   0.00000  2485:
        0   0.00000   0.00000  2486:}
        0   0.00000   0.00000  2487:
        0   0.00000   0.00000  2488:sub get_attributes {
        0   0.00000   0.00000  2489:    my $g = shift;
        0   0.00000   0.00000  2490:    $g->_attr02_012('get_attributes',
        0   0.00000   0.00000  2491:      \&Graph::get_graph_attributes,
        0   0.00000   0.00000  2492:      \&Graph::get_vertex_attributes,
        0   0.00000   0.00000  2493:      \&Graph::get_edge_attributes,
        0   0.00000   0.00000  2494:      @_);
        0   0.00000   0.00000  2495:
        0   0.00000   0.00000  2496:}
        0   0.00000   0.00000  2497:
        0   0.00000   0.00000  2498:sub has_attribute {
        0   0.00000   0.00000  2499:    my $g = shift;
        0   0.00000   0.00000  2500:    return 0 unless @_;
        0   0.00000   0.00000  2501:    $g->_attr02_123('has_attribute',
        0   0.00000   0.00000  2502:      \&Graph::has_graph_attribute,
        0   0.00000   0.00000  2503:      \&Graph::has_vertex_attribute,
        0   0.00000   0.00000  2504:      \&Graph::get_edge_attribute,
        0   0.00000   0.00000  2505:      @_);
        0   0.00000   0.00000  2506:
        0   0.00000   0.00000  2507:}
        0   0.00000   0.00000  2508:
        0   0.00000   0.00000  2509:sub has_attributes {
        0   0.00000   0.00000  2510:    my $g = shift;
        0   0.00000   0.00000  2511:    $g->_attr02_012('has_attributes',
        0   0.00000   0.00000  2512:      \&Graph::has_graph_attributes,
        0   0.00000   0.00000  2513:      \&Graph::has_vertex_attributes,
        0   0.00000   0.00000  2514:      \&Graph::has_edge_attributes,
        0   0.00000   0.00000  2515:      @_);
        0   0.00000   0.00000  2516:
        0   0.00000   0.00000  2517:}
        0   0.00000   0.00000  2518:
        0   0.00000   0.00000  2519:sub delete_attribute {
        0   0.00000   0.00000  2520:    my $g = shift;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 88
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2521:    $g->_attr02_123('delete_attribute',
        0   0.00000   0.00000  2522:      \&Graph::delete_graph_attribute,
        0   0.00000   0.00000  2523:      \&Graph::delete_vertex_attribute,
        0   0.00000   0.00000  2524:      \&Graph::delete_edge_attribute,
        0   0.00000   0.00000  2525:      @_);
        0   0.00000   0.00000  2526:
        0   0.00000   0.00000  2527:}
        0   0.00000   0.00000  2528:
        0   0.00000   0.00000  2529:sub delete_attributes {
        0   0.00000   0.00000  2530:    my $g = shift;
        0   0.00000   0.00000  2531:    $g->_attr02_012('delete_attributes',
        0   0.00000   0.00000  2532:      \&Graph::delete_graph_attributes,
        0   0.00000   0.00000  2533:      \&Graph::delete_vertex_attributes,
        0   0.00000   0.00000  2534:      \&Graph::delete_edge_attributes,
        0   0.00000   0.00000  2535:      @_);
        0   0.00000   0.00000  2536:
        0   0.00000   0.00000  2537:}
        0   0.00000   0.00000  2538:
        0   0.00000   0.00000  2539:###
        0   0.00000   0.00000  2540:# Simple DFS uses.
        0   0.00000   0.00000  2541:#
        0   0.00000   0.00000  2542:
        0   0.00000   0.00000  2543:sub topological_sort {
        0   0.00000   0.00000  2544:    my $g = shift;
        0   0.00000   0.00000  2545:    my %opt = _get_options( \@_ );
        0   0.00000   0.00000  2546:    my $eic = $opt{ empty_if_cyclic };
        0   0.00000   0.00000  2547:    my $hac;
        0   0.00000   0.00000  2548:    if ($eic) {
        0   0.00000   0.00000  2549: $hac = $g->has_a_cycle;
        0   0.00000   0.00000  2550:    } else {
        0   0.00000   0.00000  2551: $g->expect_dag;
        0   0.00000   0.00000  2552:    }
        0   0.00000   0.00000  2553:    delete $opt{ empty_if_cyclic };
        0   0.00000   0.00000  2554:    my $t = Graph::Traversal::DFS->new($g,
        0   0.00000   0.00000  2555:    my @s = $t->dfs;
        0   0.00000   0.00000  2556:    $hac ? () : reverse @s;
        0   0.00000   0.00000  2557:}
        0   0.00000   0.00000  2558:
        0   0.00000   0.00000  2559:*toposort = \&topological_sort;
        0   0.00000   0.00000  2560:
        0   0.00000   0.00000  2561:sub undirected_copy {
        0   0.00000   0.00000  2562:    my $g = shift;
        0   0.00000   0.00000  2563:
        0   0.00000   0.00000  2564:    $g->expect_directed;
        0   0.00000   0.00000  2565:
        0   0.00000   0.00000  2566:    my $c = Graph::Undirected->new;
        0   0.00000   0.00000  2567:    for my $v ($g->isolated_vertices) { #
        0   0.00000   0.00000  2568: $c->add_vertex($v);
        0   0.00000   0.00000  2569:    }
        0   0.00000   0.00000  2570:    for my $e ($g->edges05) {
        0   0.00000   0.00000  2571: $c->add_edge(@$e);
        0   0.00000   0.00000  2572:    }
        0   0.00000   0.00000  2573:    return $c;
        0   0.00000   0.00000  2574:}
        0   0.00000   0.00000  2575:
        0   0.00000   0.00000  2576:*undirected_copy_graph = \&undirected_copy;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 89
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2577:
        0   0.00000   0.00000  2578:sub directed_copy {
        0   0.00000   0.00000  2579:    my $g = shift;
        0   0.00000   0.00000  2580:    $g->expect_undirected;
        0   0.00000   0.00000  2581:    my $c = Graph::Directed->new;
        0   0.00000   0.00000  2582:    for my $v ($g->isolated_vertices) { #
        0   0.00000   0.00000  2583: $c->add_vertex($v);
        0   0.00000   0.00000  2584:    }
        0   0.00000   0.00000  2585:    for my $e ($g->edges05) {
        0   0.00000   0.00000  2586: my @e = @$e;
        0   0.00000   0.00000  2587: $c->add_edge(@e);
        0   0.00000   0.00000  2588: $c->add_edge(reverse @e);
        0   0.00000   0.00000  2589:    }
        0   0.00000   0.00000  2590:    return $c;
        0   0.00000   0.00000  2591:}
        0   0.00000   0.00000  2592:
        0   0.00000   0.00000  2593:*directed_copy_graph = \&directed_copy;
        0   0.00000   0.00000  2594:
        0   0.00000   0.00000  2595:###
        0   0.00000   0.00000  2596:# Cache or not.
        0   0.00000   0.00000  2597:#
        0   0.00000   0.00000  2598:
        0   0.00000   0.00000  2599:my %_cache_type =
        0   0.00000   0.00000  2600:    (
        0   0.00000   0.00000  2601:     'connectivity'        => '_ccc',
        0   0.00000   0.00000  2602:     'strong_connectivity' => '_scc',
        0   0.00000   0.00000  2603:     'biconnectivity'      => '_bcc',
        0   0.00000   0.00000  2604:     'SPT_Dijkstra'        => '_spt_di',
        0   0.00000   0.00000  2605:     'SPT_Bellman_Ford'    => '_spt_bf',
        0   0.00000   0.00000  2606:    );
        0   0.00000   0.00000  2607:
        0   0.00000   0.00000  2608:sub _check_cache {
        8   0.00000   0.00000  2609:    my ($g, $type, $code) = splice @_, 0, 3;
        8   0.00000   0.00000  2610:    my $c = $_cache_type{$type};
        8   0.00000   0.00000  2611:    if (defined $c) {
        8   0.00000   0.00000  2612: my $a = $g->get_graph_attribute($c);
        8   0.00000   0.00000  2613: unless (defined $a && $a->[ 0 ] == $g->[ _G
        4   0.00000   0.00000  2614:     $a->[ 0 ] = $g->[ _G ];
        4   0.00000   0.00000  2615:     $a->[ 1 ] = $code->( $g, @_ );
        4   0.00000   0.00000  2616:     $g->set_graph_attribute($c, $a);
        0   0.00000   0.00000  2617: }
        8   0.00000   0.00000  2618: return $a->[ 1 ];
        0   0.00000   0.00000  2619:    } else {
        0   0.00000   0.00000  2620: Carp::croak("Graph: unknown cache type
        0   0.00000   0.00000  2621:    }
        0   0.00000   0.00000  2622:}
        0   0.00000   0.00000  2623:
        0   0.00000   0.00000  2624:sub _clear_cache {
        0   0.00000   0.00000  2625:    my ($g, $type) = @_;
        0   0.00000   0.00000  2626:    my $c = $_cache_type{$type};
        0   0.00000   0.00000  2627:    if (defined $c) {
        0   0.00000   0.00000  2628: $g->delete_graph_attribute($c);
        0   0.00000   0.00000  2629:    } else {
        0   0.00000   0.00000  2630: Carp::croak("Graph: unknown cache type
        0   0.00000   0.00000  2631:    }
        0   0.00000   0.00000  2632:}
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 90
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2633:
        0   0.00000   0.00000  2634:sub connectivity_clear_cache {
        0   0.00000   0.00000  2635:    my $g = shift;
        0   0.00000   0.00000  2636:    _clear_cache($g, 'connectivity');
        0   0.00000   0.00000  2637:}
        0   0.00000   0.00000  2638:
        0   0.00000   0.00000  2639:sub strong_connectivity_clear_cache {
        0   0.00000   0.00000  2640:    my $g = shift;
        0   0.00000   0.00000  2641:    _clear_cache($g, 'strong_connectivity');
        0   0.00000   0.00000  2642:}
        0   0.00000   0.00000  2643:
        0   0.00000   0.00000  2644:sub biconnectivity_clear_cache {
        0   0.00000   0.00000  2645:    my $g = shift;
        0   0.00000   0.00000  2646:    _clear_cache($g, 'biconnectivity');
        0   0.00000   0.00000  2647:}
        0   0.00000   0.00000  2648:
        0   0.00000   0.00000  2649:sub SPT_Dijkstra_clear_cache {
        0   0.00000   0.00000  2650:    my $g = shift;
        0   0.00000   0.00000  2651:    _clear_cache($g, 'SPT_Dijkstra');
        0   0.00000   0.00000  2652:    $g-
        0   0.00000   0.00000  2653:}
        0   0.00000   0.00000  2654:
        0   0.00000   0.00000  2655:sub SPT_Bellman_Ford_clear_cache {
        0   0.00000   0.00000  2656:    my $g = shift;
        0   0.00000   0.00000  2657:    _clear_cache($g, 'SPT_Bellman_Ford');
        0   0.00000   0.00000  2658:}
        0   0.00000   0.00000  2659:
        0   0.00000   0.00000  2660:###
        0   0.00000   0.00000  2661:# Connected components.
        0   0.00000   0.00000  2662:#
        0   0.00000   0.00000  2663:
        0   0.00000   0.00000  2664:sub _connected_components_compute {
        0   0.00000   0.00000  2665:    my $g = shift;
        0   0.00000   0.00000  2666:    my %cce;
        0   0.00000   0.00000  2667:    my %cci;
        0   0.00000   0.00000  2668:    my $cc = 0;
        0   0.00000   0.00000  2669:    if ($g->has_union_find) {
        0   0.00000   0.00000  2670: my $UF = $g->_get_union_find();
        0   0.00000   0.00000  2671: my $V  = $g->[ _V ];
        0   0.00000   0.00000  2672: my %icce; # Isolated vertices.
        0   0.00000   0.00000  2673: my %icci;
        0   0.00000   0.00000  2674: my $icc = 0;
        0   0.00000   0.00000  2675: for my $v ( $g->unique_vertices ) {
        0   0.00000   0.00000  2676:     $cc = $UF->find( $V->_get_path_id( $v )
        0   0.00000   0.00000  2677:     if (defined $cc) {
        0   0.00000   0.00000  2678:  $cce{ $v } = $cc;
        0   0.00000   0.00000  2679:  push @{ $cci{ $cc } }, $v;
        0   0.00000   0.00000  2680:     } else {
        0   0.00000   0.00000  2681:  $icce{ $v } = $icc;
        0   0.00000   0.00000  2682:  push @{ $icci{ $icc } }, $v;
        0   0.00000   0.00000  2683:  $icc++;
        0   0.00000   0.00000  2684:     }
        0   0.00000   0.00000  2685: }
        0   0.00000   0.00000  2686: if ($icc) {
        0   0.00000   0.00000  2687:     @cce{ keys %icce } = values %icce;
        0   0.00000   0.00000  2688:     @cci{ keys %icci } = values %icci;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 91
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2689: }
        0   0.00000   0.00000  2690:    } else {
        0   0.00000   0.00000  2691: my @u = $g->unique_vertices;
        0   0.00000   0.00000  2692: my %r; @r{ @u } = @u;
        0   0.00000   0.00000  2693: my $froot = sub {
        0   0.00000   0.00000  2694:     (each %r)[1];
        0   0.00000   0.00000  2695: };
        0   0.00000   0.00000  2696: my $nroot = sub {
        0   0.00000   0.00000  2697:     $cc++ if keys %r;
        0   0.00000   0.00000  2698:     (each %r)[1];
        0   0.00000   0.00000  2699: };
        0   0.00000   0.00000  2700: my $t = Graph::Traversal::DFS->new($g,
        0   0.00000   0.00000  2701:        first_root => $froot,
        0   0.00000   0.00000  2702:        next_root  => $nroot,
        0   0.00000   0.00000  2703:        pre => sub {
        0   0.00000   0.00000  2704:            my ($v, $t) = @_;
        0   0.00000   0.00000  2705:            $cce{ $v } = $cc;
        0   0.00000   0.00000  2706:            push @{ $cci{ $cc } }, $v;
        0   0.00000   0.00000  2707:            delete $r{ $v };
        0   0.00000   0.00000  2708:        },
        0   0.00000   0.00000  2709:        @_);
        0   0.00000   0.00000  2710: $t->dfs;
        0   0.00000   0.00000  2711:    }
        0   0.00000   0.00000  2712:    return [ \%cce, \%cci ];
        0   0.00000   0.00000  2713:}
        0   0.00000   0.00000  2714:
        0   0.00000   0.00000  2715:sub _connected_components {
        0   0.00000   0.00000  2716:    my $g = shift;
        0   0.00000   0.00000  2717:    my $ccc = _check_cache($g,
        0   0.00000   0.00000  2718:      \&_connected_components_compute, @_);
        0   0.00000   0.00000  2719:    return @{ $ccc };
        0   0.00000   0.00000  2720:}
        0   0.00000   0.00000  2721:
        0   0.00000   0.00000  2722:sub connected_component_by_vertex {
        0   0.00000   0.00000  2723:    my ($g, $v) = @_;
        0   0.00000   0.00000  2724:    $g->expect_undirected;
        0   0.00000   0.00000  2725:    my ($CCE, $CCI) = $g-
        0   0.00000   0.00000  2726:    return $CCE->{ $v };
        0   0.00000   0.00000  2727:}
        0   0.00000   0.00000  2728:
        0   0.00000   0.00000  2729:sub connected_component_by_index {
        0   0.00000   0.00000  2730:    my ($g, $i) = @_;
        0   0.00000   0.00000  2731:    $g->expect_undirected;
        0   0.00000   0.00000  2732:    my ($CCE, $CCI) = $g-
        0   0.00000   0.00000  2733:    return defined $CCI->{ $i } ? @{ $CCI->{
        0   0.00000   0.00000  2734:}
        0   0.00000   0.00000  2735:
        0   0.00000   0.00000  2736:sub connected_components {
        0   0.00000   0.00000  2737:    my $g = shift;
        0   0.00000   0.00000  2738:    $g->expect_undirected;
        0   0.00000   0.00000  2739:    my ($CCE, $CCI) = $g-
        0   0.00000   0.00000  2740:    return values %{ $CCI };
        0   0.00000   0.00000  2741:}
        0   0.00000   0.00000  2742:
        0   0.00000   0.00000  2743:sub same_connected_components {
        0   0.00000   0.00000  2744:    my $g = shift;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 92
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2745:    $g->expect_undirected;
        0   0.00000   0.00000  2746:    if ($g->has_union_find) {
        0   0.00000   0.00000  2747: my $UF = $g->_get_union_find();
        0   0.00000   0.00000  2748: my $V  = $g->[ _V ];
        0   0.00000   0.00000  2749: my $u = shift;
        0   0.00000   0.00000  2750: my $c = $UF->find( $V->_get_path_id ( $u )
        0   0.00000   0.00000  2751: my $d;
        0   0.00000   0.00000  2752: for my $v ( @_) {
        0   0.00000   0.00000  2753:     return 0
        0   0.00000   0.00000  2754:  unless defined($d = $UF->find( $V-
        0   0.00000   0.00000  2755:         $d eq $c;
        0   0.00000   0.00000  2756: }
        0   0.00000   0.00000  2757: return 1;
        0   0.00000   0.00000  2758:    } else {
        0   0.00000   0.00000  2759: my ($CCE, $CCI) = $g-
        0   0.00000   0.00000  2760: my $u = shift;
        0   0.00000   0.00000  2761: my $c = $CCE->{ $u };
        0   0.00000   0.00000  2762: for my $v ( @_) {
        0   0.00000   0.00000  2763:     return 0
        0   0.00000   0.00000  2764:  unless defined $CCE->{ $v } &&
        0   0.00000   0.00000  2765:         $CCE->{ $v } eq $c;
        0   0.00000   0.00000  2766: }
        0   0.00000   0.00000  2767: return 1;
        0   0.00000   0.00000  2768:    }
        0   0.00000   0.00000  2769:}
        0   0.00000   0.00000  2770:
        0   0.00000   0.00000  2771:my $super_component = sub { join("+", sort
        0   0.00000   0.00000  2772:
        0   0.00000   0.00000  2773:sub connected_graph {
        0   0.00000   0.00000  2774:    my ($g, %opt) = @_;
        0   0.00000   0.00000  2775:    $g->expect_undirected;
        0   0.00000   0.00000  2776:    my $cg = Graph->new(undirected => 1);
        0   0.00000   0.00000  2777:    if ($g->has_union_find && $g->vertices ==
        0   0.00000   0.00000  2778: # TODO: super_component?
        0   0.00000   0.00000  2779: $cg->add_vertices($g->vertices);
        0   0.00000   0.00000  2780:    } else {
        0   0.00000   0.00000  2781: my $sc_cb =
        0   0.00000   0.00000  2782:     exists $opt{super_component} ?
        0   0.00000   0.00000  2783:  $opt{super_component} : $super_component;
        0   0.00000   0.00000  2784: for my $cc ( $g->connected_components() ) {
        0   0.00000   0.00000  2785:     my $sc = $sc_cb->(@$cc);
        0   0.00000   0.00000  2786:     $cg->add_vertex($sc);
        0   0.00000   0.00000  2787:     $cg->set_vertex_attribute($sc,
        0   0.00000   0.00000  2788: }
        0   0.00000   0.00000  2789:    }
        0   0.00000   0.00000  2790:    return $cg;
        0   0.00000   0.00000  2791:}
        0   0.00000   0.00000  2792:
        0   0.00000   0.00000  2793:sub is_connected {
        0   0.00000   0.00000  2794:    my $g = shift;
        0   0.00000   0.00000  2795:    $g->expect_undirected;
        0   0.00000   0.00000  2796:    my ($CCE, $CCI) = $g-
        0   0.00000   0.00000  2797:    return keys %{ $CCI } == 1;
        0   0.00000   0.00000  2798:}
        0   0.00000   0.00000  2799:
        0   0.00000   0.00000  2800:sub is_weakly_connected {
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 93
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2801:    my $g = shift;
        0   0.00000   0.00000  2802:    $g->expect_directed;
        0   0.00000   0.00000  2803:    $g->undirected_copy->is_connected(@_);
        0   0.00000   0.00000  2804:}
        0   0.00000   0.00000  2805:
        0   0.00000   0.00000  2806:*weakly_connected = \&is_weakly_connected;
        0   0.00000   0.00000  2807:
        0   0.00000   0.00000  2808:sub weakly_connected_components {
        0   0.00000   0.00000  2809:    my $g = shift;
        0   0.00000   0.00000  2810:    $g->expect_directed;
        0   0.00000   0.00000  2811:    $g->undirected_copy-
        0   0.00000   0.00000  2812:}
        0   0.00000   0.00000  2813:
        0   0.00000   0.00000  2814:sub weakly_connected_component_by_vertex {
        0   0.00000   0.00000  2815:    my $g = shift;
        0   0.00000   0.00000  2816:    $g->expect_directed;
        0   0.00000   0.00000  2817:    $g->undirected_copy-
        0   0.00000   0.00000  2818:}
        0   0.00000   0.00000  2819:
        0   0.00000   0.00000  2820:sub weakly_connected_component_by_index {
        0   0.00000   0.00000  2821:    my $g = shift;
        0   0.00000   0.00000  2822:    $g->expect_directed;
        0   0.00000   0.00000  2823:    $g->undirected_copy-
        0   0.00000   0.00000  2824:}
        0   0.00000   0.00000  2825:
        0   0.00000   0.00000  2826:sub same_weakly_connected_components {
        0   0.00000   0.00000  2827:    my $g = shift;
        0   0.00000   0.00000  2828:    $g->expect_directed;
        0   0.00000   0.00000  2829:    $g->undirected_copy-
        0   0.00000   0.00000  2830:}
        0   0.00000   0.00000  2831:
        0   0.00000   0.00000  2832:sub weakly_connected_graph {
        0   0.00000   0.00000  2833:    my $g = shift;
        0   0.00000   0.00000  2834:    $g->expect_directed;
        0   0.00000   0.00000  2835:    $g->undirected_copy->connected_graph(@_);
        0   0.00000   0.00000  2836:}
        0   0.00000   0.00000  2837:
        0   0.00000   0.00000  2838:sub _strongly_connected_components_compute {
        0   0.00000   0.00000  2839:    my $g = shift;
        0   0.00000   0.00000  2840:    my $t = Graph::Traversal::DFS->new($g);
        0   0.00000   0.00000  2841:    my @d = reverse $t->dfs;
        0   0.00000   0.00000  2842:    my @c;
        0   0.00000   0.00000  2843:    my $h = $g->transpose_graph;
        0   0.00000   0.00000  2844:    my $u =
        0   0.00000   0.00000  2845: Graph::Traversal::DFS->new($h,
        0   0.00000   0.00000  2846:       next_root => sub {
        0   0.00000   0.00000  2847:           my ($t, $u) = @_;
        0   0.00000   0.00000  2848:           my $root;
        0   0.00000   0.00000  2849:           while (defined($root = shift @d))
        0   0.00000   0.00000  2850:        last if exists $u->{ $root };
        0   0.00000   0.00000  2851:           }
        0   0.00000   0.00000  2852:           if (defined $root) {
        0   0.00000   0.00000  2853:        push @c, [];
        0   0.00000   0.00000  2854:        return $root;
        0   0.00000   0.00000  2855:           } else {
        0   0.00000   0.00000  2856:        return;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 94
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2857:           }
        0   0.00000   0.00000  2858:       },
        0   0.00000   0.00000  2859:       pre => sub {
        0   0.00000   0.00000  2860:           my ($v, $t) = @_;
        0   0.00000   0.00000  2861:           push @{ $c[-1] }, $v;
        0   0.00000   0.00000  2862:       },
        0   0.00000   0.00000  2863:       @_);
        0   0.00000   0.00000  2864:    $u->dfs;
        0   0.00000   0.00000  2865:    return \@c;
        0   0.00000   0.00000  2866:}
        0   0.00000   0.00000  2867:
        0   0.00000   0.00000  2868:sub _strongly_connected_components {
        0   0.00000   0.00000  2869:    my $g = shift;
        0   0.00000   0.00000  2870:    my $scc = _check_cache($g,
        0   0.00000   0.00000  2871:
        0   0.00000   0.00000  2872:    return defined $scc ? @$scc : ( );
        0   0.00000   0.00000  2873:}
        0   0.00000   0.00000  2874:
        0   0.00000   0.00000  2875:sub strongly_connected_components {
        0   0.00000   0.00000  2876:    my $g = shift;
        0   0.00000   0.00000  2877:    $g->expect_directed;
        0   0.00000   0.00000  2878:    $g->_strongly_connected_components(@_);
        0   0.00000   0.00000  2879:}
        0   0.00000   0.00000  2880:
        0   0.00000   0.00000  2881:sub strongly_connected_component_by_vertex {
        0   0.00000   0.00000  2882:    my $g = shift;
        0   0.00000   0.00000  2883:    my $v = shift;
        0   0.00000   0.00000  2884:    $g->expect_directed;
        0   0.00000   0.00000  2885:    my @scc = $g-
        0   0.00000   0.00000  2886:    for (my $i = 0; $i <= $#scc; $i++) {
        0   0.00000   0.00000  2887: for (my $j = 0; $j <= $#{ $scc[$i] }; $j++)
        0   0.00000   0.00000  2888:     return $i if $scc[$i]->[$j] eq $v;
        0   0.00000   0.00000  2889: }
        0   0.00000   0.00000  2890:    }
        0   0.00000   0.00000  2891:    return;
        0   0.00000   0.00000  2892:}
        0   0.00000   0.00000  2893:
        0   0.00000   0.00000  2894:sub strongly_connected_component_by_index {
        0   0.00000   0.00000  2895:    my $g = shift;
        0   0.00000   0.00000  2896:    my $i = shift;
        0   0.00000   0.00000  2897:    $g->expect_directed;
        0   0.00000   0.00000  2898:    my $c = ( $g-
        0   0.00000   0.00000  2899:    return defined $c ? @{ $c } : ();
        0   0.00000   0.00000  2900:}
        0   0.00000   0.00000  2901:
        0   0.00000   0.00000  2902:sub same_strongly_connected_components {
        0   0.00000   0.00000  2903:    my $g = shift;
        0   0.00000   0.00000  2904:    $g->expect_directed;
        0   0.00000   0.00000  2905:    my @scc = $g-
        0   0.00000   0.00000  2906:    my @i;
        0   0.00000   0.00000  2907:    while (@_) {
        0   0.00000   0.00000  2908: my $v = shift;
        0   0.00000   0.00000  2909: for (my $i = 0; $i <= $#scc; $i++) {
        0   0.00000   0.00000  2910:     for (my $j = 0; $j <= $#{ $scc[$i] };
        0   0.00000   0.00000  2911:  if ($scc[$i]->[$j] eq $v) {
        0   0.00000   0.00000  2912:      push @i, $i;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 95
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2913:      return 0 if @i > 1 && $i[-1] ne $i[0];
        0   0.00000   0.00000  2914:  }
        0   0.00000   0.00000  2915:     }
        0   0.00000   0.00000  2916: }
        0   0.00000   0.00000  2917:    }
        0   0.00000   0.00000  2918:    return 1;
        0   0.00000   0.00000  2919:}
        0   0.00000   0.00000  2920:
        0   0.00000   0.00000  2921:sub is_strongly_connected {
        0   0.00000   0.00000  2922:    my $g = shift;
        0   0.00000   0.00000  2923:    $g->expect_directed;
        0   0.00000   0.00000  2924:    my $t = Graph::Traversal::DFS->new($g);
        0   0.00000   0.00000  2925:    my @d = reverse $t->dfs;
        0   0.00000   0.00000  2926:    my @c;
        0   0.00000   0.00000  2927:    my $h = $g->transpose;
        0   0.00000   0.00000  2928:    my $u =
        0   0.00000   0.00000  2929: Graph::Traversal::DFS->new($h,
        0   0.00000   0.00000  2930:       next_root => sub {
        0   0.00000   0.00000  2931:           my ($t, $u) = @_;
        0   0.00000   0.00000  2932:           my $root;
        0   0.00000   0.00000  2933:           while (defined($root = shift @d))
        0   0.00000   0.00000  2934:        last if exists $u->{ $root };
        0   0.00000   0.00000  2935:           }
        0   0.00000   0.00000  2936:           if (defined $root) {
        0   0.00000   0.00000  2937:        unless (@{ $t->{ roots } }) {
        0   0.00000   0.00000  2938:            push @c, [];
        0   0.00000   0.00000  2939:            return $root;
        0   0.00000   0.00000  2940:        } else {
        0   0.00000   0.00000  2941:            $t->terminate;
        0   0.00000   0.00000  2942:            return;
        0   0.00000   0.00000  2943:        }
        0   0.00000   0.00000  2944:           } else {
        0   0.00000   0.00000  2945:        return;
        0   0.00000   0.00000  2946:           }
        0   0.00000   0.00000  2947:       },
        0   0.00000   0.00000  2948:       pre => sub {
        0   0.00000   0.00000  2949:           my ($v, $t) = @_;
        0   0.00000   0.00000  2950:           push @{ $c[-1] }, $v;
        0   0.00000   0.00000  2951:       },
        0   0.00000   0.00000  2952:       @_);
        0   0.00000   0.00000  2953:    $u->dfs;
        0   0.00000   0.00000  2954:    return @{ $u->{ roots } } == 1 && keys %{
        0   0.00000   0.00000  2955:}
        0   0.00000   0.00000  2956:
        0   0.00000   0.00000  2957:*strongly_connected =
        0   0.00000   0.00000  2958:
        0   0.00000   0.00000  2959:sub strongly_connected_graph {
        0   0.00000   0.00000  2960:    my $g = shift;
        0   0.00000   0.00000  2961:    my %attr = @_;
        0   0.00000   0.00000  2962:
        0   0.00000   0.00000  2963:    $g->expect_directed;
        0   0.00000   0.00000  2964:
        0   0.00000   0.00000  2965:    my $t = Graph::Traversal::DFS->new($g);
        0   0.00000   0.00000  2966:    my @d = reverse $t->dfs;
        0   0.00000   0.00000  2967:    my @c;
        0   0.00000   0.00000  2968:    my $h = $g->transpose;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 96
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2969:    my $u =
        0   0.00000   0.00000  2970: Graph::Traversal::DFS->new($h,
        0   0.00000   0.00000  2971:       next_root => sub {
        0   0.00000   0.00000  2972:           my ($t, $u) = @_;
        0   0.00000   0.00000  2973:           my $root;
        0   0.00000   0.00000  2974:           while (defined($root = shift @d))
        0   0.00000   0.00000  2975:        last if exists $u->{ $root };
        0   0.00000   0.00000  2976:           }
        0   0.00000   0.00000  2977:           if (defined $root) {
        0   0.00000   0.00000  2978:        push @c, [];
        0   0.00000   0.00000  2979:        return $root;
        0   0.00000   0.00000  2980:           } else {
        0   0.00000   0.00000  2981:        return;
        0   0.00000   0.00000  2982:           }
        0   0.00000   0.00000  2983:       },
        0   0.00000   0.00000  2984:       pre => sub {
        0   0.00000   0.00000  2985:           my ($v, $t) = @_;
        0   0.00000   0.00000  2986:           push @{ $c[-1] }, $v;
        0   0.00000   0.00000  2987:       }
        0   0.00000   0.00000  2988:       );
        0   0.00000   0.00000  2989:
        0   0.00000   0.00000  2990:    $u->dfs;
        0   0.00000   0.00000  2991:
        0   0.00000   0.00000  2992:    my $sc_cb;
        0   0.00000   0.00000  2993:    my $hv_cb;
        0   0.00000   0.00000  2994:
        0   0.00000   0.00000  2995:    _opt_get(\%attr, super_component =>
        0   0.00000   0.00000  2996:    _opt_get(\%attr, hypervertex => \$hv_cb);
        0   0.00000   0.00000  2997:    _opt_unknown(\%attr);
        0   0.00000   0.00000  2998:
        0   0.00000   0.00000  2999:    if (defined $hv_cb && !defined $sc_cb) {
        0   0.00000   0.00000  3000: $sc_cb = sub { $hv_cb->( [ @_ ] ) };
        0   0.00000   0.00000  3001:    }
        0   0.00000   0.00000  3002:    unless (defined $sc_cb) {
        0   0.00000   0.00000  3003: $sc_cb = $super_component;
        0   0.00000   0.00000  3004:    }
        0   0.00000   0.00000  3005:
        0   0.00000   0.00000  3006:    my $s = Graph->new;
        0   0.00000   0.00000  3007:
        0   0.00000   0.00000  3008:    my %c;
        0   0.00000   0.00000  3009:    my @s;
        0   0.00000   0.00000  3010:    for (my $i = 0; $i <  @c; $i++) {
        0   0.00000   0.00000  3011: my $c = $c[$i];
        0   0.00000   0.00000  3012: $s->add_vertex( $s[$i] = $sc_cb->(@$c) );
        0   0.00000   0.00000  3013: $s->set_vertex_attribute($s[$i],
        0   0.00000   0.00000  3014: for my $v (@$c) {
        0   0.00000   0.00000  3015:     $c{$v} = $i;
        0   0.00000   0.00000  3016: }
        0   0.00000   0.00000  3017:    }
        0   0.00000   0.00000  3018:
        0   0.00000   0.00000  3019:    my $n = @c;
        0   0.00000   0.00000  3020:    for my $v ($g->vertices) {
        0   0.00000   0.00000  3021: unless (exists $c{$v}) {
        0   0.00000   0.00000  3022:     $c{$v} = $n;
        0   0.00000   0.00000  3023:     $s[$n] = $v;
        0   0.00000   0.00000  3024:     $n++;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 97
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  3025: }
        0   0.00000   0.00000  3026:    }
        0   0.00000   0.00000  3027:
        0   0.00000   0.00000  3028:    for my $e ($g->edges05) {
        0   0.00000   0.00000  3029: my ($u, $v) = @$e; # @TODO: hyperedges
        0   0.00000   0.00000  3030: unless ($c{$u} == $c{$v}) {
        0   0.00000   0.00000  3031:     my ($p, $q) = ( $s[ $c{ $u } ], $s[ $c{
        0   0.00000   0.00000  3032:     $s->add_edge($p, $q) unless $s-
        0   0.00000   0.00000  3033: }
        0   0.00000   0.00000  3034:    }
        0   0.00000   0.00000  3035:
        0   0.00000   0.00000  3036:    if (my @i = $g->isolated_vertices) {
        0   0.00000   0.00000  3037: $s->add_vertices(map { $s[ $c{ $_ } ] } @i);
        0   0.00000   0.00000  3038:    }
        0   0.00000   0.00000  3039:
        0   0.00000   0.00000  3040:    return $s;
        0   0.00000   0.00000  3041:}
        0   0.00000   0.00000  3042:
        0   0.00000   0.00000  3043:###
        0   0.00000   0.00000  3044:# Biconnectivity.
        0   0.00000   0.00000  3045:#
        0   0.00000   0.00000  3046:
        0   0.00000   0.00000  3047:sub _make_bcc {
       12   0.00000   0.00000  3048:    my ($S, $v, $c) = @_;
       12   0.00000   0.00000  3049:    my %b;
       12   0.00000   0.00000  3050:    while (@$S) {
       50   0.00000   0.00000  3051: my $t = pop @$S;
       50   0.00000   0.00000  3052: $b{ $t } = $t;
       50   0.00000   0.00000  3053: last if $t eq $v;
        0   0.00000   0.00000  3054:    }
       12   0.00001   0.00000  3055:    return [ values %b, $c ];
        0   0.00000   0.00000  3056:}
        0   0.00000   0.00000  3057:
        0   0.00000   0.00000  3058:sub _biconnectivity_compute {
        4   0.00000   0.00000  3059:    my $g = shift;
        4   0.00000   0.00000  3060:    my ($opt, $unseenh, $unseena, $r, $next,
        0   0.00000   0.00000  3061: $g->_root_opt(@_);
        4   0.00000   0.00000  3062:    return () unless defined $r;
        4   0.00000   0.00000  3063:    my %P;
        4   0.00000   0.00000  3064:    my %I;
        4   0.00000   0.00000  3065:    for my $v ($g->vertices) {
       54   0.00000   0.00000  3066: $I{ $v } = 0;
        0   0.00000   0.00000  3067:    }
        4   0.00000   0.00000  3068:    $I{ $r } = 1;
        4   0.00000   0.00000  3069:    my %U;
        4   0.00000   0.00000  3070:    my %S; # Self-loops.
        4   0.00000   0.00000  3071:    for my $e ($g->edges) {
       62   0.00000   0.00000  3072: my ($u, $v) = @$e;
       62   0.00000   0.00000  3073: $U{ $u }{ $v } = 0;
       62   0.00000   0.00000  3074: $U{ $v }{ $u } = 0;
       62   0.00002   0.00000  3075: $S{ $u } = 1 if $u eq $v;
        0   0.00000   0.00000  3076:    }
        4   0.00000   0.00000  3077:    my $i = 1;
        4   0.00000   0.00000  3078:    my $v = $r;
        4   0.00000   0.00000  3079:    my %AP;
        4   0.00000   0.00000  3080:    my %L = ( $r => 1 );
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 98
       =================================================================
    count wall tm  cpu time line
        4   0.00000   0.00000  3081:    my @S = ( $r );
        4   0.00000   0.00000  3082:    my %A;
        4   0.00000   0.00000  3083:    my @V = $g->vertices;
        0   0.00000   0.00000  3084:
        0   0.00000   0.00000  3085:    # print "V : @V\n";
        0   0.00000   0.00000  3086:    # print "r : $r\n";
        0   0.00000   0.00000  3087:
        8   0.00001   0.00000  3088:    my %T; @T{ @V } = @V;
        0   0.00000   0.00000  3089:
        4   0.00000   0.00000  3090:    for my $w (@V) {
       54   0.00000   0.00000  3091: my @s = $g->successors( $w );
       54   0.00000   0.00000  3092: if (@s) {
       54   0.00000   0.00000  3093:     @s = grep { $_ eq $w ? ( delete $T{ $w
       54   0.00000   0.00000  3094:     @{ $A{ $w } }{ @s } = @s;
        0   0.00000   0.00000  3095: } elsif ($g->predecessors( $w ) == 0) {
        0   0.00000   0.00000  3096:     delete $T{ $w };
        0   0.00000   0.00000  3097:     if ($w eq $r) {
        0   0.00000   0.00000  3098:  delete $I { $r };
        0   0.00000   0.00000  3099:  $r = $v = each %T;
        0   0.00000   0.00000  3100:  if (defined $r) {
        0   0.00000   0.00000  3101:      %L = ( $r => 1 );
        0   0.00000   0.00000  3102:      @S = ( $r );
        0   0.00000   0.00000  3103:      $I{ $r } = 1;
        0   0.00000   0.00000  3104:      # print "r : $r\n";
        0   0.00000   0.00000  3105:  }
        0   0.00000   0.00000  3106:     }
        0   0.00000   0.00000  3107: }
        0   0.00000   0.00000  3108:    }
        0   0.00000   0.00000  3109:
        0   0.00000   0.00000  3110:    # use Data::Dumper;
        0   0.00000   0.00000  3111:    # print "T : ", Dumper(\%T);
        0   0.00000   0.00000  3112:    # print "A : ", Dumper(\%A);
        0   0.00000   0.00000  3113:
        4   0.00000   0.00000  3114:    my %V2BC;
        4   0.00000   0.00000  3115:    my @BR;
        4   0.00000   0.00000  3116:    my @BC;
        0   0.00000   0.00000  3117:
        4   0.00000   0.00000  3118:    my @C;
        4   0.00000   0.00000  3119:    my $Avok;
        0   0.00000   0.00000  3120:
        4   0.00000   0.00000  3121:    while (keys %T) {
        0   0.00000   0.00000  3122: # print "T = ", Dumper(\%T);
        4   0.00000   0.00000  3123: do {
       50   0.00000   0.00000  3124:     my $w;
       50   0.00000   0.00000  3125:     do {
      112   0.00000   0.00000  3126:  my @w = _shuffle values %{ $A{ $v } };
        0   0.00000   0.00000  3127:  # print "w = @w\n";
      324   0.00005   0.01000  3128:  $w = first { !$U{ $v }{ $_ } } @w;
      112   0.00001   0.01000  3129:  if (defined $w) {
        0   0.00000   0.00000  3130:      # print "w = $w\n";
       62   0.00000   0.00000  3131:      $U{ $v }{ $w }++;
       62   0.00000   0.00000  3132:      $U{ $w }{ $v }++;
       62   0.00000   0.00000  3133:      if ($I{ $w } == 0) {
       50   0.00000   0.00000  3134:   $P{ $w } = $v;
       50   0.00000   0.00000  3135:   $i++;
       50   0.00000   0.00000  3136:   $I{ $w } = $i;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 99
       =================================================================
    count wall tm  cpu time line
       50   0.00000   0.00000  3137:   $L{ $w } = $i;
       50   0.00000   0.00000  3138:   push @S, $w;
       50   0.00000   0.00000  3139:   $v = $w;
        0   0.00000   0.00000  3140:      } else {
       12   0.00000   0.00000  3141:   $L{ $v } = $I{ $w } if $I{ $w } < $L{ $v
        0   0.00000   0.00000  3142:      }
        0   0.00000   0.00000  3143:  }
        0   0.00000   0.00000  3144:     } while (defined $w);
        0   0.00000   0.00000  3145:     # print "U = ", Dumper(\%U);
        0   0.00000   0.00000  3146:     # print "P = ", Dumper(\%P);
        0   0.00000   0.00000  3147:     # print "L = ", Dumper(\%L);
       50   0.00000   0.00000  3148:     if (!defined $P{ $v }) {
        0   0.00000   0.00000  3149:  # Do nothing.
        0   0.00000   0.00000  3150:     } elsif ($P{ $v } ne $r) {
       44   0.00000   0.00000  3151:  if ($L{ $v } < $I{ $P{ $v } }) {
        0   0.00000   0.00000  3152:      $L{ $P{ $v } } = $L{ $v } if $L{ $v } <
        0   0.00000   0.00000  3153:  } else {
        6   0.00000   0.00000  3154:      $AP{ $P{ $v } } = $P{ $v };
        6   0.00000   0.00000  3155:      push @C, _make_bcc(\@S, $v, $P{ $v } );
        0   0.00000   0.00000  3156:  }
        0   0.00000   0.00000  3157:     } else {
        6   0.00000   0.00000  3158:  my $e;
        6   0.00000   0.00000  3159:  for my $w (_shuffle keys %{ $A{ $r } }) {
        0   0.00000   0.00000  3160:      # print "w = $w\n";
       12   0.00000   0.00000  3161:      unless ($U{ $r }{ $w }) {
        2   0.00000   0.00000  3162:   $e = $r;
        0   0.00000   0.00000  3163:   # print "e = $e\n";
        2   0.00000   0.00000  3164:   last;
        0   0.00000   0.00000  3165:      }
        0   0.00000   0.00000  3166:  }
        6   0.00000   0.00000  3167:  $AP{ $e } = $e if defined $e;
        6   0.00000   0.00000  3168:  push @C, _make_bcc(\@S, $v, $r);
        0   0.00000   0.00000  3169:     }
        0   0.00000   0.00000  3170:     # print "AP = ", Dumper(\%AP);
        0   0.00000   0.00000  3171:     # print "C  = ", Dumper(\@C);
        0   0.00000   0.00000  3172:     # print "L  = ", Dumper(\%L);
       50   0.00000   0.00000  3173:     $v = defined $P{ $v } ? $P{ $v } : $r;
        0   0.00000   0.00000  3174:     # print "v = $v\n";
       50   0.00000   0.00000  3175:     $Avok = 0;
       50   0.00000   0.00000  3176:     if (defined $v) {
       50   0.00000   0.00000  3177:  if (keys %{ $A{ $v } }) {
       50   0.00000   0.00000  3178:      if (!exists $P{ $v }) {
        6   0.00000   0.00000  3179:   for my $w (keys %{ $A{ $v } }) {
       13   0.00000   0.00000  3180:       $Avok++ if $U{ $v }{ $w };
        0   0.00000   0.00000  3181:   }
        0   0.00000   0.00000  3182:   # print "Avok/1 = $Avok\n";
        6   0.00000   0.00000  3183:   $Avok = 0 unless $Avok == keys %{ $A{ $v }
        0   0.00000   0.00000  3184:   # print "Avok/2 = $Avok\n";
        0   0.00000   0.00000  3185:      }
        0   0.00000   0.00000  3186:  } else {
        0   0.00000   0.00000  3187:      $Avok = 1;
        0   0.00000   0.00000  3188:      # print "Avok/3 = $Avok\n";
        0   0.00000   0.00000  3189:  }
        0   0.00000   0.00000  3190:     }
        0   0.00000   0.00000  3191: } until ($Avok);
        0   0.00000   0.00000  3192:
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 100
       =================================================================
    count wall tm  cpu time line
        4   0.00000   0.00000  3193: last if @C == 0 && !exists $S{$v};
        0   0.00000   0.00000  3194:
        4   0.00000   0.00000  3195: for (my $i = 0; $i < @C; $i++) {
       12   0.00000   0.00000  3196:     for my $v (@{ $C[ $i ]}) {
       62   0.00000   0.00000  3197:  $V2BC{ $v }{ $i }++;
       62   0.00000   0.00000  3198:  delete $T{ $v };
        0   0.00000   0.00000  3199:     }
        4   0.00000   0.00000  3200: }
        0   0.00000   0.00000  3201:
        4   0.00000   0.00000  3202: for (my $i = 0; $i < @C; $i++) {
        0   0.00000   0.00000  3203:     if (@{ $C[ $i ] } == 2) {
        0   0.00000   0.00000  3204:  push @BR, $C[ $i ];
        0   0.00000   0.00000  3205:     } else {
        4   0.00000   0.00000  3206:  push @BC, $C[ $i ];
        0   0.00000   0.00000  3207:     }
        4   0.00000   0.00000  3208: }
        0   0.00000   0.00000  3209:
        4   0.00000   0.00000  3210: if (keys %T) {
        0   0.00000   0.00000  3211:     $r = $v = each %T;
        0   0.00000   0.00000  3212: }
        0   0.00000   0.00000  3213:    }
        0   0.00000   0.00000  3214:
        4   0.00010   0.00000  3215:    return [ [values %AP], \@BC, \@BR, \%V2BC
        0   0.00000   0.00000  3216:}
        0   0.00000   0.00000  3217:
        0   0.00000   0.00000  3218:sub biconnectivity {
        8   0.00000   0.00000  3219:    my $g = shift;
        8   0.00000   0.00000  3220:    $g->expect_undirected;
        8   0.00000   0.00000  3221:    my $bcc = _check_cache($g,
        0   0.00000   0.00000  3222:      \&_biconnectivity_compute, @_);
        8   0.00000   0.00000  3223:    return defined $bcc ? @$bcc : ( );
        0   0.00000   0.00000  3224:}
        0   0.00000   0.00000  3225:
        0   0.00000   0.00000  3226:sub is_biconnected {
        0   0.00000   0.00000  3227:    my $g = shift;
        0   0.00000   0.00000  3228:    my ($ap, $bc) = ($g-
        0   0.00000   0.00000  3229:    return defined $ap ? @$ap == 0 && $g-
        0   0.00000   0.00000  3230:}
        0   0.00000   0.00000  3231:
        0   0.00000   0.00000  3232:sub is_edge_connected {
        0   0.00000   0.00000  3233:    my $g = shift;
        0   0.00000   0.00000  3234:    my ($br) = ($g->biconnectivity(@_))[2];
        0   0.00000   0.00000  3235:    return defined $br ? @$br == 0 && $g-
        0   0.00000   0.00000  3236:}
        0   0.00000   0.00000  3237:
        0   0.00000   0.00000  3238:sub is_edge_separable {
        0   0.00000   0.00000  3239:    my $g = shift;
        0   0.00000   0.00000  3240:    my $c = $g->is_edge_connected;
        0   0.00000   0.00000  3241:    defined $c ? !$c && $g->edges : undef;
        0   0.00000   0.00000  3242:}
        0   0.00000   0.00000  3243:
        0   0.00000   0.00000  3244:sub articulation_points {
        8   0.00000   0.00000  3245:    my $g = shift;
        8   0.00000   0.00000  3246:    my ($ap) = ($g->biconnectivity(@_))[0];
        8   0.00000   0.00000  3247:    return defined $ap ? @$ap : ();
        0   0.00000   0.00000  3248:}
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 101
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  3249:
        0   0.00000   0.00000  3250:*cut_vertices = \&articulation_points;
        0   0.00000   0.00000  3251:
        0   0.00000   0.00000  3252:sub biconnected_components {
        0   0.00000   0.00000  3253:    my $g = shift;
        0   0.00000   0.00000  3254:    my ($bc) = ($g->biconnectivity(@_))[1];
        0   0.00000   0.00000  3255:    return defined $bc ? @$bc : ();
        0   0.00000   0.00000  3256:}
        0   0.00000   0.00000  3257:
        0   0.00000   0.00000  3258:sub biconnected_component_by_index {
        0   0.00000   0.00000  3259:    my $g = shift;
        0   0.00000   0.00000  3260:    my $i = shift;
        0   0.00000   0.00000  3261:    my ($bc) = ($g->biconnectivity(@_))[1];
        0   0.00000   0.00000  3262:    return defined $bc ? $bc->[ $i ] : undef;
        0   0.00000   0.00000  3263:}
        0   0.00000   0.00000  3264:
        0   0.00000   0.00000  3265:sub biconnected_component_by_vertex {
        0   0.00000   0.00000  3266:    my $g = shift;
        0   0.00000   0.00000  3267:    my $v = shift;
        0   0.00000   0.00000  3268:    my ($v2bc) = ($g->biconnectivity(@_))[3];
        0   0.00000   0.00000  3269:    return defined $v2bc->{ $v } ? keys %{
        0   0.00000   0.00000  3270:}
        0   0.00000   0.00000  3271:
        0   0.00000   0.00000  3272:sub same_biconnected_components {
        0   0.00000   0.00000  3273:    my $g = shift;
        0   0.00000   0.00000  3274:    my $u = shift;
        0   0.00000   0.00000  3275:    my @u = $g-
        0   0.00000   0.00000  3276:    return 0 unless @u;
        0   0.00000   0.00000  3277:    my %ubc; @ubc{ @u } = ();
        0   0.00000   0.00000  3278:    while (@_) {
        0   0.00000   0.00000  3279: my $v = shift;
        0   0.00000   0.00000  3280: my @v = $g-
        0   0.00000   0.00000  3281: if (@v) {
        0   0.00000   0.00000  3282:     my %vbc; @vbc{ @v } = ();
        0   0.00000   0.00000  3283:     my $vi;
        0   0.00000   0.00000  3284:     for my $ui (keys %ubc) {
        0   0.00000   0.00000  3285:  if (exists $vbc{ $ui }) {
        0   0.00000   0.00000  3286:      $vi = $ui;
        0   0.00000   0.00000  3287:      last;
        0   0.00000   0.00000  3288:  }
        0   0.00000   0.00000  3289:     }
        0   0.00000   0.00000  3290:     return 0 unless defined $vi;
        0   0.00000   0.00000  3291: }
        0   0.00000   0.00000  3292:    }
        0   0.00000   0.00000  3293:    return 1;
        0   0.00000   0.00000  3294:}
        0   0.00000   0.00000  3295:
        0   0.00000   0.00000  3296:sub biconnected_graph {
        0   0.00000   0.00000  3297:    my ($g, %opt) = @_;
        0   0.00000   0.00000  3298:    my ($bc, $v2bc) = ($g->biconnectivity,
        0   0.00000   0.00000  3299:    my $bcg = Graph::Undirected->new;
        0   0.00000   0.00000  3300:    my $sc_cb =
        0   0.00000   0.00000  3301: exists $opt{super_component} ?
        0   0.00000   0.00000  3302:     $opt{super_component} :
        0   0.00000   0.00000  3303:    for my $c (@$bc) {
        0   0.00000   0.00000  3304: $bcg->add_vertex(my $s = $sc_cb->(@$c));
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 102
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  3305: $bcg->set_vertex_attribute($s,
        0   0.00000   0.00000  3306:    }
        0   0.00000   0.00000  3307:    my %k;
        0   0.00000   0.00000  3308:    for my $i (0..$#$bc) {
        0   0.00000   0.00000  3309: my @u = @{ $bc->[ $i ] };
        0   0.00000   0.00000  3310: my %i; @i{ @u } = ();
        0   0.00000   0.00000  3311: for my $j (0..$#$bc) {
        0   0.00000   0.00000  3312:     if ($i > $j) {
        0   0.00000   0.00000  3313:  my @v = @{ $bc->[ $j ] };
        0   0.00000   0.00000  3314:  my %j; @j{ @v } = ();
        0   0.00000   0.00000  3315:  for my $u (@u) {
        0   0.00000   0.00000  3316:      if (exists $j{ $u }) {
        0   0.00000   0.00000  3317:   unless ($k{ $i }{ $j }++) {
        0   0.00000   0.00000  3318:       $bcg->add_edge($sc_cb->(@{$bc->[$i]}),
        0   0.00000   0.00000  3319:        $sc_cb->(@{$bc->[$j]}));
        0   0.00000   0.00000  3320:   }
        0   0.00000   0.00000  3321:   last;
        0   0.00000   0.00000  3322:      }
        0   0.00000   0.00000  3323:  }
        0   0.00000   0.00000  3324:     }
        0   0.00000   0.00000  3325: }
        0   0.00000   0.00000  3326:    }
        0   0.00000   0.00000  3327:    return $bcg;
        0   0.00000   0.00000  3328:}
        0   0.00000   0.00000  3329:
        0   0.00000   0.00000  3330:sub bridges {
        0   0.00000   0.00000  3331:    my $g = shift;
        0   0.00000   0.00000  3332:    my ($br) = ($g->biconnectivity(@_))[2];
        0   0.00000   0.00000  3333:    return defined $br ? @$br : ();
        0   0.00000   0.00000  3334:}
        0   0.00000   0.00000  3335:
        0   0.00000   0.00000  3336:###
        0   0.00000   0.00000  3337:# SPT.
        0   0.00000   0.00000  3338:#
        0   0.00000   0.00000  3339:
        0   0.00000   0.00000  3340:sub _SPT_add {
      882   0.00001   0.00000  3341:    my ($g, $h, $HF, $r, $attr, $unseen,
      882   0.00004   0.00000  3342:    my $etc_r = $etc->{ $r } || 0;
      882   0.00001   0.01000  3343:    for my $s ( grep { exists $unseen->{ $_ }
     1026   0.00003   0.02000  3344: my $t = $g->get_edge_attribute( $r, $s,
     1026   0.00025   0.00000  3345: $t = 1 unless defined $t;
     1026   0.00069   0.00000  3346: if ($t < 0) {
        0   0.00000   0.00000  3347:     require Carp;
        0   0.00000   0.00000  3348:     Carp::croak("Graph::SPT_Dijkstra: edge
        0   0.00000   0.00000  3349: }
     1026   0.00037   0.00000  3350: if (!defined($etc->{ $s }) || ($etc_r + $t)
      828   0.00097   0.02000  3351:     my $etc_s = $etc->{ $s } || 0;
      828   0.00000   0.00000  3352:     $etc->{ $s } = $etc_r + $t;
        0   0.00000   0.00000  3353:     # print "$r - $s : setting $s to $etc->{
      828   0.00000   0.00000  3354:     $h->set_vertex_attribute( $s, $attr,
      828   0.00001   0.01000  3355:     $h->set_vertex_attribute( $s, 'p', $r );
      828   0.00001   0.00000  3356:     $HF->add( Graph::SPTHeapElem->new($r,
        0   0.00000   0.00000  3357: }
        0   0.00000   0.00000  3358:    }
        0   0.00000   0.00000  3359:}
        0   0.00000   0.00000  3360:
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 103
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  3361:sub _SPT_Dijkstra_compute {
        0   0.00000   0.00000  3362:}
        0   0.00000   0.00000  3363:
        0   0.00000   0.00000  3364:sub SPT_Dijkstra {
     1764   0.00027   0.00000  3365:    my $g = shift;
     1764   0.00081   0.01000  3366:    my %opt = @_ == 1 ? (first_root => $_[0])
     1764   0.00027   0.01000  3367:    my $first_root = $opt{ first_root };
     1764   0.00044   0.02000  3368:    unless (defined $first_root) {
        0   0.00000   0.00000  3369: $opt{ first_root } = $first_root = $g-
        0   0.00000   0.00000  3370:    }
     1764   0.00075   0.00000  3371:    my $spt_di = $g-
     1764   0.00098   0.04000  3372:    unless (defined $spt_di && exists
       54   0.00000   0.00000  3373: my %etc;
       54   0.00000   0.00000  3374: my $sptg = $g->_heap_walk($g->new,
       54   0.00000   0.00000  3375: $spt_di->{ $first_root } = [ $g->[ _G ],
       54   0.00000   0.00000  3376: $g->set_graph_attribute('_spt_di', $spt_di);
        0   0.00000   0.00000  3377:    }
        0   0.00000   0.00000  3378:
     1764   0.00110   0.01000  3379:    my $spt = $spt_di->{ $first_root }->[ 1
        0   0.00000   0.00000  3380:
     1764   0.00045   0.01000  3381:    $spt-
        0   0.00000   0.00000  3382:
     1764   0.00073   0.01000  3383:    return $spt;
        0   0.00000   0.00000  3384:}
        0   0.00000   0.00000  3385:
        0   0.00000   0.00000  3386:*SSSP_Dijkstra = \&SPT_Dijkstra;
        0   0.00000   0.00000  3387:
        0   0.00000   0.00000  3388:*single_source_shortest_paths =
        0   0.00000   0.00000  3389:
        0   0.00000   0.00000  3390:sub SP_Dijkstra {
     1764   0.00002   0.02000  3391:    my ($g, $u, $v) = @_;
     1764   0.00004   0.02000  3392:    my $sptg = $g->SPT_Dijkstra(first_root =>
     1764   0.00002   0.01000  3393:    my @path = ($v);
     1764   0.00179   0.02000  3394:    my %seen;
     1764   0.00025   0.02000  3395:    my $V = $g->vertices;
     1764   0.00008   0.03000  3396:    my $p;
     1764   0.00050   0.01000  3397:    while (defined($p = $sptg-
     5608   0.00074   0.05000  3398: last if exists $seen{$p};
     5608   0.00764   0.10000  3399: push @path, $p;
     5608   0.00066   0.05000  3400: $v = $p;
     5608   0.00052   0.03000  3401: $seen{$p}++;
     5608   0.00407   0.05000  3402: last if keys %seen == $V || $u eq $v;
        0   0.00000   0.00000  3403:    }
     1764   0.00000   0.01000  3404:    @path = () if @path && $path[-1] ne $u;
     1764   0.00222   0.02000  3405:    return reverse @path;
        0   0.00000   0.00000  3406:}
        0   0.00000   0.00000  3407:
        0   0.00000   0.00000  3408:sub __SPT_Bellman_Ford {
        0   0.00000   0.00000  3409:    my ($g, $u, $v, $attr, $d, $p, $c0, $c1)
        0   0.00000   0.00000  3410:    return unless $c0->{ $u };
        0   0.00000   0.00000  3411:    my $w = $g->get_edge_attribute($u, $v,
        0   0.00000   0.00000  3412:    $w = 1 unless defined $w;
        0   0.00000   0.00000  3413:    if (defined $d->{ $v }) {
        0   0.00000   0.00000  3414: if (defined $d->{ $u }) {
        0   0.00000   0.00000  3415:     if ($d->{ $v } > $d->{ $u } + $w) {
        0   0.00000   0.00000  3416:  $d->{ $v } = $d->{ $u } + $w;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 104
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  3417:  $p->{ $v } = $u;
        0   0.00000   0.00000  3418:  $c1->{ $v }++;
        0   0.00000   0.00000  3419:     }
        0   0.00000   0.00000  3420: } # else !defined $d->{ $u } &&  defined $d-
        0   0.00000   0.00000  3421:    } else {
        0   0.00000   0.00000  3422: if (defined $d->{ $u }) {
        0   0.00000   0.00000  3423:     #  defined $d->{ $u } && !defined $d->{
        0   0.00000   0.00000  3424:     $d->{ $v } = $d->{ $u } + $w;
        0   0.00000   0.00000  3425:     $p->{ $v } = $u;
        0   0.00000   0.00000  3426:     $c1->{ $v }++;
        0   0.00000   0.00000  3427: } # else !defined $d->{ $u } && !defined $d-
        0   0.00000   0.00000  3428:    }
        0   0.00000   0.00000  3429:}
        0   0.00000   0.00000  3430:
        0   0.00000   0.00000  3431:sub _SPT_Bellman_Ford {
        0   0.00000   0.00000  3432:    my ($g, $opt, $unseenh, $unseena, $r,
        0   0.00000   0.00000  3433:    my %d;
        0   0.00000   0.00000  3434:    return unless defined $r;
        0   0.00000   0.00000  3435:    $d{ $r } = 0;
        0   0.00000   0.00000  3436:    my %p;
        0   0.00000   0.00000  3437:    my $V = $g->vertices;
        0   0.00000   0.00000  3438:    my %c0; # Changed during the last
        0   0.00000   0.00000  3439:    $c0{ $r }++;
        0   0.00000   0.00000  3440:    for (my $i = 0; $i < $V; $i++) {
        0   0.00000   0.00000  3441: my %c1;
        0   0.00000   0.00000  3442: for my $e ($g->edges) {
        0   0.00000   0.00000  3443:     my ($u, $v) = @$e;
        0   0.00000   0.00000  3444:     __SPT_Bellman_Ford($g, $u, $v, $attr,
        0   0.00000   0.00000  3445:     if ($g->undirected) {
        0   0.00000   0.00000  3446:  __SPT_Bellman_Ford($g, $v, $u, $attr, \%d,
        0   0.00000   0.00000  3447:     }
        0   0.00000   0.00000  3448: }
        0   0.00000   0.00000  3449: %c0 = %c1 unless $i == $V - 1;
        0   0.00000   0.00000  3450:    }
        0   0.00000   0.00000  3451:
        0   0.00000   0.00000  3452:    for my $e ($g->edges) {
        0   0.00000   0.00000  3453: my ($u, $v) = @$e;
        0   0.00000   0.00000  3454: if (defined $d{ $u } && defined $d{ $v }) {
        0   0.00000   0.00000  3455:     my $d = $g->get_edge_attribute($u, $v,
        0   0.00000   0.00000  3456:     if (defined $d && $d{ $v } > $d{ $u } +
        0   0.00000   0.00000  3457:  require Carp;
        0   0.00000   0.00000  3458:  Carp::croak("Graph::SPT_Bellman_Ford:
        0   0.00000   0.00000  3459:     }
        0   0.00000   0.00000  3460: }
        0   0.00000   0.00000  3461:    }
        0   0.00000   0.00000  3462:
        0   0.00000   0.00000  3463:    return (\%p, \%d);
        0   0.00000   0.00000  3464:}
        0   0.00000   0.00000  3465:
        0   0.00000   0.00000  3466:sub _SPT_Bellman_Ford_compute {
        0   0.00000   0.00000  3467:}
        0   0.00000   0.00000  3468:
        0   0.00000   0.00000  3469:sub SPT_Bellman_Ford {
        0   0.00000   0.00000  3470:    my $g = shift;
        0   0.00000   0.00000  3471:
        0   0.00000   0.00000  3472:    my ($opt, $unseenh, $unseena, $r, $next,
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 105
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  3473:
        0   0.00000   0.00000  3474:    unless (defined $r) {
        0   0.00000   0.00000  3475: $r = $g->random_vertex();
        0   0.00000   0.00000  3476: return unless defined $r;
        0   0.00000   0.00000  3477:    }
        0   0.00000   0.00000  3478:
        0   0.00000   0.00000  3479:    my $spt_bf = $g-
        0   0.00000   0.00000  3480:    unless (defined $spt_bf &&
        0   0.00000   0.00000  3481:     exists $spt_bf->{ $r } && $spt_bf->{ $r
        0   0.00000   0.00000  3482: my ($p, $d) =
        0   0.00000   0.00000  3483:     $g->_SPT_Bellman_Ford($opt, $unseenh,
        0   0.00000   0.00000  3484:      $r, $next, $code, $attr);
        0   0.00000   0.00000  3485: my $h = $g->new;
        0   0.00000   0.00000  3486: for my $v (keys %$p) {
        0   0.00000   0.00000  3487:     my $u = $p->{ $v };
        0   0.00000   0.00000  3488:     $h->add_edge( $u, $v );
        0   0.00000   0.00000  3489:     $h->set_edge_attribute( $u, $v, $attr,
        0   0.00000   0.00000  3490:        $g->get_edge_attribute($u, $v,
        0   0.00000   0.00000  3491:     $h->set_vertex_attribute( $v, $attr, $d-
        0   0.00000   0.00000  3492:     $h->set_vertex_attribute( $v, 'p', $u );
        0   0.00000   0.00000  3493: }
        0   0.00000   0.00000  3494: $spt_bf->{ $r } = [ $g->[ _G ], $h ];
        0   0.00000   0.00000  3495: $g->set_graph_attribute('_spt_bf', $spt_bf);
        0   0.00000   0.00000  3496:    }
        0   0.00000   0.00000  3497:
        0   0.00000   0.00000  3498:    my $spt = $spt_bf->{ $r }->[ 1 ];
        0   0.00000   0.00000  3499:
        0   0.00000   0.00000  3500:    $spt-
        0   0.00000   0.00000  3501:
        0   0.00000   0.00000  3502:    return $spt;
        0   0.00000   0.00000  3503:}
        0   0.00000   0.00000  3504:
        0   0.00000   0.00000  3505:*SSSP_Bellman_Ford = \&SPT_Bellman_Ford;
        0   0.00000   0.00000  3506:
        0   0.00000   0.00000  3507:sub SP_Bellman_Ford {
        0   0.00000   0.00000  3508:    my ($g, $u, $v) = @_;
        0   0.00000   0.00000  3509:    my $sptg = $g-
        0   0.00000   0.00000  3510:    my @path = ($v);
        0   0.00000   0.00000  3511:    my %seen;
        0   0.00000   0.00000  3512:    my $V = $g->vertices;
        0   0.00000   0.00000  3513:    my $p;
        0   0.00000   0.00000  3514:    while (defined($p = $sptg-
        0   0.00000   0.00000  3515: last if exists $seen{$p};
        0   0.00000   0.00000  3516: push @path, $p;
        0   0.00000   0.00000  3517: $v = $p;
        0   0.00000   0.00000  3518: $seen{$p}++;
        0   0.00000   0.00000  3519: last if keys %seen == $V;
        0   0.00000   0.00000  3520:    }
        0   0.00000   0.00000  3521:    # @path = () if @path && "$path[-1]" ne
        0   0.00000   0.00000  3522:    return reverse @path;
        0   0.00000   0.00000  3523:}
        0   0.00000   0.00000  3524:
        0   0.00000   0.00000  3525:###
        0   0.00000   0.00000  3526:# Transitive Closure.
        0   0.00000   0.00000  3527:#
        0   0.00000   0.00000  3528:
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 106
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  3529:sub TransitiveClosure_Floyd_Warshall {
        0   0.00000   0.00000  3530:    my $self = shift;
        0   0.00000   0.00000  3531:    my $class = ref $self || $self;
        0   0.00000   0.00000  3532:    $self = shift unless ref $self;
        0   0.00000   0.00000  3533:    bless Graph::TransitiveClosure-
        0   0.00000   0.00000  3534:}
        0   0.00000   0.00000  3535:
        0   0.00000   0.00000  3536:*transitive_closure =
        0   0.00000   0.00000  3537:
        0   0.00000   0.00000  3538:sub APSP_Floyd_Warshall {
        0   0.00000   0.00000  3539:    my $self = shift;
        0   0.00000   0.00000  3540:    my $class = ref $self || $self;
        0   0.00000   0.00000  3541:    $self = shift unless ref $self;
        0   0.00000   0.00000  3542:    bless Graph::TransitiveClosure-
        0   0.00000   0.00000  3543:}
        0   0.00000   0.00000  3544:
        0   0.00000   0.00000  3545:*all_pairs_shortest_paths =
        0   0.00000   0.00000  3546:
        0   0.00000   0.00000  3547:sub _transitive_closure_matrix_compute {
        0   0.00000   0.00000  3548:}
        0   0.00000   0.00000  3549:
        0   0.00000   0.00000  3550:sub transitive_closure_matrix {
        0   0.00000   0.00000  3551:    my $g = shift;
        0   0.00000   0.00000  3552:    my $tcm = $g-
        0   0.00000   0.00000  3553:    if (defined $tcm) {
        0   0.00000   0.00000  3554: if (ref $tcm eq 'ARRAY') { # YECHHH!
        0   0.00000   0.00000  3555:     if ($tcm->[ 0 ] == $g->[ _G ]) {
        0   0.00000   0.00000  3556:  $tcm = $tcm->[ 1 ];
        0   0.00000   0.00000  3557:     } else {
        0   0.00000   0.00000  3558:  undef $tcm;
        0   0.00000   0.00000  3559:     }
        0   0.00000   0.00000  3560: }
        0   0.00000   0.00000  3561:    }
        0   0.00000   0.00000  3562:    unless (defined $tcm) {
        0   0.00000   0.00000  3563: my $apsp = $g->APSP_Floyd_Warshall(@_);
        0   0.00000   0.00000  3564: $tcm = $apsp->get_graph_attribute('_tcm');
        0   0.00000   0.00000  3565: $g->set_graph_attribute('_tcm', [ $g->[ _G
        0   0.00000   0.00000  3566:    }
        0   0.00000   0.00000  3567:
        0   0.00000   0.00000  3568:    return $tcm;
        0   0.00000   0.00000  3569:}
        0   0.00000   0.00000  3570:
        0   0.00000   0.00000  3571:sub path_length {
        0   0.00000   0.00000  3572:    my $g = shift;
        0   0.00000   0.00000  3573:    my $tcm = $g->transitive_closure_matrix;
        0   0.00000   0.00000  3574:    $tcm->path_length(@_);
        0   0.00000   0.00000  3575:}
        0   0.00000   0.00000  3576:
        0   0.00000   0.00000  3577:sub path_predecessor {
        0   0.00000   0.00000  3578:    my $g = shift;
        0   0.00000   0.00000  3579:    my $tcm = $g->transitive_closure_matrix;
        0   0.00000   0.00000  3580:    $tcm->path_predecessor(@_);
        0   0.00000   0.00000  3581:}
        0   0.00000   0.00000  3582:
        0   0.00000   0.00000  3583:sub path_vertices {
        0   0.00000   0.00000  3584:    my $g = shift;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 107
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  3585:    my $tcm = $g->transitive_closure_matrix;
        0   0.00000   0.00000  3586:    $tcm->path_vertices(@_);
        0   0.00000   0.00000  3587:}
        0   0.00000   0.00000  3588:
        0   0.00000   0.00000  3589:sub is_reachable {
        0   0.00000   0.00000  3590:    my $g = shift;
        0   0.00000   0.00000  3591:    my $tcm = $g->transitive_closure_matrix;
        0   0.00000   0.00000  3592:    $tcm->is_reachable(@_);
        0   0.00000   0.00000  3593:}
        0   0.00000   0.00000  3594:
        0   0.00000   0.00000  3595:sub for_shortest_paths {
        0   0.00000   0.00000  3596:    my $g = shift;
        0   0.00000   0.00000  3597:    my $c = shift;
        0   0.00000   0.00000  3598:    my $t = $g->transitive_closure_matrix;
        0   0.00000   0.00000  3599:    my @v = $g->vertices;
        0   0.00000   0.00000  3600:    my $n = 0;
        0   0.00000   0.00000  3601:    for my $u (@v) {
        0   0.00000   0.00000  3602: for my $v (@v) {
        0   0.00000   0.00000  3603:     next unless $t->is_reachable($u, $v);
        0   0.00000   0.00000  3604:     $n++;
        0   0.00000   0.00000  3605:     $c->($t, $u, $v, $n);
        0   0.00000   0.00000  3606: }
        0   0.00000   0.00000  3607:    }
        0   0.00000   0.00000  3608:    return $n;
        0   0.00000   0.00000  3609:}
        0   0.00000   0.00000  3610:
        0   0.00000   0.00000  3611:sub _minmax_path {
        0   0.00000   0.00000  3612:    my $g = shift;
        0   0.00000   0.00000  3613:    my $min;
        0   0.00000   0.00000  3614:    my $max;
        0   0.00000   0.00000  3615:    my $minp;
        0   0.00000   0.00000  3616:    my $maxp;
        0   0.00000   0.00000  3617:    $g->for_shortest_paths(sub {
        0   0.00000   0.00000  3618:          my ($t, $u, $v, $n) = @_;
        0   0.00000   0.00000  3619:          my $l = $t->path_length($u, $v);
        0   0.00000   0.00000  3620:          return unless defined $l;
        0   0.00000   0.00000  3621:          my $p;
        0   0.00000   0.00000  3622:          if ($u ne $v && (!defined $max ||
        0   0.00000   0.00000  3623:       $max = $l;
        0   0.00000   0.00000  3624:       $maxp = $p = [ $t->path_vertices($u,
        0   0.00000   0.00000  3625:          }
        0   0.00000   0.00000  3626:          if ($u ne $v && (!defined $min ||
        0   0.00000   0.00000  3627:       $min = $l;
        0   0.00000   0.00000  3628:       $minp = $p || [ $t->path_vertices($u,
        0   0.00000   0.00000  3629:          }
        0   0.00000   0.00000  3630:      });
        0   0.00000   0.00000  3631:    return ($min, $max, $minp, $maxp);
        0   0.00000   0.00000  3632:}
        0   0.00000   0.00000  3633:
        0   0.00000   0.00000  3634:sub diameter {
        0   0.00000   0.00000  3635:    my $g = shift;
        0   0.00000   0.00000  3636:    my ($min, $max, $minp, $maxp) = $g-
        0   0.00000   0.00000  3637:    return defined $maxp ? (wantarray ?
        0   0.00000   0.00000  3638:}
        0   0.00000   0.00000  3639:
        0   0.00000   0.00000  3640:*graph_diameter = \&diameter;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 108
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  3641:
        0   0.00000   0.00000  3642:sub longest_path {
        0   0.00000   0.00000  3643:    my ($g, $u, $v) = @_;
        0   0.00000   0.00000  3644:    my $t = $g->transitive_closure_matrix;
        0   0.00000   0.00000  3645:    if (defined $u) {
        0   0.00000   0.00000  3646: if (defined $v) {
        0   0.00000   0.00000  3647:     return wantarray ?
        0   0.00000   0.00000  3648:  $t->path_vertices($u, $v) : $t-
        0   0.00000   0.00000  3649: } else {
        0   0.00000   0.00000  3650:     my $max;
        0   0.00000   0.00000  3651:     my @max;
        0   0.00000   0.00000  3652:     for my $v ($g->vertices) {
        0   0.00000   0.00000  3653:  next if $u eq $v;
        0   0.00000   0.00000  3654:  my $l = $t->path_length($u, $v);
        0   0.00000   0.00000  3655:  if (defined $l && (!defined $max || $l >
        0   0.00000   0.00000  3656:      $max = $l;
        0   0.00000   0.00000  3657:      @max = $t->path_vertices($u, $v);
        0   0.00000   0.00000  3658:  }
        0   0.00000   0.00000  3659:     }
        0   0.00000   0.00000  3660:     return wantarray ? @max : $max;
        0   0.00000   0.00000  3661: }
        0   0.00000   0.00000  3662:    } else {
        0   0.00000   0.00000  3663: if (defined $v) {
        0   0.00000   0.00000  3664:     my $max;
        0   0.00000   0.00000  3665:     my @max;
        0   0.00000   0.00000  3666:     for my $u ($g->vertices) {
        0   0.00000   0.00000  3667:  next if $u eq $v;
        0   0.00000   0.00000  3668:  my $l = $t->path_length($u, $v);
        0   0.00000   0.00000  3669:  if (defined $l && (!defined $max || $l >
        0   0.00000   0.00000  3670:      $max = $l;
        0   0.00000   0.00000  3671:      @max = $t->path_vertices($u, $v);
        0   0.00000   0.00000  3672:  }
        0   0.00000   0.00000  3673:     }
        0   0.00000   0.00000  3674:     return wantarray ? @max : @max - 1;
        0   0.00000   0.00000  3675: } else {
        0   0.00000   0.00000  3676:     my ($min, $max, $minp, $maxp) = $g-
        0   0.00000   0.00000  3677:     return defined $maxp ? (wantarray ?
        0   0.00000   0.00000  3678: }
        0   0.00000   0.00000  3679:    }
        0   0.00000   0.00000  3680:}
        0   0.00000   0.00000  3681:
        0   0.00000   0.00000  3682:sub vertex_eccentricity {
        0   0.00000   0.00000  3683:    my ($g, $u) = @_;
        0   0.00000   0.00000  3684:    $g->expect_undirected;
        0   0.00000   0.00000  3685:    if ($g->is_connected) {
        0   0.00000   0.00000  3686: my $max;
        0   0.00000   0.00000  3687: for my $v ($g->vertices) {
        0   0.00000   0.00000  3688:     next if $u eq $v;
        0   0.00000   0.00000  3689:     my $l = $g->path_length($u, $v);
        0   0.00000   0.00000  3690:     if (defined $l && (!defined $max || $l >
        0   0.00000   0.00000  3691:  $max = $l;
        0   0.00000   0.00000  3692:     }
        0   0.00000   0.00000  3693: }
        0   0.00000   0.00000  3694: return $max;
        0   0.00000   0.00000  3695:    } else {
        0   0.00000   0.00000  3696: return Infinity();
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 109
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  3697:    }
        0   0.00000   0.00000  3698:}
        0   0.00000   0.00000  3699:
        0   0.00000   0.00000  3700:sub shortest_path {
        0   0.00000   0.00000  3701:    my ($g, $u, $v) = @_;
        0   0.00000   0.00000  3702:    $g->expect_undirected;
        0   0.00000   0.00000  3703:    my $t = $g->transitive_closure_matrix;
        0   0.00000   0.00000  3704:    if (defined $u) {
        0   0.00000   0.00000  3705: if (defined $v) {
        0   0.00000   0.00000  3706:     return wantarray ?
        0   0.00000   0.00000  3707:  $t->path_vertices($u, $v) : $t-
        0   0.00000   0.00000  3708: } else {
        0   0.00000   0.00000  3709:     my $min;
        0   0.00000   0.00000  3710:     my @min;
        0   0.00000   0.00000  3711:     for my $v ($g->vertices) {
        0   0.00000   0.00000  3712:  next if $u eq $v;
        0   0.00000   0.00000  3713:  my $l = $t->path_length($u, $v);
        0   0.00000   0.00000  3714:  if (defined $l && (!defined $min || $l <
        0   0.00000   0.00000  3715:      $min = $l;
        0   0.00000   0.00000  3716:      @min = $t->path_vertices($u, $v);
        0   0.00000   0.00000  3717:  }
        0   0.00000   0.00000  3718:     }
        0   0.00000   0.00000  3719:     return wantarray ? @min : $min;
        0   0.00000   0.00000  3720: }
        0   0.00000   0.00000  3721:    } else {
        0   0.00000   0.00000  3722: if (defined $v) {
        0   0.00000   0.00000  3723:     my $min;
        0   0.00000   0.00000  3724:     my @min;
        0   0.00000   0.00000  3725:     for my $u ($g->vertices) {
        0   0.00000   0.00000  3726:  next if $u eq $v;
        0   0.00000   0.00000  3727:  my $l = $t->path_length($u, $v);
        0   0.00000   0.00000  3728:  if (defined $l && (!defined $min || $l <
        0   0.00000   0.00000  3729:      $min = $l;
        0   0.00000   0.00000  3730:      @min = $t->path_vertices($u, $v);
        0   0.00000   0.00000  3731:  }
        0   0.00000   0.00000  3732:     }
        0   0.00000   0.00000  3733:     return wantarray ? @min : $min;
        0   0.00000   0.00000  3734: } else {
        0   0.00000   0.00000  3735:     my ($min, $max, $minp, $maxp) = $g-
        0   0.00000   0.00000  3736:     return defined $minp ? (wantarray ?
        0   0.00000   0.00000  3737: }
        0   0.00000   0.00000  3738:    }
        0   0.00000   0.00000  3739:}
        0   0.00000   0.00000  3740:
        0   0.00000   0.00000  3741:sub radius {
        0   0.00000   0.00000  3742:    my $g = shift;
        0   0.00000   0.00000  3743:    $g->expect_undirected;
        0   0.00000   0.00000  3744:    my ($center, $radius) = (undef,
        0   0.00000   0.00000  3745:    for my $v ($g->vertices) {
        0   0.00000   0.00000  3746: my $x = $g->vertex_eccentricity($v);
        0   0.00000   0.00000  3747: ($center, $radius) = ($v, $x) if defined $x
        0   0.00000   0.00000  3748:    }
        0   0.00000   0.00000  3749:    return $radius;
        0   0.00000   0.00000  3750:}
        0   0.00000   0.00000  3751:
        0   0.00000   0.00000  3752:sub center_vertices {
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 110
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  3753:    my ($g, $delta) = @_;
        0   0.00000   0.00000  3754:    $g->expect_undirected;
        0   0.00000   0.00000  3755:    $delta = 0 unless defined $delta;
        0   0.00000   0.00000  3756:    $delta = abs($delta);
        0   0.00000   0.00000  3757:    my @c;
        0   0.00000   0.00000  3758:    my $r = $g->radius;
        0   0.00000   0.00000  3759:    if (defined $r) {
        0   0.00000   0.00000  3760: for my $v ($g->vertices) {
        0   0.00000   0.00000  3761:     my $e = $g->vertex_eccentricity($v);
        0   0.00000   0.00000  3762:     next unless defined $e;
        0   0.00000   0.00000  3763:     push @c, $v if abs($e - $r) <= $delta;
        0   0.00000   0.00000  3764: }
        0   0.00000   0.00000  3765:    }
        0   0.00000   0.00000  3766:    return @c;
        0   0.00000   0.00000  3767:}
        0   0.00000   0.00000  3768:
        0   0.00000   0.00000  3769:*centre_vertices = \&center_vertices;
        0   0.00000   0.00000  3770:
        0   0.00000   0.00000  3771:sub average_path_length {
        0   0.00000   0.00000  3772:    my $g = shift;
        0   0.00000   0.00000  3773:    my @A = @_;
        0   0.00000   0.00000  3774:    my $d = 0;
        0   0.00000   0.00000  3775:    my $m = 0;
        0   0.00000   0.00000  3776:    my $n = $g->for_shortest_paths(sub {
        0   0.00000   0.00000  3777:           my ($t, $u, $v, $n) = @_;
        0   0.00000   0.00000  3778:           my $l = $t->path_length($u, $v);
        0   0.00000   0.00000  3779:           if ($l) {
        0   0.00000   0.00000  3780:        my $c = @A == 0 ||
        0   0.00000   0.00000  3781:            (@A == 1 && $u eq $A[0]) ||
        0   0.00000   0.00000  3782:         ((@A == 2) &&
        0   0.00000   0.00000  3783:          (defined $A[0] &&
        0   0.00000   0.00000  3784:           $u eq $A[0]) ||
        0   0.00000   0.00000  3785:          (defined $A[1] &&
        0   0.00000   0.00000  3786:           $v eq $A[1]));
        0   0.00000   0.00000  3787:        if ($c) {
        0   0.00000   0.00000  3788:            $d += $l;
        0   0.00000   0.00000  3789:            $m++;
        0   0.00000   0.00000  3790:        }
        0   0.00000   0.00000  3791:           }
        0   0.00000   0.00000  3792:       });
        0   0.00000   0.00000  3793:    return $m ? $d / $m : undef;
        0   0.00000   0.00000  3794:}
        0   0.00000   0.00000  3795:
        0   0.00000   0.00000  3796:###
        0   0.00000   0.00000  3797:# Simple tests.
        0   0.00000   0.00000  3798:#
        0   0.00000   0.00000  3799:
        0   0.00000   0.00000  3800:sub is_multi_graph {
        0   0.00000   0.00000  3801:    my $g = shift;
        0   0.00000   0.00000  3802:    return 0 unless $g->is_multiedged || $g-
        0   0.00000   0.00000  3803:    my $multiedges = 0;
        0   0.00000   0.00000  3804:    for my $e ($g->edges05) {
        0   0.00000   0.00000  3805: my ($u, @v) = @$e;
        0   0.00000   0.00000  3806: for my $v (@v) {
        0   0.00000   0.00000  3807:     return 0 if $u eq $v;
        0   0.00000   0.00000  3808: }
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 111
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  3809: $multiedges++ if $g->get_edge_count(@$e) >
        0   0.00000   0.00000  3810:    }
        0   0.00000   0.00000  3811:    return $multiedges;
        0   0.00000   0.00000  3812:}
        0   0.00000   0.00000  3813:
        0   0.00000   0.00000  3814:sub is_simple_graph {
        0   0.00000   0.00000  3815:    my $g = shift;
        0   0.00000   0.00000  3816:    return 1 unless $g->is_countedged || $g-
        0   0.00000   0.00000  3817:    for my $e ($g->edges05) {
        0   0.00000   0.00000  3818: return 0 if $g->get_edge_count(@$e) > 1;
        0   0.00000   0.00000  3819:    }
        0   0.00000   0.00000  3820:    return 1;
        0   0.00000   0.00000  3821:}
        0   0.00000   0.00000  3822:
        0   0.00000   0.00000  3823:sub is_pseudo_graph {
        0   0.00000   0.00000  3824:    my $g = shift;
        0   0.00000   0.00000  3825:    my $m = $g->is_countedged || $g-
        0   0.00000   0.00000  3826:    for my $e ($g->edges05) {
        0   0.00000   0.00000  3827: my ($u, @v) = @$e;
        0   0.00000   0.00000  3828: for my $v (@v) {
        0   0.00000   0.00000  3829:     return 1 if $u eq $v;
        0   0.00000   0.00000  3830: }
        0   0.00000   0.00000  3831: return 1 if $m && $g->get_edge_count($u, @v)
        0   0.00000   0.00000  3832:    }
        0   0.00000   0.00000  3833:    return 0;
        0   0.00000   0.00000  3834:}
        0   0.00000   0.00000  3835:
        0   0.00000   0.00000  3836:###
        0   0.00000   0.00000  3837:# Rough isomorphism guess.
        0   0.00000   0.00000  3838:#
        0   0.00000   0.00000  3839:
        0   0.00000   0.00000  3840:my %_factorial = (0 => 1, 1 => 1);
        0   0.00000   0.00000  3841:
        0   0.00000   0.00000  3842:sub __factorial {
        0   0.00000   0.00000  3843:    my $n = shift;
        0   0.00000   0.00000  3844:    for (my $i = 2; $i <= $n; $i++) {
        0   0.00000   0.00000  3845: next if exists $_factorial{$i};
        0   0.00000   0.00000  3846: $_factorial{$i} = $i * $_factorial{$i - 1};
        0   0.00000   0.00000  3847:    }
        0   0.00000   0.00000  3848:    $_factorial{$n};
        0   0.00000   0.00000  3849:}
        0   0.00000   0.00000  3850:
        0   0.00000   0.00000  3851:sub _factorial {
        0   0.00000   0.00000  3852:    my $n = int(shift);
        0   0.00000   0.00000  3853:    if ($n < 0) {
        0   0.00000   0.00000  3854: require Carp;
        0   0.00000   0.00000  3855: Carp::croak("factorial of a negative
        0   0.00000   0.00000  3856:    }
        0   0.00000   0.00000  3857:    __factorial($n) unless exists
        0   0.00000   0.00000  3858:    return $_factorial{$n};
        0   0.00000   0.00000  3859:}
        0   0.00000   0.00000  3860:
        0   0.00000   0.00000  3861:sub could_be_isomorphic {
        0   0.00000   0.00000  3862:    my ($g0, $g1) = @_;
        0   0.00000   0.00000  3863:    return 0 unless $g0->vertices == $g1-
        0   0.00000   0.00000  3864:    return 0 unless $g0->edges05  == $g1-
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 112
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  3865:    my %d0;
        0   0.00000   0.00000  3866:    for my $v0 ($g0->vertices) {
        0   0.00000   0.00000  3867: $d0{ $g0->in_degree($v0) }{ $g0-
        0   0.00000   0.00000  3868:    }
        0   0.00000   0.00000  3869:    my %d1;
        0   0.00000   0.00000  3870:    for my $v1 ($g1->vertices) {
        0   0.00000   0.00000  3871: $d1{ $g1->in_degree($v1) }{ $g1-
        0   0.00000   0.00000  3872:    }
        0   0.00000   0.00000  3873:    return 0 unless keys %d0 == keys %d1;
        0   0.00000   0.00000  3874:    for my $da (keys %d0) {
        0   0.00000   0.00000  3875: return 0
        0   0.00000   0.00000  3876:     unless exists $d1{$da} &&
        0   0.00000   0.00000  3877:     keys %{ $d0{$da} } == keys %{ $d1{$da}
        0   0.00000   0.00000  3878: for my $db (keys %{ $d0{$da} }) {
        0   0.00000   0.00000  3879:     return 0
        0   0.00000   0.00000  3880:  unless exists $d1{$da}{$db} &&
        0   0.00000   0.00000  3881:         $d0{$da}{$db} == $d1{$da}{$db};
        0   0.00000   0.00000  3882: }
        0   0.00000   0.00000  3883:    }
        0   0.00000   0.00000  3884:    for my $da (keys %d0) {
        0   0.00000   0.00000  3885: for my $db (keys %{ $d0{$da} }) {
        0   0.00000   0.00000  3886:     return 0 unless $d1{$da}{$db} ==
        0   0.00000   0.00000  3887: }
        0   0.00000   0.00000  3888: delete $d1{$da};
        0   0.00000   0.00000  3889:    }
        0   0.00000   0.00000  3890:    return 0 unless keys %d1 == 0;
        0   0.00000   0.00000  3891:    my $f = 1;
        0   0.00000   0.00000  3892:    for my $da (keys %d0) {
        0   0.00000   0.00000  3893: for my $db (keys %{ $d0{$da} }) {
        0   0.00000   0.00000  3894:     $f *= _factorial(abs($d0{$da}{$db}));
        0   0.00000   0.00000  3895: }
        0   0.00000   0.00000  3896:    }
        0   0.00000   0.00000  3897:    return $f;
        0   0.00000   0.00000  3898:}
        0   0.00000   0.00000  3899:
        0   0.00000   0.00000  3900:###
        0   0.00000   0.00000  3901:# Analysis functions.
        0   0.00000   0.00000  3902:
        0   0.00000   0.00000  3903:sub subgraph_by_radius
        0   0.00000   0.00000  3904:{
        0   0.00000   0.00000  3905:    my ($g, $n, $rad) = @_;
        0   0.00000   0.00000  3906:
        0   0.00000   0.00000  3907:    return unless defined $n && defined $rad
        0   0.00000   0.00000  3908:
        0   0.00000   0.00000  3909:    my $r = (ref $g)->new;
        0   0.00000   0.00000  3910:
        0   0.00000   0.00000  3911:    if ($rad == 0) {
        0   0.00000   0.00000  3912: return $r->add_vertex($n);
        0   0.00000   0.00000  3913:    }
        0   0.00000   0.00000  3914:
        0   0.00000   0.00000  3915:    my %h;
        0   0.00000   0.00000  3916:    $h{1} = [ [ $n, $g->successors($n) ] ];
        0   0.00000   0.00000  3917:    for my $i (1..$rad) {
        0   0.00000   0.00000  3918: $h{$i+1} = [];
        0   0.00000   0.00000  3919: for my $arr (@{ $h{$i} }) {
        0   0.00000   0.00000  3920:     my ($p, @succ) = @{ $arr };
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 113
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  3921:     for my $s (@succ) {
        0   0.00000   0.00000  3922:  $r->add_edge($p, $s);
        0   0.00000   0.00000  3923:  push(@{ $h{$i+1} }, [$s, $g-
        0   0.00000   0.00000  3924:     }
        0   0.00000   0.00000  3925: }
        0   0.00000   0.00000  3926:    }
        0   0.00000   0.00000  3927:
        0   0.00000   0.00000  3928:    return $r;
        0   0.00000   0.00000  3929:}
        0   0.00000   0.00000  3930:
        0   0.00000   0.00000  3931:sub clustering_coefficient {
        0   0.00000   0.00000  3932:    my ($g) = @_;
        0   0.00000   0.00000  3933:    my %clustering;
        0   0.00000   0.00000  3934:
        0   0.00000   0.00000  3935:    my $gamma = 0;
        0   0.00000   0.00000  3936:
        0   0.00000   0.00000  3937:    for my $n ($g->vertices()) {
        0   0.00000   0.00000  3938: my $gamma_v = 0;
        0   0.00000   0.00000  3939: my @neigh = $g->successors($n);
        0   0.00000   0.00000  3940: my %c;
        0   0.00000   0.00000  3941: for my $u (@neigh) {
        0   0.00000   0.00000  3942:     for my $v (@neigh) {
        0   0.00000   0.00000  3943:  if (!$c{"$u-$v"} && $g->has_edge($u, $v)) {
        0   0.00000   0.00000  3944:      $gamma_v++;
        0   0.00000   0.00000  3945:      $c{"$u-$v"} = 1;
        0   0.00000   0.00000  3946:      $c{"$v-$u"} = 1;
        0   0.00000   0.00000  3947:  }
        0   0.00000   0.00000  3948:     }
        0   0.00000   0.00000  3949: }
        0   0.00000   0.00000  3950: if (@neigh > 1) {
        0   0.00000   0.00000  3951:     $clustering{$n} = $gamma_v/(@neigh *
        0   0.00000   0.00000  3952:     $gamma += $gamma_v/(@neigh * (@neigh -
        0   0.00000   0.00000  3953: } else {
        0   0.00000   0.00000  3954:     $clustering{$n} = 0;
        0   0.00000   0.00000  3955: }
        0   0.00000   0.00000  3956:    }
        0   0.00000   0.00000  3957:
        0   0.00000   0.00000  3958:    $gamma /= $g->vertices();
        0   0.00000   0.00000  3959:
        0   0.00000   0.00000  3960:    return wantarray ? ($gamma, %clustering)
        0   0.00000   0.00000  3961:}
        0   0.00000   0.00000  3962:
        0   0.00000   0.00000  3963:sub betweenness {
        0   0.00000   0.00000  3964:    my $g = shift;
        0   0.00000   0.00000  3965:
        0   0.00000   0.00000  3966:    my @V = $g->vertices();
        0   0.00000   0.00000  3967:
        0   0.00000   0.00000  3968:    my %Cb; # C_b{w} = 0
        0   0.00000   0.00000  3969:
        0   0.00000   0.00000  3970:    $Cb{$_} = 0 for @V;
        0   0.00000   0.00000  3971:
        0   0.00000   0.00000  3972:    for my $s (@V) {
        0   0.00000   0.00000  3973: my @S; # stack (unshift, shift)
        0   0.00000   0.00000  3974:
        0   0.00000   0.00000  3975: my %P; # P{w} = empty list
        0   0.00000   0.00000  3976: $P{$_} = [] for @V;
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 114
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  3977:
        0   0.00000   0.00000  3978: my %sigma; # \sigma{t} = 0
        0   0.00000   0.00000  3979: $sigma{$_} = 0 for @V;
        0   0.00000   0.00000  3980: $sigma{$s} = 1;
        0   0.00000   0.00000  3981:
        0   0.00000   0.00000  3982: my %d; # d{t} = -1;
        0   0.00000   0.00000  3983: $d{$_} = -1 for @V;
        0   0.00000   0.00000  3984: $d{$s} = 0;
        0   0.00000   0.00000  3985:
        0   0.00000   0.00000  3986: my @Q; # queue (push, shift)
        0   0.00000   0.00000  3987: push @Q, $s;
        0   0.00000   0.00000  3988:
        0   0.00000   0.00000  3989: while (@Q) {
        0   0.00000   0.00000  3990:     my $v = shift @Q;
        0   0.00000   0.00000  3991:     unshift @S, $v;
        0   0.00000   0.00000  3992:     for my $w ($g->successors($v)) {
        0   0.00000   0.00000  3993:  # w found for first time
        0   0.00000   0.00000  3994:  if ($d{$w} < 0) {
        0   0.00000   0.00000  3995:      push @Q, $w;
        0   0.00000   0.00000  3996:      $d{$w} = $d{$v} + 1;
        0   0.00000   0.00000  3997:  }
        0   0.00000   0.00000  3998:  # Shortest path to w via v
        0   0.00000   0.00000  3999:  if ($d{$w} == $d{$v} + 1) {
        0   0.00000   0.00000  4000:      $sigma{$w} += $sigma{$v};
        0   0.00000   0.00000  4001:      push @{ $P{$w} }, $v;
        0   0.00000   0.00000  4002:  }
        0   0.00000   0.00000  4003:     }
        0   0.00000   0.00000  4004: }
        0   0.00000   0.00000  4005:
        0   0.00000   0.00000  4006: my %delta;
        0   0.00000   0.00000  4007: $delta{$_} = 0 for @V;
        0   0.00000   0.00000  4008:
        0   0.00000   0.00000  4009: while (@S) {
        0   0.00000   0.00000  4010:     my $w = shift @S;
        0   0.00000   0.00000  4011:     for my $v (@{ $P{$w} }) {
        0   0.00000   0.00000  4012:  $delta{$v} += $sigma{$v}/$sigma{$w} * (1 +
        0   0.00000   0.00000  4013:     }
        0   0.00000   0.00000  4014:     if ($w ne $s) {
        0   0.00000   0.00000  4015:  $Cb{$w} += $delta{$w};
        0   0.00000   0.00000  4016:     }
        0   0.00000   0.00000  4017: }
        0   0.00000   0.00000  4018:    }
        0   0.00000   0.00000  4019:
        0   0.00000   0.00000  4020:    return %Cb;
        0   0.00000   0.00000  4021:}
        0   0.00000   0.00000  4022:
        0   0.00000   0.00000  4023:###
        0   0.00000   0.00000  4024:# Debugging.
        0   0.00000   0.00000  4025:#
        0   0.00000   0.00000  4026:
        0   0.00000   0.00000  4027:sub _dump {
        0   0.00000   0.00000  4028:    require Data::Dumper;
        0   0.00000   0.00000  4029:    my $d = Data::Dumper->new([$_[0]],[ref
        0   0.00000   0.00000  4030:    defined wantarray ? $d->Dump : print $d-
        0   0.00000   0.00000  4031:}
        0   0.00000   0.00000  4032:
           ================ SmallProf version 2.02 ================
               Profile of /usr/local/share/perl/5.10.0/Graph.pm        Page 115
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  4033:1;
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap.pm Page 116
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:package Graph::AdjacencyMap;
        0   0.00000   0.00000     2:
        0   0.00000   0.00000     3:use strict;
        0   0.00000   0.00000     4:
        0   0.00000   0.00000     5:require Exporter;
        0   0.00000   0.00000     6:use vars qw(@ISA @EXPORT_OK %EXPORT_TAGS);
        0   0.00000   0.00000     7:@ISA = qw(Exporter);
        0   0.00000   0.00000     8:@EXPORT_OK   = qw(_COUNT _MULTI _COUNTMULTI
        0   0.00000   0.00000     9:    _HYPER _UNORD _UNIQ _REF _UNORDUNIQ
        0   0.00000   0.00000    10:    _n _f _a _i _s _p _g _u _ni _nc _na _nm);
        0   0.00000   0.00000    11:%EXPORT_TAGS =
        0   0.00000   0.00000    12:    (flags =>  [qw(_COUNT _MULTI _COUNTMULTI
        0   0.00000   0.00000    13:     _HYPER _UNORD _UNIQ _REF _UNORDUNIQ
        0   0.00000   0.00000    14:     fields => [qw(_n _f _a _i _s _p _g _u
        0   0.00000   0.00000    15:
        0   0.00000   0.00000    16:sub _COUNT      () {  0x00000001   }
        0   0.00000   0.00000    17:sub _MULTI      () {  0x00000002   }
        0   0.00000   0.00000    18:sub _COUNTMULTI () { _COUNT|_MULTI }
        0   0.00000   0.00000    19:sub _HYPER      () {  0x00000004   }
        0   0.00000   0.00000    20:sub _UNORD      () {  0x00000008   }
        0   0.00000   0.00000    21:sub _UNIQ       () {  0x00000010   }
        0   0.00000   0.00000    22:sub _REF        () {  0x00000020   }
        0   0.00000   0.00000    23:sub _UNORDUNIQ  () { _UNORD|_UNIQ  }
        0   0.00000   0.00000    24:sub _UNIONFIND  () {  0x00000040   }
        0   0.00000   0.00000    25:sub _LIGHT      () {  0x00000080   }
        0   0.00000   0.00000    26:
        0   0.00000   0.00000    27:my $_GEN_ID = 0;
        0   0.00000   0.00000    28:
        0   0.00000   0.00000    29:sub _GEN_ID () { \$_GEN_ID }
        0   0.00000   0.00000    30:
        0   0.00000   0.00000    31:sub _ni () { 0 } # Node index.
        0   0.00000   0.00000    32:sub _nc () { 1 } # Node count.
        0   0.00000   0.00000    33:sub _na () { 2 } # Node attributes.
        0   0.00000   0.00000    34:sub _nm () { 3 } # Node map.
        0   0.00000   0.00000    35:
        0   0.00000   0.00000    36:sub _n () { 0 } # Next id.
        0   0.00000   0.00000    37:sub _f () { 1 } # Flags.
        0   0.00000   0.00000    38:sub _a () { 2 } # Arity.
        0   0.00000   0.00000    39:sub _i () { 3 } # Index to path.
        0   0.00000   0.00000    40:sub _s () { 4 } # Successors / Path to Index.
        0   0.00000   0.00000    41:sub _p () { 5 } # Predecessors.
        0   0.00000   0.00000    42:sub _g () { 6 } # Graph (AdjacencyMap::Light)
        0   0.00000   0.00000    43:
        0   0.00000   0.00000    44:sub _V () { 2 }  # Graph::_V()
        0   0.00000   0.00000    45:
        0   0.00000   0.00000    46:sub _new {
       58   0.00000   0.00000    47:    my $class = shift;
       58   0.00000   0.00000    48:    my $map = bless [ 0, @_ ], $class;
       58   0.00000   0.00000    49:    return $map;
        0   0.00000   0.00000    50:}
        0   0.00000   0.00000    51:
        0   0.00000   0.00000    52:sub _ids {
        4   0.00000   0.00000    53:    my $m = shift;
        4   0.00000   0.00000    54:    return $m->[ _i ];
        0   0.00000   0.00000    55:}
        0   0.00000   0.00000    56:
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap.pm Page 117
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000    57:sub has_paths {
        0   0.00000   0.00000    58:    my $m = shift;
        0   0.00000   0.00000    59:    return defined $m->[ _i ] && keys %{ $m-
        0   0.00000   0.00000    60:}
        0   0.00000   0.00000    61:
        0   0.00000   0.00000    62:sub _dump {
        0   0.00000   0.00000    63:    my $d = Data::Dumper->new([$_[0]],[ref
        0   0.00000   0.00000    64:    defined wantarray ? $d->Dump : print $d-
        0   0.00000   0.00000    65:}
        0   0.00000   0.00000    66:
        0   0.00000   0.00000    67:sub _del_id {
        0   0.00000   0.00000    68:    my ($m, $i) = @_;
        0   0.00000   0.00000    69:    my @p = $m->_get_id_path( $i );
        0   0.00000   0.00000    70:    $m->del_path( @p ) if @p;
        0   0.00000   0.00000    71:}
        0   0.00000   0.00000    72:
        0   0.00000   0.00000    73:sub _new_node {
     1718   0.00050   0.03000    74:    my ($m, $n, $id) = @_;
     1718   0.00010   0.06000    75:    my $f = $m->[ _f ];
     1718   0.00000   0.00000    76:    my $i = $m->[ _n ]++;
     1718   0.00001   0.00000    77:    if (($f & _MULTI)) {
        0   0.00000   0.00000    78: $id = 0 if $id eq _GEN_ID;
        0   0.00000   0.00000    79: $$n = [ $i, 0, undef, { $id => { } } ];
        0   0.00000   0.00000    80:    } elsif (($f & _COUNT)) {
        0   0.00000   0.00000    81: $$n = [ $i, 1 ];
        0   0.00000   0.00000    82:    } else {
     1718   0.00048   0.01000    83: $$n = $i;
        0   0.00000   0.00000    84:    }
     1718   0.00046   0.01000    85:    return $i;
        0   0.00000   0.00000    86:}
        0   0.00000   0.00000    87:
        0   0.00000   0.00000    88:sub _inc_node {
        0   0.00000   0.00000    89:    my ($m, $n, $id) = @_;
        0   0.00000   0.00000    90:    my $f = $m->[ _f ];
        0   0.00000   0.00000    91:    if (($f & _MULTI)) {
        0   0.00000   0.00000    92: if ($id eq _GEN_ID) {
        0   0.00000   0.00000    93:     $$n->[ _nc ]++
        0   0.00000   0.00000    94:  while exists $$n->[ _nm ]->{ $$n->[ _nc ]
        0   0.00000   0.00000    95:     $id = $$n->[ _nc ];
        0   0.00000   0.00000    96: }
        0   0.00000   0.00000    97: $$n->[ _nm ]->{ $id } = { };
        0   0.00000   0.00000    98:    } elsif (($f & _COUNT)) {
        0   0.00000   0.00000    99: $$n->[ _nc ]++;
        0   0.00000   0.00000   100:    }
        0   0.00000   0.00000   101:    return $id;
        0   0.00000   0.00000   102:}
        0   0.00000   0.00000   103:
        0   0.00000   0.00000   104:sub __get_path_node {
    13294   0.00303   0.12000   105:    my $m = shift;
    13294   0.00358   0.13000   106:    my ($p, $k);
    13294   0.00626   0.11000   107:    my $f = $m->[ _f ];
    13294   0.01128   0.04000   108:    @_ = sort @_ if ($f & _UNORD);
    13294   0.00133   0.09000   109:    if ($m->[ _a ] == 2 && @_ == 2 && !($f &
        0   0.00000   0.00000   110: return unless exists $m->[ _s ]->{ $_[0] };
        0   0.00000   0.00000   111: $p = [ $m->[ _s ], $m->[ _s ]->{ $_[0] } ];
        0   0.00000   0.00000   112: $k = [ $_[0], $_[1] ];
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap.pm Page 118
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   113:    } else {
    13294   0.00169   0.09000   114: ($p, $k) = $m->__has_path( @_ );
        0   0.00000   0.00000   115:    }
    13294   0.00835   0.13000   116:    return unless defined $p && defined $k;
    13294   0.00570   0.07000   117:    my $l = defined $k->[-1] ? $k->[-1] : "";
    13294   0.00331   0.14000   118:    return ( exists $p->[-1]->{ $l }, $p->[-
        0   0.00000   0.00000   119:}
        0   0.00000   0.00000   120:
        0   0.00000   0.00000   121:sub set_path_by_multi_id {
        0   0.00000   0.00000   122:    my $m = shift;
        0   0.00000   0.00000   123:    my ($p, $k) = $m->__set_path( @_ );
        0   0.00000   0.00000   124:    return unless defined $p && defined $k;
        0   0.00000   0.00000   125:    my $l = defined $k->[-1] ? $k->[-1] : "";
        0   0.00000   0.00000   126:    return $m->__set_path_node( $p, $l, @_ );
        0   0.00000   0.00000   127:}
        0   0.00000   0.00000   128:
        0   0.00000   0.00000   129:sub get_multi_ids {
        0   0.00000   0.00000   130:    my $m = shift;
        0   0.00000   0.00000   131:    my $f = $m->[ _f ];
        0   0.00000   0.00000   132:    return () unless ($f & _MULTI);
        0   0.00000   0.00000   133:    my ($e, $n) = $m->__get_path_node( @_ );
        0   0.00000   0.00000   134:    return $e ? keys %{ $n->[ _nm ] } : ();
        0   0.00000   0.00000   135:}
        0   0.00000   0.00000   136:
        0   0.00000   0.00000   137:sub _has_path_attrs {
        0   0.00000   0.00000   138:    my $m = shift;
        0   0.00000   0.00000   139:    my $f = $m->[ _f ];
        0   0.00000   0.00000   140:    my $id = pop if ($f & _MULTI);
        0   0.00000   0.00000   141:    @_ = sort @_ if ($f & _UNORD);
        0   0.00000   0.00000   142:    $m->__attr( \@_ );
        0   0.00000   0.00000   143:    if (($f & _MULTI)) {
        0   0.00000   0.00000   144: my ($p, $k) = $m->__has_path( @_ );
        0   0.00000   0.00000   145: return unless defined $p && defined $k;
        0   0.00000   0.00000   146: my $l = defined $k->[-1] ? $k->[-1] : "";
        0   0.00000   0.00000   147: return keys %{ $p->[-1]->{ $l }->[ _nm ]->{
        0   0.00000   0.00000   148:    } else {
        0   0.00000   0.00000   149: my ($e, $n) = $m->__get_path_node( @_ );
        0   0.00000   0.00000   150: return undef unless $e;
        0   0.00000   0.00000   151: return ref $n && $#$n == _na && keys %{ $n-
        0   0.00000   0.00000   152:    }
        0   0.00000   0.00000   153:}
        0   0.00000   0.00000   154:
        0   0.00000   0.00000   155:sub _set_path_attrs {
        0   0.00000   0.00000   156:    my $m = shift;
        0   0.00000   0.00000   157:    my $f = $m->[ _f ];
        0   0.00000   0.00000   158:    my $attr = pop;
        0   0.00000   0.00000   159:    my $id   = pop if ($f & _MULTI);
        0   0.00000   0.00000   160:    @_ = sort @_ if ($f & _UNORD);
        0   0.00000   0.00000   161:    $m->__attr( @_ );
        0   0.00000   0.00000   162:    push @_, $id if ($f & _MULTI);
        0   0.00000   0.00000   163:    my ($p, $k) = $m->__set_path( @_ );
        0   0.00000   0.00000   164:    return unless defined $p && defined $k;
        0   0.00000   0.00000   165:    my $l = defined $k->[-1] ? $k->[-1] : "";
        0   0.00000   0.00000   166:    $m->__set_path_node( $p, $l, @_ ) unless
        0   0.00000   0.00000   167:    if (($f & _MULTI)) {
        0   0.00000   0.00000   168: $p->[-1]->{ $l }->[ _nm ]->{ $id } = $attr;
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap.pm Page 119
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   169:    } else {
        0   0.00000   0.00000   170: # Extend the node if it is a simple id node.
        0   0.00000   0.00000   171: $p->[-1]->{ $l } = [ $p->[-1]->{ $l }, 1 ]
        0   0.00000   0.00000   172: $p->[-1]->{ $l }->[ _na ] = $attr;
        0   0.00000   0.00000   173:    }
        0   0.00000   0.00000   174:}
        0   0.00000   0.00000   175:
        0   0.00000   0.00000   176:sub _has_path_attr {
      124   0.00001   0.00000   177:    my $m = shift;
      124   0.00000   0.00000   178:    my $f = $m->[ _f ];
      124   0.00000   0.00000   179:    my $attr = pop;
      124   0.00000   0.01000   180:    my $id   = pop if ($f & _MULTI);
      124   0.00000   0.00000   181:    @_ = sort @_ if ($f & _UNORD);
      124   0.00010   0.00000   182:    $m->__attr( \@_ );
      124   0.00002   0.00000   183:    if (($f & _MULTI)) {
        0   0.00000   0.00000   184: my ($p, $k) = $m->__has_path( @_ );
        0   0.00000   0.00000   185: return unless defined $p && defined $k;
        0   0.00000   0.00000   186: my $l = defined $k->[-1] ? $k->[-1] : "";
        0   0.00000   0.00000   187: exists $p->[-1]->{ $l }->[ _nm ]->{ $id }->{
        0   0.00000   0.00000   188:    } else {
      124   0.00000   0.00000   189: my ($e, $n) = $m->__get_path_node( @_ );
      124   0.00000   0.00000   190: return undef unless $e;
      124   0.00003   0.01000   191: return ref $n && $#$n == _na ? exists $n->[
        0   0.00000   0.00000   192:    }
        0   0.00000   0.00000   193:}
        0   0.00000   0.00000   194:
        0   0.00000   0.00000   195:sub _set_path_attr {
     2546   0.00045   0.02000   196:    my $m = shift;
     2546   0.00135   0.01000   197:    my $f = $m->[ _f ];
     2546   0.00052   0.03000   198:    my $val  = pop;
     2546   0.00047   0.03000   199:    my $attr = pop;
     2546   0.00049   0.02000   200:    my $id   = pop if ($f & _MULTI);
     2546   0.00013   0.02000   201:    @_ = sort @_ if ($f & _UNORD);
     2546   0.00046   0.00000   202:    my ($p, $k);
     2546   0.00005   0.03000   203:    $m->__attr( \@_ ); # _LIGHT maps need
     2546   0.00047   0.04000   204:    push @_, $id if ($f & _MULTI);
     2546   0.00005   0.02000   205:    @_ = sort @_ if ($f & _UNORD);
     2546   0.00004   0.05000   206:    if ($m->[ _a ] == 2 && @_ == 2 && !($f &
      828   0.00000   0.00000   207: $m->[ _s ]->{ $_[0] } ||= { };
      828   0.00001   0.01000   208: $p = [ $m->[ _s ], $m->[ _s ]->{ $_[0] } ];
      828   0.00003   0.00000   209: $k = [ $_[0], $_[1] ];
        0   0.00000   0.00000   210:    } else {
     1718   0.00883   0.02000   211: ($p, $k) = $m->__set_path( @_ );
        0   0.00000   0.00000   212:    }
     2546   0.00405   0.03000   213:    return unless defined $p && defined $k;
     2546   0.00019   0.06000   214:    my $l = defined $k->[-1] ? $k->[-1] : "";
     2546   0.00006   0.02000   215:    $m->__set_path_node( $p, $l, @_ ) unless
     2546   0.00691   0.02000   216:    if (($f & _MULTI)) {
        0   0.00000   0.00000   217: $p->[-1]->{ $l }->[ _nm ]->{ $id }->{ $attr
        0   0.00000   0.00000   218:    } else {
        0   0.00000   0.00000   219: # Extend the node if it is a simple id node.
     2546   0.00050   0.02000   220: $p->[-1]->{ $l } = [ $p->[-1]->{ $l }, 1 ]
     2546   0.00229   0.02000   221: $p->[-1]->{ $l }->[ _na ]->{ $attr } = $val;
        0   0.00000   0.00000   222:    }
     2546   0.00028   0.02000   223:    return $val;
        0   0.00000   0.00000   224:}
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap.pm Page 120
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   225:
        0   0.00000   0.00000   226:sub _get_path_attrs {
        0   0.00000   0.00000   227:    my $m = shift;
        0   0.00000   0.00000   228:    my $f = $m->[ _f ];
        0   0.00000   0.00000   229:    my $id   = pop if ($f & _MULTI);
        0   0.00000   0.00000   230:    @_ = sort @_ if ($f & _UNORD);
        0   0.00000   0.00000   231:    $m->__attr( \@_ );
        0   0.00000   0.00000   232:    if (($f & _MULTI)) {
        0   0.00000   0.00000   233: my ($p, $k) = $m->__has_path( @_ );
        0   0.00000   0.00000   234: return unless defined $p && defined $k;
        0   0.00000   0.00000   235: my $l = defined $k->[-1] ? $k->[-1] : "";
        0   0.00000   0.00000   236: $p->[-1]->{ $l }->[ _nm ]->{ $id };
        0   0.00000   0.00000   237:    } else {
        0   0.00000   0.00000   238: my ($e, $n) = $m->__get_path_node( @_ );
        0   0.00000   0.00000   239: return unless $e;
        0   0.00000   0.00000   240: return $n->[ _na ] if ref $n && $#$n == _na;
        0   0.00000   0.00000   241: return;
        0   0.00000   0.00000   242:    }
        0   0.00000   0.00000   243:}
        0   0.00000   0.00000   244:
        0   0.00000   0.00000   245:sub _get_path_attr {
     6866   0.00051   0.04000   246:    my $m = shift;
     6866   0.00262   0.05000   247:    my $f = $m->[ _f ];
     6866   0.00125   0.09000   248:    my $attr = pop;
     6866   0.00055   0.05000   249:    my $id = pop if ($f & _MULTI);
     6866   0.00121   0.08000   250:    @_ = sort @_ if ($f & _UNORD);
     6866   0.00150   0.07000   251:    $m->__attr( \@_ );
     6866   0.00050   0.02000   252:    if (($f & _MULTI)) {
        0   0.00000   0.00000   253: my ($p, $k) = $m->__has_path( @_ );
        0   0.00000   0.00000   254: return unless defined $p && defined $k;
        0   0.00000   0.00000   255: my $l = defined $k->[-1] ? $k->[-1] : "";
        0   0.00000   0.00000   256: return $p->[-1]->{ $l }->[ _nm ]->{ $id }->{
        0   0.00000   0.00000   257:    } else {
     6866   0.00098   0.03000   258: my ($e, $n) = $m->__get_path_node( @_ );
     6866   0.00186   0.08000   259: return undef unless $e;
     6866   0.00230   0.10000   260: return ref $n && $#$n == _na ? $n->[ _na ]-
        0   0.00000   0.00000   261:    }
        0   0.00000   0.00000   262:}
        0   0.00000   0.00000   263:
        0   0.00000   0.00000   264:sub _get_path_attr_names {
        0   0.00000   0.00000   265:    my $m = shift;
        0   0.00000   0.00000   266:    my $f = $m->[ _f ];
        0   0.00000   0.00000   267:    my $id = pop if ($f & _MULTI);
        0   0.00000   0.00000   268:    @_ = sort @_ if ($f & _UNORD);
        0   0.00000   0.00000   269:    $m->__attr( \@_ );
        0   0.00000   0.00000   270:    if (($f & _MULTI)) {
        0   0.00000   0.00000   271: my ($p, $k) = $m->__has_path( @_ );
        0   0.00000   0.00000   272: return unless defined $p && defined $k;
        0   0.00000   0.00000   273: my $l = defined $k->[-1] ? $k->[-1] : "";
        0   0.00000   0.00000   274: keys %{ $p->[-1]->{ $l }->[ _nm ]->{ $id }
        0   0.00000   0.00000   275:    } else {
        0   0.00000   0.00000   276: my ($e, $n) = $m->__get_path_node( @_ );
        0   0.00000   0.00000   277: return undef unless $e;
        0   0.00000   0.00000   278: return keys %{ $n->[ _na ] } if ref $n &&
        0   0.00000   0.00000   279: return;
        0   0.00000   0.00000   280:    }
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap.pm Page 121
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   281:}
        0   0.00000   0.00000   282:
        0   0.00000   0.00000   283:sub _get_path_attr_values {
        0   0.00000   0.00000   284:    my $m = shift;
        0   0.00000   0.00000   285:    my $f = $m->[ _f ];
        0   0.00000   0.00000   286:    my $id = pop if ($f & _MULTI);
        0   0.00000   0.00000   287:    @_ = sort @_ if ($f & _UNORD);
        0   0.00000   0.00000   288:    $m->__attr( \@_ );
        0   0.00000   0.00000   289:    if (($f & _MULTI)) {
        0   0.00000   0.00000   290: my ($p, $k) = $m->__has_path( @_ );
        0   0.00000   0.00000   291: return unless defined $p && defined $k;
        0   0.00000   0.00000   292: my $l = defined $k->[-1] ? $k->[-1] : "";
        0   0.00000   0.00000   293: values %{ $p->[-1]->{ $l }->[ _nm ]->{ $id }
        0   0.00000   0.00000   294:    } else {
        0   0.00000   0.00000   295: my ($e, $n) = $m->__get_path_node( @_ );
        0   0.00000   0.00000   296: return undef unless $e;
        0   0.00000   0.00000   297: return values %{ $n->[ _na ] } if ref $n &&
        0   0.00000   0.00000   298: return;
        0   0.00000   0.00000   299:    }
        0   0.00000   0.00000   300:}
        0   0.00000   0.00000   301:
        0   0.00000   0.00000   302:sub _del_path_attrs {
        0   0.00000   0.00000   303:    my $m = shift;
        0   0.00000   0.00000   304:    my $f = $m->[ _f ];
        0   0.00000   0.00000   305:    my $id = pop if ($f & _MULTI);
        0   0.00000   0.00000   306:    @_ = sort @_ if ($f & _UNORD);
        0   0.00000   0.00000   307:    $m->__attr( \@_ );
        0   0.00000   0.00000   308:    if (($f & _MULTI)) {
        0   0.00000   0.00000   309: my ($p, $k) = $m->__has_path( @_ );
        0   0.00000   0.00000   310: return unless defined $p && defined $k;
        0   0.00000   0.00000   311: my $l = defined $k->[-1] ? $k->[-1] : "";
        0   0.00000   0.00000   312: delete $p->[-1]->{ $l }->[ _nm ]->{ $id };
        0   0.00000   0.00000   313: unless (keys %{ $p->[-1]->{ $l }->[ _nm ] }
        0   0.00000   0.00000   314:  (defined $p->[-1]->{ $l }->[ _na ] &&
        0   0.00000   0.00000   315:   keys %{ $p->[-1]->{ $l }->[ _na ] })) {
        0   0.00000   0.00000   316:     delete $p->[-1]->{ $l };
        0   0.00000   0.00000   317: }
        0   0.00000   0.00000   318:    } else {
        0   0.00000   0.00000   319: my ($e, $n) = $m->__get_path_node( @_ );
        0   0.00000   0.00000   320: return undef unless $e;
        0   0.00000   0.00000   321: if (ref $n) {
        0   0.00000   0.00000   322:     $e = _na == $#$n && keys %{ $n->[ _na ]
        0   0.00000   0.00000   323:     $#$n = _na - 1;
        0   0.00000   0.00000   324:     return $e;
        0   0.00000   0.00000   325: } else {
        0   0.00000   0.00000   326:     return 0;
        0   0.00000   0.00000   327: }
        0   0.00000   0.00000   328:    }
        0   0.00000   0.00000   329:}
        0   0.00000   0.00000   330:
        0   0.00000   0.00000   331:sub _del_path_attr {
        0   0.00000   0.00000   332:    my $m = shift;
        0   0.00000   0.00000   333:    my $f = $m->[ _f ];
        0   0.00000   0.00000   334:    my $attr = pop;
        0   0.00000   0.00000   335:    my $id = pop if ($f & _MULTI);
        0   0.00000   0.00000   336:    @_ = sort @_ if ($f & _UNORD);
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap.pm Page 122
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   337:    $m->__attr( \@_ );
        0   0.00000   0.00000   338:    if (($f & _MULTI)) {
        0   0.00000   0.00000   339: my ($p, $k) = $m->__has_path( @_ );
        0   0.00000   0.00000   340: return unless defined $p && defined $k;
        0   0.00000   0.00000   341: my $l = defined $k->[-1] ? $k->[-1] : "";
        0   0.00000   0.00000   342: delete $p->[-1]->{ $l }->[ _nm ]->{ $id }->{
        0   0.00000   0.00000   343: $m->_del_path_attrs( @_, $id )
        0   0.00000   0.00000   344:     unless keys %{ $p->[-1]->{ $l }->[ _nm
        0   0.00000   0.00000   345:    } else {
        0   0.00000   0.00000   346: my ($e, $n) = $m->__get_path_node( @_ );
        0   0.00000   0.00000   347: return undef unless $e;
        0   0.00000   0.00000   348: if (ref $n && $#$n == _na && exists $n->[
        0   0.00000   0.00000   349:     delete $n->[ _na ]->{ $attr };
        0   0.00000   0.00000   350:     return 1;
        0   0.00000   0.00000   351: } else {
        0   0.00000   0.00000   352:     return 0;
        0   0.00000   0.00000   353: }
        0   0.00000   0.00000   354:    }
        0   0.00000   0.00000   355:}
        0   0.00000   0.00000   356:
       44   0.00000   0.00000   357:sub _is_COUNT { $_[0]->[ _f ] & _COUNT }
    11190   0.00295   0.16000   358:sub _is_MULTI { $_[0]->[ _f ] & _MULTI }
     2538   0.00048   0.03000   359:sub _is_HYPER { $_[0]->[ _f ] & _HYPER }
      944   0.00046   0.01000   360:sub _is_UNORD { $_[0]->[ _f ] & _UNORD }
        0   0.00000   0.00000   361:sub _is_UNIQ  { $_[0]->[ _f ] & _UNIQ  }
        0   0.00000   0.00000   362:sub _is_REF   { $_[0]->[ _f ] & _REF   }
        0   0.00000   0.00000   363:
        0   0.00000   0.00000   364:sub __arg {
        0   0.00000   0.00000   365:    my $m = shift;
        0   0.00000   0.00000   366:    my $f = $m->[ _f ];
        0   0.00000   0.00000   367:    my @a = @{$_[0]};
        0   0.00000   0.00000   368:    if ($f & _UNIQ) {
        0   0.00000   0.00000   369: my %u;
        0   0.00000   0.00000   370: if ($f & _UNORD) {
        0   0.00000   0.00000   371:     @u{ @a } = @a;
        0   0.00000   0.00000   372:     @a = values %u;
        0   0.00000   0.00000   373: } else {
        0   0.00000   0.00000   374:     my @u;
        0   0.00000   0.00000   375:     for my $e (@a) {
        0   0.00000   0.00000   376:  push @u, $e if $u{$e}++ == 0;
        0   0.00000   0.00000   377:     }
        0   0.00000   0.00000   378:     @a = @u;
        0   0.00000   0.00000   379: }
        0   0.00000   0.00000   380:    }
        0   0.00000   0.00000   381:    # Alphabetic or numeric sort, does not
        0   0.00000   0.00000   382:    @{$_[0]} = ($f & _UNORD) ? sort @a : @a;
        0   0.00000   0.00000   383:}
        0   0.00000   0.00000   384:
        0   0.00000   0.00000   385:sub _successors {
      936   0.00047   0.01000   386:    my $E = shift;
      936   0.00046   0.00000   387:    my $g = shift;
      936   0.00008   0.00000   388:    my $V = $g->[ _V ];
     3112   0.00050   0.01000   389:    map { my @v = @{ $_->[ 1 ] };
     2176   0.00046   0.04000   390:   shift @v;
     4352   0.00096   0.02000   391:   map { $V->_get_id_path($_) } @v } $g-
        0   0.00000   0.00000   392:}
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap.pm Page 123
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   393:
        0   0.00000   0.00000   394:sub _predecessors {
        0   0.00000   0.00000   395:    my $E = shift;
        0   0.00000   0.00000   396:    my $g = shift;
        0   0.00000   0.00000   397:    my $V = $g->[ _V ];
        0   0.00000   0.00000   398:    if (wantarray) {
        0   0.00000   0.00000   399: map { my @v = @{ $_->[ 1 ] };
        0   0.00000   0.00000   400:       pop @v;
        0   0.00000   0.00000   401:       map { $V->_get_id_path($_) } @v } $g-
        0   0.00000   0.00000   402:    } else {
        0   0.00000   0.00000   403: return $g->_edges_to( @_ );
        0   0.00000   0.00000   404:    }
        0   0.00000   0.00000   405:}
        0   0.00000   0.00000   406:
        0   0.00000   0.00000   407:1;
        0   0.00000   0.00000   408:__END__
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap/He Page 124
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:package Graph::AdjacencyMap::Heavy;
        0   0.00000   0.00000     2:
        0   0.00000   0.00000     3:# THIS IS INTERNAL IMPLEMENTATION ONLY, NOT
        0   0.00000   0.00000     4:# THE INTERFACE IS HARD TO USE AND GOING TO
        0   0.00000   0.00000     5:# ALMOST GUARANTEED TO CHANGE OR GO AWAY IN
        0   0.00000   0.00000     6:
        0   0.00000   0.00000     7:use strict;
        0   0.00000   0.00000     8:
        0   0.00000   0.00000     9:# $SIG{__DIE__ } = sub { use Carp; confess };
        0   0.00000   0.00000    10:# $SIG{__WARN__} = sub { use Carp; confess };
        0   0.00000   0.00000    11:
        0   0.00000   0.00000    12:use Graph::AdjacencyMap qw(:flags :fields);
        0   0.00000   0.00000    13:use base 'Graph::AdjacencyMap';
        0   0.00000   0.00000    14:
        0   0.00000   0.00000    15:require overload; # for de-overloading
        0   0.00000   0.00000    16:
        0   0.00000   0.00000    17:require Data::Dumper;
        0   0.00000   0.00000    18:
        0   0.00000   0.00000    19:sub __set_path {
      952   0.00743   0.02000    20:    my $m = shift;
      952   0.00002   0.00000    21:    my $f = $m->[ _f ];
      952   0.00005   0.02000    22:    my $id = pop if ($f & _MULTI);
      952   0.00001   0.01000    23:    if (@_ != $m->[ _a ] && !($f & _HYPER)) {
        0   0.00000   0.00000    24: require Carp;
        0   0.00000   0.00000    25: Carp::confess(sprintf
        0   0.00000   0.00000    26:        scalar @_, $m->[ _a ]);
        0   0.00000   0.00000    27:    }
      952   0.00002   0.02000    28:    my $p;
      952   0.00026   0.02000    29:    $p = ($f & _HYPER) ?
        0   0.00000   0.00000    30: (( $m->[ _s ] ||= [ ] )->[ @_ ] ||= { }) :
        0   0.00000   0.00000    31: (  $m->[ _s ]                   ||= { });
      952   0.00026   0.02000    32:    my @p = $p;
      952   0.00001   0.00000    33:    my @k;
      952   0.00001   0.02000    34:    while (@_) {
     1904   0.00003   0.00000    35: my $k = shift;
     1904   0.00001   0.02000    36: my $q = ref $k && ($f & _REF) &&
     1904   0.00013   0.00000    37: if (@_) {
      952   0.00045   0.00000    38:     $p = $p->{ $q } ||= {};
      952   0.00001   0.03000    39:     return unless $p;
      952   0.00001   0.00000    40:     push @p, $p;
        0   0.00000   0.00000    41: }
     1904   0.00063   0.02000    42: push @k, $q;
        0   0.00000   0.00000    43:    }
      952   0.00002   0.02000    44:    return (\@p, \@k);
        0   0.00000   0.00000    45:}
        0   0.00000   0.00000    46:
        0   0.00000   0.00000    47:sub __set_path_node {
      890   0.00046   0.00000    48:    my ($m, $p, $l) = splice @_, 0, 3;
      890   0.00000   0.00000    49:    my $f = $m->[ _f ] ;
      890   0.00001   0.01000    50:    my $id = pop if ($f & _MULTI);
      890   0.00001   0.00000    51:    unless (exists $p->[-1]->{ $l }) {
      890   0.00004   0.01000    52: my $i = $m->_new_node( \$p->[-1]->{ $l },
      890   0.00050   0.00000    53: $m->[ _i ]->{ defined $i ? $i : "" } = [ @_
      890   0.00002   0.02000    54:        return defined $id ? ($id eq _GEN_ID
        0   0.00000   0.00000    55:    } else {
        0   0.00000   0.00000    56: return $m->_inc_node( \$p->[-1]->{ $l }, $id
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap/He Page 125
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000    57:    }
        0   0.00000   0.00000    58:}
        0   0.00000   0.00000    59:
        0   0.00000   0.00000    60:sub set_path {
      890   0.00001   0.01000    61:    my $m = shift;
      890   0.00001   0.00000    62:    my $f = $m->[ _f ];
      890   0.00001   0.00000    63:    if (@_ > 1 && ($f & _UNORDUNIQ)) {
        0   0.00000   0.00000    64: if (($f & _UNORDUNIQ) == _UNORD && @_ == 2)
        0   0.00000   0.00000    65:        else { $m->__arg(\@_) }
        0   0.00000   0.00000    66:    }
      890   0.00049   0.00000    67:    my ($p, $k) = $m->__set_path( @_ );
      890   0.00047   0.02000    68:    return unless defined $p && defined $k;
      890   0.00001   0.01000    69:    my $l = defined $k->[-1] ? $k->[-1] : "";
      890   0.00053   0.01000    70:    return $m->__set_path_node( $p, $l, @_ );
        0   0.00000   0.00000    71:}
        0   0.00000   0.00000    72:
        0   0.00000   0.00000    73:sub __has_path {
     2610   0.00055   0.04000    74:    my $m = shift;
     2610   0.00049   0.03000    75:    my $f = $m->[ _f ];
     2610   0.00054   0.02000    76:    if (@_ != $m->[ _a ] && !($f & _HYPER)) {
        0   0.00000   0.00000    77: require Carp;
        0   0.00000   0.00000    78: Carp::confess(sprintf
        0   0.00000   0.00000    79:        scalar @_, $m->[ _a ]);
        0   0.00000   0.00000    80:    }
     2610   0.00004   0.03000    81:    if (@_ > 1 && ($f & _UNORDUNIQ)) {
        0   0.00000   0.00000    82: if (($f & _UNORDUNIQ) == _UNORD && @_ == 2)
        0   0.00000   0.00000    83:        else { $m->__arg(\@_) }
        0   0.00000   0.00000    84:    }
     2610   0.00048   0.00000    85:    my $p = $m->[ _s ];
     2610   0.00074   0.04000    86:    return unless defined $p;
     2610   0.00001   0.01000    87:    $p = $p->[ @_ ] if ($f & _HYPER);
     2610   0.00046   0.00000    88:    return unless defined $p;
     2610   0.00048   0.05000    89:    my @p = $p;
     2610   0.00048   0.01000    90:    my @k;
     2610   0.00049   0.04000    91:    while (@_) {
     5220   0.00105   0.02000    92: my $k = shift;
     5220   0.00052   0.02000    93: my $q = ref $k && ($f & _REF) &&
     5220   0.00059   0.04000    94: if (@_) {
     2610   0.00049   0.03000    95:     $p = $p->{ $q };
     2610   0.00050   0.02000    96:     return unless defined $p;
     2610   0.00012   0.03000    97:     push @p, $p;
        0   0.00000   0.00000    98: }
     5220   0.00108   0.03000    99: push @k, $q;
        0   0.00000   0.00000   100:    }
     2610   0.00007   0.01000   101:    return (\@p, \@k);
        0   0.00000   0.00000   102:}
        0   0.00000   0.00000   103:
        0   0.00000   0.00000   104:sub has_path {
        0   0.00000   0.00000   105:    my $m = shift;
        0   0.00000   0.00000   106:    my $f = $m->[ _f ];
        0   0.00000   0.00000   107:    if (@_ > 1 && ($f & _UNORDUNIQ)) {
        0   0.00000   0.00000   108: if (($f & _UNORDUNIQ) == _UNORD && @_ == 2)
        0   0.00000   0.00000   109:        else { $m->__arg(\@_) }
        0   0.00000   0.00000   110:    }
        0   0.00000   0.00000   111:    my ($p, $k) = $m->__has_path( @_ );
        0   0.00000   0.00000   112:    return unless defined $p && defined $k;
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap/He Page 126
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   113:    return exists $p->[-1]->{ defined $k->[-
        0   0.00000   0.00000   114:}
        0   0.00000   0.00000   115:
        0   0.00000   0.00000   116:sub has_path_by_multi_id {
        0   0.00000   0.00000   117:    my $m = shift;
        0   0.00000   0.00000   118:    my $f = $m->[ _f ];
        0   0.00000   0.00000   119:    my $id = pop;
        0   0.00000   0.00000   120:    if (@_ > 1 && ($f & _UNORDUNIQ)) {
        0   0.00000   0.00000   121: if (($f & _UNORDUNIQ) == _UNORD && @_ == 2)
        0   0.00000   0.00000   122:        else { $m->__arg(\@_) }
        0   0.00000   0.00000   123:    }
        0   0.00000   0.00000   124:    my ($e, $n) = $m->__get_path_node( @_ );
        0   0.00000   0.00000   125:    return undef unless $e;
        0   0.00000   0.00000   126:    return exists $n->[ _nm ]->{ $id };
        0   0.00000   0.00000   127:}
        0   0.00000   0.00000   128:
        0   0.00000   0.00000   129:sub _get_path_node {
     1336   0.00053   0.02000   130:    my $m = shift;
     1336   0.00003   0.00000   131:    my $f = $m->[ _f ];
     1336   0.00001   0.02000   132:    if ($m->[ _a ] == 2 && @_ == 2 && !($f &
        0   0.00000   0.00000   133: @_ = sort @_ if ($f & _UNORD);
        0   0.00000   0.00000   134: return unless exists $m->[ _s ]->{ $_[0] };
        0   0.00000   0.00000   135: my $p = [ $m->[ _s ], $m->[ _s ]->{ $_[0] }
        0   0.00000   0.00000   136: my $k = [ $_[0], $_[1] ];
        0   0.00000   0.00000   137: my $l = $_[1];
        0   0.00000   0.00000   138: return ( exists $p->[-1]->{ $l }, $p->[-1]-
        0   0.00000   0.00000   139:    } else {
     1336   0.00006   0.01000   140: if (@_ > 1 && ($f & _UNORDUNIQ)) {
        0   0.00000   0.00000   141:     if (($f & _UNORDUNIQ) == _UNORD && @_ ==
        0   0.00000   0.00000   142:     else { $m->__arg(\@_) }
        0   0.00000   0.00000   143: }
     1336   0.00005   0.03000   144: $m->__get_path_node( @_ );
        0   0.00000   0.00000   145:    }
        0   0.00000   0.00000   146:}
        0   0.00000   0.00000   147:
        0   0.00000   0.00000   148:sub _get_path_id {
     1336   0.00048   0.00000   149:    my $m = shift;
     1336   0.00026   0.01000   150:    my $f = $m->[ _f ];
     1336   0.00003   0.02000   151:    my ($e, $n);
     1336   0.00043   0.02000   152:    if ($m->[ _a ] == 2 && @_ == 2 && !($f &
        0   0.00000   0.00000   153: @_ = sort @_ if ($f & _UNORD);
        0   0.00000   0.00000   154: return unless exists $m->[ _s ]->{ $_[0] };
        0   0.00000   0.00000   155: my $p = $m->[ _s ]->{ $_[0] };
        0   0.00000   0.00000   156: $e = exists $p->{ $_[1] };
        0   0.00000   0.00000   157: $n = $p->{ $_[1] };
        0   0.00000   0.00000   158:    } else {
     1336   0.00048   0.02000   159: ($e, $n) = $m->_get_path_node( @_ );
        0   0.00000   0.00000   160:    }
     1336   0.00001   0.01000   161:    return undef unless $e;
     1336   0.00024   0.02000   162:    return ref $n ? $n->[ _ni ] : $n;
        0   0.00000   0.00000   163:}
        0   0.00000   0.00000   164:
        0   0.00000   0.00000   165:sub _get_path_count {
        0   0.00000   0.00000   166:    my $m = shift;
        0   0.00000   0.00000   167:    my $f = $m->[ _f ];
        0   0.00000   0.00000   168:    my ($e, $n) = $m->_get_path_node( @_ );
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap/He Page 127
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   169:    return undef unless $e && defined $n;
        0   0.00000   0.00000   170:    return
        0   0.00000   0.00000   171: ($f & _COUNT) ? $n->[ _nc ] :
        0   0.00000   0.00000   172: ($f & _MULTI) ? scalar keys %{ $n->[ _nm ] }
        0   0.00000   0.00000   173:}
        0   0.00000   0.00000   174:
        0   0.00000   0.00000   175:sub __attr {
     2164   0.00047   0.02000   176:    my $m = shift;
     2164   0.00012   0.00000   177:    if (@_) {
     2164   0.00068   0.02000   178: if (ref $_[0] && @{ $_[0] }) {
     2164   0.00076   0.00000   179:     if (@{ $_[0] } != $m->[ _a ]) {
        0   0.00000   0.00000   180:  require Carp;
        0   0.00000   0.00000   181:  Carp::confess(sprintf
        0   0.00000   0.00000   182:         "Graph::AdjacencyMap::Heavy:
        0   0.00000   0.00000   183:         scalar @{ $_[0] }, $m->[ _a ]);
        0   0.00000   0.00000   184:     }
     2164   0.00001   0.00000   185:     my $f = $m->[ _f ];
     2164   0.00161   0.07000   186:     if (@{ $_[0] } > 1 && ($f & _UNORDUNIQ))
        0   0.00000   0.00000   187:  if (($f & _UNORDUNIQ) == _UNORD && @{ $_[0]
        0   0.00000   0.00000   188:      @{ $_[0] } = sort @{ $_[0] }
        0   0.00000   0.00000   189:  } else { $m->__arg(\@_) }
        0   0.00000   0.00000   190:     }
        0   0.00000   0.00000   191: }
        0   0.00000   0.00000   192:    }
        0   0.00000   0.00000   193:}
        0   0.00000   0.00000   194:
        0   0.00000   0.00000   195:sub _get_id_path {
        0   0.00000   0.00000   196:    my ($m, $i) = @_;
        0   0.00000   0.00000   197:    my $p = defined $i ? $m->[ _i ]->{ $i } :
        0   0.00000   0.00000   198:    return defined $p ? @$p : ( );
        0   0.00000   0.00000   199:}
        0   0.00000   0.00000   200:
        0   0.00000   0.00000   201:sub del_path {
        0   0.00000   0.00000   202:    my $m = shift;
        0   0.00000   0.00000   203:    my $f = $m->[ _f ];
        0   0.00000   0.00000   204:    if (@_ > 1 && ($f & _UNORDUNIQ)) {
        0   0.00000   0.00000   205: if (($f & _UNORDUNIQ) == _UNORD && @_ == 2)
        0   0.00000   0.00000   206:        else { $m->__arg(\@_) }
        0   0.00000   0.00000   207:    }
        0   0.00000   0.00000   208:    my ($e, $n, $p, $k, $l) = $m-
        0   0.00000   0.00000   209:    return unless $e;
        0   0.00000   0.00000   210:    my $c = ($f & _COUNT) ? --$n->[ _nc ] :
        0   0.00000   0.00000   211:    if ($c == 0) {
        0   0.00000   0.00000   212: delete $m->[ _i ]->{ ref $n ? $n->[ _ni ] :
        0   0.00000   0.00000   213: delete $p->[-1]->{ $l };
        0   0.00000   0.00000   214: while (@$p && @$k && keys %{ $p->[-1]->{ $k-
        0   0.00000   0.00000   215:     delete $p->[-1]->{ $k->[-1] };
        0   0.00000   0.00000   216:     pop @$p;
        0   0.00000   0.00000   217:     pop @$k;
        0   0.00000   0.00000   218: }
        0   0.00000   0.00000   219:    }
        0   0.00000   0.00000   220:    return 1;
        0   0.00000   0.00000   221:}
        0   0.00000   0.00000   222:
        0   0.00000   0.00000   223:sub del_path_by_multi_id {
        0   0.00000   0.00000   224:    my $m = shift;
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap/He Page 128
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   225:    my $f = $m->[ _f ];
        0   0.00000   0.00000   226:    my $id = pop;
        0   0.00000   0.00000   227:    if (@_ > 1 && ($f & _UNORDUNIQ)) {
        0   0.00000   0.00000   228: if (($f & _UNORDUNIQ) == _UNORD && @_ == 2)
        0   0.00000   0.00000   229:        else { $m->__arg(\@_) }
        0   0.00000   0.00000   230:    }
        0   0.00000   0.00000   231:    my ($e, $n, $p, $k, $l) = $m-
        0   0.00000   0.00000   232:    return unless $e;
        0   0.00000   0.00000   233:    delete $n->[ _nm ]->{ $id };
        0   0.00000   0.00000   234:    unless (keys %{ $n->[ _nm ] }) {
        0   0.00000   0.00000   235: delete $m->[ _i ]->{ $n->[ _ni ] };
        0   0.00000   0.00000   236: delete $p->[-1]->{ $l };
        0   0.00000   0.00000   237: while (@$p && @$k && keys %{ $p->[-1]->{ $k-
        0   0.00000   0.00000   238:     delete $p->[-1]->{ $k->[-1] };
        0   0.00000   0.00000   239:     pop @$p;
        0   0.00000   0.00000   240:     pop @$k;
        0   0.00000   0.00000   241: }
        0   0.00000   0.00000   242:    }
        0   0.00000   0.00000   243:    return 1;
        0   0.00000   0.00000   244:}
        0   0.00000   0.00000   245:
        0   0.00000   0.00000   246:sub paths {
       44   0.00000   0.00000   247:    my $m = shift;
       44   0.00011   0.00000   248:    return values %{ $m->[ _i ] } if defined
        0   0.00000   0.00000   249:    wantarray ? ( ) : 0;
        0   0.00000   0.00000   250:}
        0   0.00000   0.00000   251:
        0   0.00000   0.00000   252:1;
        0   0.00000   0.00000   253:__END__
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap/Li Page 129
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:package Graph::AdjacencyMap::Light;
        0   0.00000   0.00000     2:
        0   0.00000   0.00000     3:# THIS IS INTERNAL IMPLEMENTATION ONLY, NOT
        0   0.00000   0.00000     4:# THE INTERFACE IS HARD TO USE AND GOING TO
        0   0.00000   0.00000     5:# ALMOST GUARANTEED TO CHANGE OR GO AWAY IN
        0   0.00000   0.00000     6:
        0   0.00000   0.00000     7:use strict;
        0   0.00000   0.00000     8:
        0   0.00000   0.00000     9:use Graph::AdjacencyMap qw(:flags :fields);
        0   0.00000   0.00000    10:use base 'Graph::AdjacencyMap';
        0   0.00000   0.00000    11:
        0   0.00000   0.00000    12:use Scalar::Util qw(weaken);
        0   0.00000   0.00000    13:
        0   0.00000   0.00000    14:use Graph::AdjacencyMap::Heavy;
        0   0.00000   0.00000    15:use Graph::AdjacencyMap::Vertex;
        0   0.00000   0.00000    16:
        0   0.00000   0.00000    17:sub _V () { 2 } # Graph::_V
        0   0.00000   0.00000    18:sub _E () { 3 } # Graph::_E
        0   0.00000   0.00000    19:sub _F () { 0 } # Graph::_F
        0   0.00000   0.00000    20:
        0   0.00000   0.00000    21:sub _new {
      112   0.00001   0.01000    22:    my ($class, $graph, $flags, $arity) = @_;
      112   0.00002   0.00000    23:    my $m = bless [ ], $class;
      112   0.00000   0.00000    24:    $m->[ _n ] = 0;
      112   0.00001   0.00000    25:    $m->[ _f ] = $flags | _LIGHT;
      112   0.00000   0.00000    26:    $m->[ _a ] = $arity;
      112   0.00000   0.00000    27:    $m->[ _i ] = { };
      112   0.00000   0.00000    28:    $m->[ _s ] = { };
      112   0.00001   0.00000    29:    $m->[ _p ] = { };
      112   0.00000   0.00000    30:    $m->[ _g ] = $graph;
      112   0.00001   0.00000    31:    weaken $m->[ _g ]; # So that DESTROY
      112   0.00001   0.01000    32:    return $m;
        0   0.00000   0.00000    33:}
        0   0.00000   0.00000    34:
        0   0.00000   0.00000    35:sub set_path {
      162   0.00000   0.00000    36:    my $m = shift;
      162   0.00000   0.00000    37:    my ($n, $f, $a, $i, $s, $p) = @$m;
      162   0.00009   0.01000    38:    if ($a == 2) {
        0   0.00000   0.00000    39: @_ = sort @_ if ($f & _UNORD);
        0   0.00000   0.00000    40:    }
      162   0.00000   0.00000    41:    my $e0 = shift;
      162   0.00001   0.00000    42:    if ($a == 2) {
       54   0.00000   0.00000    43: my $e1 = shift;
       54   0.00001   0.00000    44: unless (exists $s->{ $e0 } && exists $s->{
       54   0.00001   0.01000    45:     $n = $m->[ _n ]++;
       54   0.00000   0.00000    46:     $i->{ $n } = [ $e0, $e1 ];
       54   0.00000   0.00000    47:     $s->{ $e0 }->{ $e1 } = $n;
       54   0.00000   0.00000    48:     $p->{ $e1 }->{ $e0 } = $n;
        0   0.00000   0.00000    49: }
        0   0.00000   0.00000    50:    } else {
      108   0.00007   0.00000    51: unless (exists $s->{ $e0 }) {
      108   0.00001   0.01000    52:     $n = $m->[ _n ]++;
      108   0.00001   0.00000    53:     $s->{ $e0 } = $n;
      108   0.00001   0.01000    54:     $i->{ $n } = $e0;
        0   0.00000   0.00000    55: }
        0   0.00000   0.00000    56:    }
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap/Li Page 130
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000    57:}
        0   0.00000   0.00000    58:
        0   0.00000   0.00000    59:sub has_path {
        0   0.00000   0.00000    60:    my $m = shift;
        0   0.00000   0.00000    61:    my ($n, $f, $a, $i, $s) = @$m;
        0   0.00000   0.00000    62:    return 0 unless $a == @_;
        0   0.00000   0.00000    63:    my $e;
        0   0.00000   0.00000    64:    if ($a == 2) {
        0   0.00000   0.00000    65: @_ = sort @_ if ($f & _UNORD);
        0   0.00000   0.00000    66: $e = shift;
        0   0.00000   0.00000    67: return 0 unless exists $s->{ $e };
        0   0.00000   0.00000    68:        $s = $s->{ $e };
        0   0.00000   0.00000    69:    }
        0   0.00000   0.00000    70:    $e = shift;
        0   0.00000   0.00000    71:    exists $s->{ $e };
        0   0.00000   0.00000    72:}
        0   0.00000   0.00000    73:
        0   0.00000   0.00000    74:sub _get_path_id {
     1872   0.00842   0.00000    75:    my $m = shift;
     1872   0.00027   0.02000    76:    my ($n, $f, $a, $i, $s) = @$m;
     1872   0.00047   0.04000    77:    return undef unless $a == @_;
     1872   0.00092   0.01000    78:    my $e;
     1872   0.00008   0.02000    79:    if ($a == 2) {
        0   0.00000   0.00000    80: @_ = sort @_ if ($f & _UNORD);
        0   0.00000   0.00000    81: $e = shift;
        0   0.00000   0.00000    82: return undef unless exists $s->{ $e };
        0   0.00000   0.00000    83:        $s = $s->{ $e };
        0   0.00000   0.00000    84:    }
     1872   0.00050   0.02000    85:    $e = shift;
     1872   0.00003   0.00000    86:    $s->{ $e };
        0   0.00000   0.00000    87:}
        0   0.00000   0.00000    88:
        0   0.00000   0.00000    89:sub _get_path_count {
        0   0.00000   0.00000    90:    my $m = shift;
        0   0.00000   0.00000    91:    my ($n, $f, $a, $i, $s) = @$m;
        0   0.00000   0.00000    92:    my $e;
        0   0.00000   0.00000    93:    if (@_ == 2) {
        0   0.00000   0.00000    94: @_ = sort @_ if ($f & _UNORD);
        0   0.00000   0.00000    95: $e = shift;
        0   0.00000   0.00000    96: return undef unless exists $s->{ $e };
        0   0.00000   0.00000    97:        $s = $s->{ $e };
        0   0.00000   0.00000    98:    }
        0   0.00000   0.00000    99:    $e = shift;
        0   0.00000   0.00000   100:    return exists $s->{ $e } ? 1 : 0;
        0   0.00000   0.00000   101:}
        0   0.00000   0.00000   102:
        0   0.00000   0.00000   103:sub has_paths {
        0   0.00000   0.00000   104:    my $m = shift;
        0   0.00000   0.00000   105:    my ($n, $f, $a, $i, $s) = @$m;
        0   0.00000   0.00000   106:    keys %$s;
        0   0.00000   0.00000   107:}
        0   0.00000   0.00000   108:
        0   0.00000   0.00000   109:sub paths {
     2016   0.00203   0.00000   110:    my $m = shift;
     2016   0.00003   0.01000   111:    my ($n, $f, $a, $i) = @$m;
     2016   0.00046   0.00000   112:    if (defined $i) {
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap/Li Page 131
       =================================================================
    count wall tm  cpu time line
     2016   0.00047   0.02000   113: my ($k, $v) = each %$i;
     2016   0.00003   0.01000   114: if (ref $v) {
        0   0.00000   0.00000   115:     return values %{ $i };
        0   0.00000   0.00000   116: } else {
     1962   0.03604   0.07000   117:     return map { [ $_ ] } values %{ $i };
        0   0.00000   0.00000   118: }
        0   0.00000   0.00000   119:    } else {
        0   0.00000   0.00000   120: return ( );
        0   0.00000   0.00000   121:    }
        0   0.00000   0.00000   122:}
        0   0.00000   0.00000   123:
        0   0.00000   0.00000   124:sub _get_id_path {
     3044   0.00077   0.03000   125:    my $m = shift;
     3044   0.00033   0.03000   126:    my ($n, $f, $a, $i) = @$m;
     3044   0.00101   0.04000   127:    my $p = $i->{ $_[ 0 ] };
     3044   0.00775   0.02000   128:    defined $p ? ( ref $p eq 'ARRAY' ? @$p :
        0   0.00000   0.00000   129:}
        0   0.00000   0.00000   130:
        0   0.00000   0.00000   131:sub del_path {
        0   0.00000   0.00000   132:    my $m = shift;
        0   0.00000   0.00000   133:    my ($n, $f, $a, $i, $s, $p) = @$m;
        0   0.00000   0.00000   134:    if (@_ == 2) {
        0   0.00000   0.00000   135: @_ = sort @_ if ($f & _UNORD);
        0   0.00000   0.00000   136: my $e0 = shift;
        0   0.00000   0.00000   137: return 0 unless exists $s->{ $e0 };
        0   0.00000   0.00000   138: my $e1 = shift;
        0   0.00000   0.00000   139: if (defined($n = $s->{ $e0 }->{ $e1 })) {
        0   0.00000   0.00000   140:     delete $i->{ $n };
        0   0.00000   0.00000   141:            delete $s->{ $e0 }->{ $e1 };
        0   0.00000   0.00000   142:            delete $p->{ $e1 }->{ $e0 };
        0   0.00000   0.00000   143:     delete $s->{ $e0 } unless keys %{ $s->{
        0   0.00000   0.00000   144:     delete $p->{ $e1 } unless keys %{ $p->{
        0   0.00000   0.00000   145:     return 1;
        0   0.00000   0.00000   146: }
        0   0.00000   0.00000   147:    } else {
        0   0.00000   0.00000   148: my $e = shift;
        0   0.00000   0.00000   149: if (defined($n = $s->{ $e })) {
        0   0.00000   0.00000   150:     delete $i->{ $n };
        0   0.00000   0.00000   151:     delete $s->{ $e };
        0   0.00000   0.00000   152:     return 1;
        0   0.00000   0.00000   153: }
        0   0.00000   0.00000   154:    }
        0   0.00000   0.00000   155:    return 0;
        0   0.00000   0.00000   156:}
        0   0.00000   0.00000   157:
        0   0.00000   0.00000   158:sub __successors {
        0   0.00000   0.00000   159:    my $E = shift;
        0   0.00000   0.00000   160:    return wantarray ? () : 0 unless defined
        0   0.00000   0.00000   161:    my $g = shift;
        0   0.00000   0.00000   162:    my $V = $g->[ _V ];
        0   0.00000   0.00000   163:    return wantarray ? () : 0 unless defined
        0   0.00000   0.00000   164:    # my $i = $V->_get_path_id( $_[0] );
        0   0.00000   0.00000   165:    my $i =
        0   0.00000   0.00000   166: ($V->[ _f ] & _LIGHT) ?
        0   0.00000   0.00000   167:     $V->[ _s ]->{ $_[0] } :
        0   0.00000   0.00000   168:     $V->_get_path_id( $_[0] );
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap/Li Page 132
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   169:    return wantarray ? () : 0 unless defined
        0   0.00000   0.00000   170:    return keys %{ $E->[ _s ]->{ $i } };
        0   0.00000   0.00000   171:}
        0   0.00000   0.00000   172:
        0   0.00000   0.00000   173:sub _successors {
        0   0.00000   0.00000   174:    my $E = shift;
        0   0.00000   0.00000   175:    my $g = shift;
        0   0.00000   0.00000   176:    my @s = $E->__successors($g, @_);
        0   0.00000   0.00000   177:    if (($E->[ _f ] & _UNORD)) {
        0   0.00000   0.00000   178: push @s, $E->__predecessors($g, @_);
        0   0.00000   0.00000   179: my %s; @s{ @s } = ();
        0   0.00000   0.00000   180: @s = keys %s;
        0   0.00000   0.00000   181:    }
        0   0.00000   0.00000   182:    my $V = $g->[ _V ];
        0   0.00000   0.00000   183:    return wantarray ? map { $V->[ _i ]->{ $_
        0   0.00000   0.00000   184:}
        0   0.00000   0.00000   185:
        0   0.00000   0.00000   186:sub __predecessors {
        0   0.00000   0.00000   187:    my $E = shift;
        0   0.00000   0.00000   188:    return wantarray ? () : 0 unless defined
        0   0.00000   0.00000   189:    my $g = shift;
        0   0.00000   0.00000   190:    my $V = $g->[ _V ];
        0   0.00000   0.00000   191:    return wantarray ? () : 0 unless defined
        0   0.00000   0.00000   192:    # my $i = $V->_get_path_id( $_[0] );
        0   0.00000   0.00000   193:    my $i =
        0   0.00000   0.00000   194: ($V->[ _f ] & _LIGHT) ?
        0   0.00000   0.00000   195:     $V->[ _s ]->{ $_[0] } :
        0   0.00000   0.00000   196:     $V->_get_path_id( $_[0] );
        0   0.00000   0.00000   197:    return wantarray ? () : 0 unless defined
        0   0.00000   0.00000   198:    return keys %{ $E->[ _p ]->{ $i } };
        0   0.00000   0.00000   199:}
        0   0.00000   0.00000   200:
        0   0.00000   0.00000   201:sub _predecessors {
        0   0.00000   0.00000   202:    my $E = shift;
        0   0.00000   0.00000   203:    my $g = shift;
        0   0.00000   0.00000   204:    my @p = $E->__predecessors($g, @_);
        0   0.00000   0.00000   205:    if ($E->[ _f ] & _UNORD) {
        0   0.00000   0.00000   206: push @p, $E->__successors($g, @_);
        0   0.00000   0.00000   207: my %p; @p{ @p } = ();
        0   0.00000   0.00000   208: @p = keys %p;
        0   0.00000   0.00000   209:    }
        0   0.00000   0.00000   210:    my $V = $g->[ _V ];
        0   0.00000   0.00000   211:    return wantarray ? map { $V->[ _i ]->{ $_
        0   0.00000   0.00000   212:}
        0   0.00000   0.00000   213:
        0   0.00000   0.00000   214:sub __attr {
        0   0.00000   0.00000   215:    # Major magic takes place here: we
        0   0.00000   0.00000   216:    # map into a more complex map and then
      108   0.00000   0.00000   217:    my $m = $_[0];
      108   0.00001   0.01000   218:    my ($n, $f, $a, $i, $s, $p, $g) = @$m;
      108   0.00000   0.00000   219:    my ($k, $v) = each %$i;
      108   0.00000   0.00000   220:    my @V = @{ $g->[ _V ] };
      108   0.00000   0.00000   221:    my @E = $g->edges; # TODO: Both these
        0   0.00000   0.00000   222:    # ZZZ: an example of failing tests is
      108   0.00000   0.00000   223:    if (ref $v eq 'ARRAY') { # Edges, then.
        0   0.00000   0.00000   224: # print "Reedging.\n";
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap/Li Page 133
       =================================================================
    count wall tm  cpu time line
       54   0.00000   0.00000   225: @E = $g->edges; # TODO: Both these (ZZZ)
       54   0.00000   0.00000   226: $g->[ _E ] = $m =
       54   0.00000   0.00000   227: $g->add_edges( @E );
        0   0.00000   0.00000   228:    } else {
        0   0.00000   0.00000   229: # print "Revertexing.\n";
       54   0.00000   0.00000   230: $m = Graph::AdjacencyMap::Vertex->_new(($f &
       54   0.00000   0.00000   231: $m->[ _n ] = $V[ _n ];
       54   0.00000   0.00000   232: $m->[ _i ] = $V[ _i ];
       54   0.00000   0.00000   233: $m->[ _s ] = $V[ _s ];
       54   0.00000   0.00000   234: $m->[ _p ] = $V[ _p ];
       54   0.00000   0.00000   235: $g->[ _V ] = $m;
        0   0.00000   0.00000   236:    }
      108   0.00000   0.00000   237:    $_[0] = $m;
      108   0.00000   0.00000   238:    goto &{ ref($m) . "::__attr" }; #
        0   0.00000   0.00000   239:}
        0   0.00000   0.00000   240:
        0   0.00000   0.00000   241:sub _is_COUNT    () { 0 }
        0   0.00000   0.00000   242:sub _is_MULTI    () { 0 }
        0   0.00000   0.00000   243:sub _is_HYPER    () { 0 }
        0   0.00000   0.00000   244:sub _is_UNIQ     () { 0 }
        0   0.00000   0.00000   245:sub _is_REF      () { 0 }
        0   0.00000   0.00000   246:
        0   0.00000   0.00000   247:1;
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap/Ve Page 134
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:package Graph::AdjacencyMap::Vertex;
        0   0.00000   0.00000     2:
        0   0.00000   0.00000     3:# THIS IS INTERNAL IMPLEMENTATION ONLY, NOT
        0   0.00000   0.00000     4:# THE INTERFACE IS HARD TO USE AND GOING TO
        0   0.00000   0.00000     5:# ALMOST GUARANTEED TO CHANGE OR GO AWAY IN
        0   0.00000   0.00000     6:
        0   0.00000   0.00000     7:use strict;
        0   0.00000   0.00000     8:
        0   0.00000   0.00000     9:# $SIG{__DIE__ } = sub { use Carp; confess };
        0   0.00000   0.00000    10:# $SIG{__WARN__} = sub { use Carp; confess };
        0   0.00000   0.00000    11:
        0   0.00000   0.00000    12:use Graph::AdjacencyMap qw(:flags :fields);
        0   0.00000   0.00000    13:use base 'Graph::AdjacencyMap';
        0   0.00000   0.00000    14:
        0   0.00000   0.00000    15:use Scalar::Util qw(weaken);
        0   0.00000   0.00000    16:
        0   0.00000   0.00000    17:sub _new {
       54   0.00001   0.00000    18:    my ($class, $flags, $arity) = @_;
       54   0.00001   0.00000    19:    bless [ 0, $flags, $arity ], $class;
        0   0.00000   0.00000    20:}
        0   0.00000   0.00000    21:
        0   0.00000   0.00000    22:require overload; # for de-overloading
        0   0.00000   0.00000    23:
        0   0.00000   0.00000    24:sub __set_path {
     2484   0.03165   0.01000    25:    my $m = shift;
     2484   0.00057   0.02000    26:    my $f = $m->[ _f ];
     2484   0.00073   0.02000    27:    my $id = pop if ($f & _MULTI);
     2484   0.00004   0.07000    28:    if (@_ != 1) {
        0   0.00000   0.00000    29: require Carp;
        0   0.00000   0.00000    30: Carp::confess(sprintf
        0   0.00000   0.00000    31:    }
     2484   0.00002   0.01000    32:    my $p;
     2484   0.00117   0.02000    33:    $p = $m->[ _s ] ||= { };
     2484   0.00013   0.03000    34:    my @p = $p;
     2484   0.00000   0.01000    35:    my @k;
     2484   0.00005   0.01000    36:    my $k = shift;
     2484   0.00051   0.02000    37:    my $q = ref $k && ($f & _REF) &&
     2484   0.00099   0.03000    38:    push @k, $q;
     2484   0.00151   0.01000    39:    return (\@p, \@k);
        0   0.00000   0.00000    40:}
        0   0.00000   0.00000    41:
        0   0.00000   0.00000    42:sub __set_path_node {
      828   0.00048   0.00000    43:    my ($m, $p, $l) = splice @_, 0, 3;
      828   0.00025   0.00000    44:    my $f = $m->[ _f ];
      828   0.00000   0.00000    45:    my $id = pop if ($f & _MULTI);
      828   0.00001   0.01000    46:    unless (exists $p->[-1]->{ $l }) {
      828   0.00000   0.00000    47: my $i = $m->_new_node( \$p->[-1]->{ $l },
      828   0.00000   0.00000    48: $m->[ _i ]->{ defined $i ? $i : "" } =
        0   0.00000   0.00000    49:    } else {
        0   0.00000   0.00000    50: $m->_inc_node( \$p->[-1]->{ $l }, $id );
        0   0.00000   0.00000    51:    }
        0   0.00000   0.00000    52:}
        0   0.00000   0.00000    53:
        0   0.00000   0.00000    54:sub set_path {
      828   0.00024   0.00000    55:    my $m = shift;
      828   0.00046   0.00000    56:    my $f = $m->[ _f ];
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap/Ve Page 135
       =================================================================
    count wall tm  cpu time line
      828   0.00049   0.01000    57:    my ($p, $k) = $m->__set_path( @_ );
      828   0.00001   0.00000    58:    return unless defined $p && defined $k;
      828   0.00000   0.00000    59:    my $l = defined $k->[-1] ? $k->[-1] : "";
      828   0.00003   0.01000    60:    my $set = $m->__set_path_node( $p, $l, @_
      828   0.00002   0.02000    61:    return $set;
        0   0.00000   0.00000    62:}
        0   0.00000   0.00000    63:
        0   0.00000   0.00000    64:sub __has_path {
    23024   0.01754   0.18000    65:    my $m = shift;
    23024   0.00544   0.16000    66:    my $f = $m->[ _f ];
    23024   0.00486   0.24000    67:    if (@_ != 1) {
        0   0.00000   0.00000    68: require Carp;
        0   0.00000   0.00000    69: Carp::confess(sprintf
        0   0.00000   0.00000    70:        "Graph::AdjacencyMap: arguments %d
        0   0.00000   0.00000    71:        scalar @_);
        0   0.00000   0.00000    72:    }
    23024   0.00573   0.17000    73:    my $p = $m->[ _s ];
    23024   0.00453   0.19000    74:    return unless defined $p;
    23024   0.00369   0.28000    75:    my @p = $p;
    23024   0.00743   0.21000    76:    my @k;
    23024   0.00241   0.21000    77:    my $k = shift;
    23024   0.00232   0.25000    78:    my $q = ref $k && ($f & _REF) &&
    23024   0.01240   0.23000    79:    push @k, $q;
    23024   0.00823   0.23000    80:    return (\@p, \@k);
        0   0.00000   0.00000    81:}
        0   0.00000   0.00000    82:
        0   0.00000   0.00000    83:sub has_path {
    12340   0.00401   0.12000    84:    my $m = shift;
    12340   0.00141   0.09000    85:    my ($p, $k) = $m->__has_path( @_ );
    12340   0.00189   0.11000    86:    return unless defined $p && defined $k;
    12340   0.00236   0.10000    87:    return exists $p->[-1]->{ defined $k->[-
        0   0.00000   0.00000    88:}
        0   0.00000   0.00000    89:
        0   0.00000   0.00000    90:sub has_path_by_multi_id {
        0   0.00000   0.00000    91:    my $m = shift;
        0   0.00000   0.00000    92:    my $id = pop;
        0   0.00000   0.00000    93:    my ($e, $n) = $m->__get_path_node( @_ );
        0   0.00000   0.00000    94:    return undef unless $e;
        0   0.00000   0.00000    95:    return exists $n->[ _nm ]->{ $id };
        0   0.00000   0.00000    96:}
        0   0.00000   0.00000    97:
        0   0.00000   0.00000    98:sub _get_path_id {
     4968   0.00131   0.05000    99:    my $m = shift;
     4968   0.00126   0.03000   100:    my $f = $m->[ _f ];
     4968   0.00140   0.05000   101:    my ($e, $n) = $m->__get_path_node( @_ );
     4968   0.00098   0.05000   102:    return undef unless $e;
     4968   0.00037   0.05000   103:    return ref $n ? $n->[ _ni ] : $n;
        0   0.00000   0.00000   104:}
        0   0.00000   0.00000   105:
        0   0.00000   0.00000   106:sub _get_path_count {
        0   0.00000   0.00000   107:    my $m = shift;
        0   0.00000   0.00000   108:    my $f = $m->[ _f ];
        0   0.00000   0.00000   109:    my ($e, $n) = $m->__get_path_node( @_ );
        0   0.00000   0.00000   110:    return 0 unless $e && defined $n;
        0   0.00000   0.00000   111:    return
        0   0.00000   0.00000   112: ($f & _COUNT) ? $n->[ _nc ] :
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap/Ve Page 136
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   113: ($f & _MULTI) ? scalar keys %{ $n->[ _nm ] }
        0   0.00000   0.00000   114:}
        0   0.00000   0.00000   115:
        0   0.00000   0.00000   116:sub __attr {
     7372   0.00182   0.10000   117:    my $m = shift;
     7372   0.00131   0.13000   118:    if (@_ && ref $_[0] && @{ $_[0] } != $m-
        0   0.00000   0.00000   119: require Carp;
        0   0.00000   0.00000   120: Carp::confess(sprintf
        0   0.00000   0.00000   121:        scalar @{ $_[0] }, $m->[ _a ]);
        0   0.00000   0.00000   122:    }
        0   0.00000   0.00000   123:}
        0   0.00000   0.00000   124:
        0   0.00000   0.00000   125:sub _get_id_path {
      162   0.00047   0.00000   126:    my ($m, $i) = @_;
      162   0.00000   0.00000   127:    return defined $m->[ _i ] ? $m->[ _i ]->{
        0   0.00000   0.00000   128:}
        0   0.00000   0.00000   129:
        0   0.00000   0.00000   130:sub del_path {
        0   0.00000   0.00000   131:    my $m = shift;
        0   0.00000   0.00000   132:    my $f = $m->[ _f ];
        0   0.00000   0.00000   133:    my ($e, $n, $p, $k, $l) = $m-
        0   0.00000   0.00000   134:    return unless $e;
        0   0.00000   0.00000   135:    my $c = ($f & _COUNT) ? --$n->[ _nc ] :
        0   0.00000   0.00000   136:    if ($c == 0) {
        0   0.00000   0.00000   137: delete $m->[ _i ]->{ ref $n ? $n->[ _ni ] :
        0   0.00000   0.00000   138: delete $p->[ -1 ]->{ $l };
        0   0.00000   0.00000   139:    }
        0   0.00000   0.00000   140:    return 1;
        0   0.00000   0.00000   141:}
        0   0.00000   0.00000   142:
        0   0.00000   0.00000   143:sub del_path_by_multi_id {
        0   0.00000   0.00000   144:    my $m = shift;
        0   0.00000   0.00000   145:    my $f = $m->[ _f ];
        0   0.00000   0.00000   146:    my $id = pop;
        0   0.00000   0.00000   147:    my ($e, $n, $p, $k, $l) = $m-
        0   0.00000   0.00000   148:    return unless $e;
        0   0.00000   0.00000   149:    delete $n->[ _nm ]->{ $id };
        0   0.00000   0.00000   150:    unless (keys %{ $n->[ _nm ] }) {
        0   0.00000   0.00000   151: delete $m->[ _i ]->{ $n->[ _ni ] };
        0   0.00000   0.00000   152: delete $p->[-1]->{ $l };
        0   0.00000   0.00000   153:    }
        0   0.00000   0.00000   154:    return 1;
        0   0.00000   0.00000   155:}
        0   0.00000   0.00000   156:
        0   0.00000   0.00000   157:sub paths {
        0   0.00000   0.00000   158:    my $m = shift;
        0   0.00000   0.00000   159:    return map { [ $_ ] } values %{ $m->[ _i
        0   0.00000   0.00000   160:    wantarray ? ( ) : 0;
        0   0.00000   0.00000   161:}
        0   0.00000   0.00000   162:
        0   0.00000   0.00000   163:1;
        0   0.00000   0.00000   164:=pod
        0   0.00000   0.00000   165:
        0   0.00000   0.00000   166:
        0   0.00000   0.00000   167:
        0   0.00000   0.00000   168:
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/AdjacencyMap/Ve Page 137
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   169:
        0   0.00000   0.00000   170:
        0   0.00000   0.00000   171:
        0   0.00000   0.00000   172:
        0   0.00000   0.00000   173:
        0   0.00000   0.00000   174:
        0   0.00000   0.00000   175:
        0   0.00000   0.00000   176:
        0   0.00000   0.00000   177:
        0   0.00000   0.00000   178:
        0   0.00000   0.00000   179:
        0   0.00000   0.00000   180:
        0   0.00000   0.00000   181:
        0   0.00000   0.00000   182:
        0   0.00000   0.00000   183:
        0   0.00000   0.00000   184:
        0   0.00000   0.00000   185:
        0   0.00000   0.00000   186:
        0   0.00000   0.00000   187:
        0   0.00000   0.00000   188:
        0   0.00000   0.00000   189:
        0   0.00000   0.00000   190:
        0   0.00000   0.00000   191:
        0   0.00000   0.00000   192:
        0   0.00000   0.00000   193:
        0   0.00000   0.00000   194:
        0   0.00000   0.00000   195:
        0   0.00000   0.00000   196:
        0   0.00000   0.00000   197:
        0   0.00000   0.00000   198:
        0   0.00000   0.00000   199:
        0   0.00000   0.00000   200:
        0   0.00000   0.00000   201:
        0   0.00000   0.00000   202:
        0   0.00000   0.00000   203:
        0   0.00000   0.00000   204:
        0   0.00000   0.00000   205:
        0   0.00000   0.00000   206:
        0   0.00000   0.00000   207:
        0   0.00000   0.00000   208:
        0   0.00000   0.00000   209:
        0   0.00000   0.00000   210:
        0   0.00000   0.00000   211:
        0   0.00000   0.00000   212:
        0   0.00000   0.00000   213:
        0   0.00000   0.00000   214:
        0   0.00000   0.00000   215:
        0   0.00000   0.00000   216:
           ================ SmallProf version 2.02 ================
          Profile of /usr/local/share/perl/5.10.0/Graph/Attribute.pm   Page 138
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:package Graph::Attribute;
        0   0.00000   0.00000     2:
        0   0.00000   0.00000     3:use strict;
        0   0.00000   0.00000     4:
        0   0.00000   0.00000     5:sub _F () { 0 }
        0   0.00000   0.00000     6:sub _COMPAT02 () { 0x00000001 }
        0   0.00000   0.00000     7:
        0   0.00000   0.00000     8:sub import {
        0   0.00000   0.00000     9:    my $package = shift;
        0   0.00000   0.00000    10:    my %attr = @_;
        0   0.00000   0.00000    11:    my $caller = caller(0);
        0   0.00000   0.00000    12:    if (exists $attr{array}) {
        0   0.00000   0.00000    13: my $i = $attr{array};
        0   0.00000   0.00000    14: no strict 'refs';
     1772   0.00001   0.00000    15: *{"${caller}::_get_attributes"} = sub {
        0   0.00000   0.00000    16: *{"${caller}::_set_attributes"} =
     1822   0.00046   0.00000    17:     sub { $_[0]->[ $i ] ||= { };
     1822   0.00003   0.01000    18:    $_[0]->[ $i ] = $_[1] if @_ == 2;
     1822   0.00003   0.04000    19:    $_[0]->[ $i ] };
        0   0.00000   0.00000    20: *{"${caller}::_has_attributes"} = sub {
        0   0.00000   0.00000    21: *{"${caller}::_delete_attributes"} = sub {
        0   0.00000   0.00000    22:    } elsif (exists $attr{hash}) {
        0   0.00000   0.00000    23: my $k = $attr{hash};
        0   0.00000   0.00000    24: no strict 'refs';
        0   0.00000   0.00000    25: *{"${caller}::_get_attributes"} = sub {
        0   0.00000   0.00000    26: *{"${caller}::_set_attributes"} =
        0   0.00000   0.00000    27:     sub { $_[0]->{ $k } ||= { };
        0   0.00000   0.00000    28:    $_[0]->{ $k } = $_[1] if @_ == 2;
        0   0.00000   0.00000    29:    $_[0]->{ $k } };
        0   0.00000   0.00000    30: *{"${caller}::_has_attributes"} = sub {
        0   0.00000   0.00000    31: *{"${caller}::_delete_attributes"} = sub {
        0   0.00000   0.00000    32:    } else {
        0   0.00000   0.00000    33: die "Graph::Attribute::import($package @_)
        0   0.00000   0.00000    34:    }
        0   0.00000   0.00000    35:    my @api = qw(get_attribute
        0   0.00000   0.00000    36:   get_attributes
        0   0.00000   0.00000    37:   set_attribute
        0   0.00000   0.00000    38:   set_attributes
        0   0.00000   0.00000    39:   has_attribute
        0   0.00000   0.00000    40:   has_attributes
        0   0.00000   0.00000    41:   delete_attribute
        0   0.00000   0.00000    42:   delete_attributes
        0   0.00000   0.00000    43:   get_attribute_names
        0   0.00000   0.00000    44:   get_attribute_values);
        0   0.00000   0.00000    45:    if (exists $attr{map}) {
        0   0.00000   0.00000    46: my $map = $attr{map};
        0   0.00000   0.00000    47: for my $api (@api) {
        0   0.00000   0.00000    48:     my ($first, $rest) = ($api =~
        0   0.00000   0.00000    49:     no strict 'refs';
        0   0.00000   0.00000    50:     *{"${caller}::${first}_${map}_${rest}"}
        0   0.00000   0.00000    51: }
        0   0.00000   0.00000    52:    }
        0   0.00000   0.00000    53:}
        0   0.00000   0.00000    54:
        0   0.00000   0.00000    55:sub set_attribute {
     1822   0.00004   0.01000    56:    my $g = shift;
           ================ SmallProf version 2.02 ================
          Profile of /usr/local/share/perl/5.10.0/Graph/Attribute.pm   Page 139
       =================================================================
    count wall tm  cpu time line
     1822   0.00001   0.01000    57:    my $v = pop;
     1822   0.00045   0.02000    58:    my $a = pop;
     1822   0.00002   0.01000    59:    my $p = $g->_set_attributes;
     1822   0.00065   0.01000    60:    $p->{ $a } = $v;
     1822   0.00015   0.03000    61:    return 1;
        0   0.00000   0.00000    62:}
        0   0.00000   0.00000    63:
        0   0.00000   0.00000    64:sub set_attributes {
        0   0.00000   0.00000    65:    my $g = shift;
        0   0.00000   0.00000    66:    my $a = pop;
        0   0.00000   0.00000    67:    my $p = $g->_set_attributes( $a );
        0   0.00000   0.00000    68:    return 1;
        0   0.00000   0.00000    69:}
        0   0.00000   0.00000    70:
        0   0.00000   0.00000    71:sub has_attribute {
        0   0.00000   0.00000    72:    my $g = shift;
        0   0.00000   0.00000    73:    my $a = pop;
        0   0.00000   0.00000    74:    my $p = $g->_get_attributes;
        0   0.00000   0.00000    75:    $p ? exists $p->{ $a } : 0;
        0   0.00000   0.00000    76:}
        0   0.00000   0.00000    77:
        0   0.00000   0.00000    78:sub has_attributes {
        0   0.00000   0.00000    79:    my $g = shift;
        0   0.00000   0.00000    80:    $g->_get_attributes ? 1 : 0;
        0   0.00000   0.00000    81:}
        0   0.00000   0.00000    82:
        0   0.00000   0.00000    83:sub get_attribute {
     1772   0.00088   0.00000    84:    my $g = shift;
     1772   0.00007   0.01000    85:    my $a = pop;
     1772   0.00001   0.03000    86:    my $p = $g->_get_attributes;
     1772   0.00001   0.00000    87:    $p ? $p->{ $a } : undef;
        0   0.00000   0.00000    88:}
        0   0.00000   0.00000    89:
        0   0.00000   0.00000    90:sub delete_attribute {
        0   0.00000   0.00000    91:    my $g = shift;
        0   0.00000   0.00000    92:    my $a = pop;
        0   0.00000   0.00000    93:    my $p = $g->_get_attributes;
        0   0.00000   0.00000    94:    if (defined $p) {
        0   0.00000   0.00000    95: delete $p->{ $a };
        0   0.00000   0.00000    96: return 1;
        0   0.00000   0.00000    97:    } else {
        0   0.00000   0.00000    98: return 0;
        0   0.00000   0.00000    99:    }
        0   0.00000   0.00000   100:}
        0   0.00000   0.00000   101:
        0   0.00000   0.00000   102:sub delete_attributes {
        0   0.00000   0.00000   103:    my $g = shift;
        0   0.00000   0.00000   104:    if ($g->_has_attributes) {
        0   0.00000   0.00000   105: $g->_delete_attributes;
        0   0.00000   0.00000   106: return 1;
        0   0.00000   0.00000   107:    } else {
        0   0.00000   0.00000   108: return 0;
        0   0.00000   0.00000   109:    }
        0   0.00000   0.00000   110:}
        0   0.00000   0.00000   111:
        0   0.00000   0.00000   112:sub get_attribute_names {
           ================ SmallProf version 2.02 ================
          Profile of /usr/local/share/perl/5.10.0/Graph/Attribute.pm   Page 140
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   113:    my $g = shift;
        0   0.00000   0.00000   114:    my $p = $g->_get_attributes;
        0   0.00000   0.00000   115:    defined $p ? keys %{ $p } : ( );
        0   0.00000   0.00000   116:}
        0   0.00000   0.00000   117:
        0   0.00000   0.00000   118:sub get_attribute_values {
        0   0.00000   0.00000   119:    my $g = shift;
        0   0.00000   0.00000   120:    my $p = $g->_get_attributes;
        0   0.00000   0.00000   121:    defined $p ? values %{ $p } : ( );
        0   0.00000   0.00000   122:}
        0   0.00000   0.00000   123:
        0   0.00000   0.00000   124:sub get_attributes {
        0   0.00000   0.00000   125:    my $g = shift;
        0   0.00000   0.00000   126:    my $a = $g->_get_attributes;
        0   0.00000   0.00000   127:    ($g->[ _F ] & _COMPAT02) ? (defined $a ?
        0   0.00000   0.00000   128:}
        0   0.00000   0.00000   129:
        0   0.00000   0.00000   130:1;
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Graph/SPTHeapElem.pm  Page 141
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:package Graph::SPTHeapElem;
        0   0.00000   0.00000     2:
        0   0.00000   0.00000     3:use strict;
        0   0.00000   0.00000     4:use vars qw($VERSION @ISA);
        0   0.00000   0.00000     5:use Heap071::Elem;
        0   0.00000   0.00000     6:
        0   0.00000   0.00000     7:use base 'Heap071::Elem';
        0   0.00000   0.00000     8:
        0   0.00000   0.00000     9:$VERSION = 0.01;
        0   0.00000   0.00000    10:
        0   0.00000   0.00000    11:sub new {
      828   0.00004   0.00000    12:    my $class = shift;
      828   0.00065   0.03000    13:    bless { u => $_[0], v => $_[1], w =>
        0   0.00000   0.00000    14:}
        0   0.00000   0.00000    15:
        0   0.00000   0.00000    16:sub cmp {
        0   0.00000   0.00000    17:    ($_[0]->{ w } || 0) <=> ($_[1]->{ w } ||
        0   0.00000   0.00000    18:    ($_[0]->{ u } cmp $_[1]->{ u }) ||
     2346   0.00127   0.02000    19:    ($_[0]->{ u } cmp $_[1]->{ v });
        0   0.00000   0.00000    20:}
        0   0.00000   0.00000    21:
        0   0.00000   0.00000    22:sub val {
      828   0.00030   0.00000    23:    @{ $_[0] }{ qw(u v w) };
        0   0.00000   0.00000    24:}
        0   0.00000   0.00000    25:
        0   0.00000   0.00000    26:1;
           ================ SmallProf version 2.02 ================
          Profile of /usr/local/share/perl/5.10.0/Graph/Undirected.pm  Page 142
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:package Graph::Undirected;
        0   0.00000   0.00000     2:
        0   0.00000   0.00000     3:use Graph;
        0   0.00000   0.00000     4:use base 'Graph';
        0   0.00000   0.00000     5:use strict;
        0   0.00000   0.00000     6:
        0   0.00000   0.00000     7:=pod
        0   0.00000   0.00000     8:
        0   0.00000   0.00000     9:
        0   0.00000   0.00000    10:
        0   0.00000   0.00000    11:
        0   0.00000   0.00000    12:
        0   0.00000   0.00000    13:
        0   0.00000   0.00000    14:
        0   0.00000   0.00000    15:
        0   0.00000   0.00000    16:
        0   0.00000   0.00000    17:
        0   0.00000   0.00000    18:
        0   0.00000   0.00000    19:
        0   0.00000   0.00000    20:
        0   0.00000   0.00000    21:
        0   0.00000   0.00000    22:
        0   0.00000   0.00000    23:
        0   0.00000   0.00000    24:
        0   0.00000   0.00000    25:
        0   0.00000   0.00000    26:
        0   0.00000   0.00000    27:
        0   0.00000   0.00000    28:
        0   0.00000   0.00000    29:
        0   0.00000   0.00000    30:
        0   0.00000   0.00000    31:
        0   0.00000   0.00000    32:
        0   0.00000   0.00000    33:
        0   0.00000   0.00000    34:
        0   0.00000   0.00000    35:
        0   0.00000   0.00000    36:
        0   0.00000   0.00000    37:
        0   0.00000   0.00000    38:
        0   0.00000   0.00000    39:
        0   0.00000   0.00000    40:
        0   0.00000   0.00000    41:
        0   0.00000   0.00000    42:
        0   0.00000   0.00000    43:
        0   0.00000   0.00000    44:sub new {
       58   0.00000   0.00000    45:    my $class = shift;
       58   0.00000   0.00000    46:    bless Graph->new(undirected => 1, @_),
        0   0.00000   0.00000    47:}
        0   0.00000   0.00000    48:
        0   0.00000   0.00000    49:1;
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Heap071/Elem.pm    Page 143
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:package Heap071::Elem;
        0   0.00000   0.00000     2:
        0   0.00000   0.00000     3:use strict;
        0   0.00000   0.00000     4:use vars qw($VERSION @ISA @EXPORT
        0   0.00000   0.00000     5:
        0   0.00000   0.00000     6:require Exporter;
        0   0.00000   0.00000     7:require AutoLoader;
        0   0.00000   0.00000     8:
        0   0.00000   0.00000     9:@ISA = qw(Exporter AutoLoader);
        0   0.00000   0.00000    10:
        0   0.00000   0.00000    11:# No names exported.
        0   0.00000   0.00000    12:# No names available for export.
        0   0.00000   0.00000    13:
        0   0.00000   0.00000    14:@EXPORT = ( );
        0   0.00000   0.00000    15:
        0   0.00000   0.00000    16:$VERSION = '0.71';
        0   0.00000   0.00000    17:
        0   0.00000   0.00000    18:
        0   0.00000   0.00000    19:# Preloaded methods go here.
        0   0.00000   0.00000    20:
        0   0.00000   0.00000    21:# new will usually be superceded by child,
        0   0.00000   0.00000    22:# but provide an empty hash as default and
        0   0.00000   0.00000    23:# accept any provided filling for it.
        0   0.00000   0.00000    24:sub new {
        0   0.00000   0.00000    25:    my $self = shift;
        0   0.00000   0.00000    26:    my $class = ref($self) || $self;
        0   0.00000   0.00000    27:
        0   0.00000   0.00000    28:    return bless { heap=>undef, @_ }, $class;
        0   0.00000   0.00000    29:}
        0   0.00000   0.00000    30:
        0   0.00000   0.00000    31:sub heap {
     1656   0.00025   0.00000    32:    my $self = shift;
     1656   0.00001   0.01000    33:    @_ ? ($self->{heap} = shift) : $self-
        0   0.00000   0.00000    34:}
        0   0.00000   0.00000    35:
        0   0.00000   0.00000    36:sub cmp {
        0   0.00000   0.00000    37:    die "This cmp method must be superceded
        0   0.00000   0.00000    38:}
        0   0.00000   0.00000    39:
        0   0.00000   0.00000    40:# Autoload methods go after =cut, and are
        0   0.00000   0.00000    41:
        0   0.00000   0.00000    42:1;
        0   0.00000   0.00000    43:__END__
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Heap071/Fibonacci.pm  Page 144
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:package Heap071::Fibonacci;
        0   0.00000   0.00000     2:
        0   0.00000   0.00000     3:use strict;
        0   0.00000   0.00000     4:use vars qw($VERSION @ISA @EXPORT
        0   0.00000   0.00000     5:
        0   0.00000   0.00000     6:require Exporter;
        0   0.00000   0.00000     7:require AutoLoader;
        0   0.00000   0.00000     8:
        0   0.00000   0.00000     9:@ISA = qw(Exporter AutoLoader);
        0   0.00000   0.00000    10:
        0   0.00000   0.00000    11:# No names exported.
        0   0.00000   0.00000    12:# No names available for export.
        0   0.00000   0.00000    13:@EXPORT = ( );
        0   0.00000   0.00000    14:
        0   0.00000   0.00000    15:$VERSION = '0.71';
        0   0.00000   0.00000    16:
        0   0.00000   0.00000    17:
        0   0.00000   0.00000    18:# Preloaded methods go here.
        0   0.00000   0.00000    19:
        0   0.00000   0.00000    20:# common names
        0   0.00000   0.00000    21:# h - heap head
        0   0.00000   0.00000    22:# el - linkable element, contains user-
        0   0.00000   0.00000    23:# v - user-provided value
        0   0.00000   0.00000    24:
        0   0.00000   0.00000    25:#############################################
        0   0.00000   0.00000    26:
        0   0.00000   0.00000    27:my $debug = 0;
        0   0.00000   0.00000    28:my $validate = 0;
        0   0.00000   0.00000    29:
        0   0.00000   0.00000    30:# enable/disable debugging output
        0   0.00000   0.00000    31:sub debug {
        0   0.00000   0.00000    32:    @_ ? ($debug = shift) : $debug;
        0   0.00000   0.00000    33:}
        0   0.00000   0.00000    34:
        0   0.00000   0.00000    35:# enable/disable validation checks on values
        0   0.00000   0.00000    36:sub validate {
        0   0.00000   0.00000    37:    @_ ? ($validate = shift) : $validate;
        0   0.00000   0.00000    38:}
        0   0.00000   0.00000    39:
        0   0.00000   0.00000    40:my $width = 3;
        0   0.00000   0.00000    41:my $bar = ' | ';
        0   0.00000   0.00000    42:my $corner = ' +-';
        0   0.00000   0.00000    43:my $vfmt = "%3d";
        0   0.00000   0.00000    44:
        0   0.00000   0.00000    45:sub set_width {
        0   0.00000   0.00000    46:    $width = shift;
        0   0.00000   0.00000    47:    $width = 2 if $width < 2;
        0   0.00000   0.00000    48:
        0   0.00000   0.00000    49:    $vfmt = "%${width}d";
        0   0.00000   0.00000    50:    $bar = $corner = ' ' x $width;
        0   0.00000   0.00000    51:    substr($bar,-2,1) = '|';
        0   0.00000   0.00000    52:    substr($corner,-2,2) = '+-';
        0   0.00000   0.00000    53:}
        0   0.00000   0.00000    54:
        0   0.00000   0.00000    55:sub hdump;
        0   0.00000   0.00000    56:
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Heap071/Fibonacci.pm  Page 145
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000    57:sub hdump {
        0   0.00000   0.00000    58:    my $el = shift;
        0   0.00000   0.00000    59:    my $l1 = shift;
        0   0.00000   0.00000    60:    my $b = shift;
        0   0.00000   0.00000    61:
        0   0.00000   0.00000    62:    my $ch;
        0   0.00000   0.00000    63:    my $ch1;
        0   0.00000   0.00000    64:
        0   0.00000   0.00000    65:    unless( $el ) {
        0   0.00000   0.00000    66: print $l1, "\n";
        0   0.00000   0.00000    67: return;
        0   0.00000   0.00000    68:    }
        0   0.00000   0.00000    69:
        0   0.00000   0.00000    70:    hdump $ch1 = $el->{child},
        0   0.00000   0.00000    71: $l1 . sprintf( $vfmt, $el->{val}->val),
        0   0.00000   0.00000    72: $b . $bar;
        0   0.00000   0.00000    73:
        0   0.00000   0.00000    74:    if( $ch1 ) {
        0   0.00000   0.00000    75: for( $ch = $ch1->{right}; $ch != $ch1; $ch =
        0   0.00000   0.00000    76:     hdump $ch, $b . $corner, $b . $bar;
        0   0.00000   0.00000    77: }
        0   0.00000   0.00000    78:    }
        0   0.00000   0.00000    79:}
        0   0.00000   0.00000    80:
        0   0.00000   0.00000    81:sub heapdump {
        0   0.00000   0.00000    82:    my $h;
        0   0.00000   0.00000    83:
        0   0.00000   0.00000    84:    while( $h = shift ) {
        0   0.00000   0.00000    85: my $top = $$h or last;
        0   0.00000   0.00000    86: my $el = $top;
        0   0.00000   0.00000    87:
        0   0.00000   0.00000    88: do {
        0   0.00000   0.00000    89:     hdump $el, sprintf( "%02d: ", $el-
        0   0.00000   0.00000    90:     $el = $el->{right};
        0   0.00000   0.00000    91: } until $el == $top;
        0   0.00000   0.00000    92: print "\n";
        0   0.00000   0.00000    93:    }
        0   0.00000   0.00000    94:}
        0   0.00000   0.00000    95:
        0   0.00000   0.00000    96:sub bhcheck;
        0   0.00000   0.00000    97:
        0   0.00000   0.00000    98:sub bhcheck {
        0   0.00000   0.00000    99:    my $el = shift;
        0   0.00000   0.00000   100:    my $p = shift;
        0   0.00000   0.00000   101:
        0   0.00000   0.00000   102:    my $cur = $el;
        0   0.00000   0.00000   103:    my $prev;
        0   0.00000   0.00000   104:    my $ch;
        0   0.00000   0.00000   105:    do {
        0   0.00000   0.00000   106: $prev = $cur;
        0   0.00000   0.00000   107: $cur = $cur->{right};
        0   0.00000   0.00000   108: die "bad back link" unless $cur->{left} ==
        0   0.00000   0.00000   109: die "bad parent link"
        0   0.00000   0.00000   110:     unless (defined $p && defined $cur->{p}
        0   0.00000   0.00000   111:  || (!defined $p && !defined $cur->{p});
        0   0.00000   0.00000   112: die "bad degree( $cur->{degree} > $p-
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Heap071/Fibonacci.pm  Page 146
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   113:     if $p && $p->{degree} <= $cur->{degree};
        0   0.00000   0.00000   114: die "not heap ordered"
        0   0.00000   0.00000   115:     if $p && $p->{val}->cmp($cur->{val}) >
        0   0.00000   0.00000   116: $ch = $cur->{child} and bhcheck $ch, $cur;
        0   0.00000   0.00000   117:    } until $cur == $el;
        0   0.00000   0.00000   118:}
        0   0.00000   0.00000   119:
        0   0.00000   0.00000   120:
        0   0.00000   0.00000   121:sub heapcheck {
        0   0.00000   0.00000   122:    my $h;
        0   0.00000   0.00000   123:    my $el;
        0   0.00000   0.00000   124:    while( $h = shift ) {
        0   0.00000   0.00000   125: heapdump $h if $validate >= 2;
        0   0.00000   0.00000   126: $el = $$h and bhcheck $el, undef;
        0   0.00000   0.00000   127:    }
        0   0.00000   0.00000   128:}
        0   0.00000   0.00000   129:
        0   0.00000   0.00000   130:
        0   0.00000   0.00000   131:#############################################
        0   0.00000   0.00000   132:
        0   0.00000   0.00000   133:sub ascending_cut;
        0   0.00000   0.00000   134:sub elem;
        0   0.00000   0.00000   135:sub elem_DESTROY;
        0   0.00000   0.00000   136:sub link_to_left_of;
        0   0.00000   0.00000   137:
        0   0.00000   0.00000   138:#############################################
        0   0.00000   0.00000   139:
        0   0.00000   0.00000   140:# Cormen et al. use two values for the heap,
        0   0.00000   0.00000   141:# list at the top, and a count of the number
        0   0.00000   0.00000   142:# used to determine the size of array
        0   0.00000   0.00000   143:# but perl can set array sizes as needed and
        0   0.00000   0.00000   144:# when they are created, so we're not
        0   0.00000   0.00000   145:sub new {
       54   0.00000   0.00000   146:    my $self = shift;
       54   0.00000   0.00000   147:    my $class = ref($self) || $self;
       54   0.00000   0.00000   148:    my $h = undef;
       54   0.00000   0.00000   149:    bless \$h, $class;
        0   0.00000   0.00000   150:}
        0   0.00000   0.00000   151:
        0   0.00000   0.00000   152:sub DESTROY {
       54   0.00001   0.00000   153:    my $h = shift;
        0   0.00000   0.00000   154:
       54   0.00000   0.00000   155:    elem_DESTROY $$h;
        0   0.00000   0.00000   156:}
        0   0.00000   0.00000   157:
        0   0.00000   0.00000   158:sub add {
      828   0.00004   0.03000   159:    my $h = shift;
      828   0.00756   0.00000   160:    my $v = shift;
      828   0.00000   0.01000   161:    $validate && do {
        0   0.00000   0.00000   162: die "Method 'heap' required for element on
        0   0.00000   0.00000   163:     unless $v->can('heap');
        0   0.00000   0.00000   164: die "Method 'cmp' required for element on
        0   0.00000   0.00000   165:     unless $v->can('cmp');
        0   0.00000   0.00000   166:    };
      828   0.00046   0.01000   167:    my $el = elem $v;
      828   0.00000   0.00000   168:    my $top;
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Heap071/Fibonacci.pm  Page 147
       =================================================================
    count wall tm  cpu time line
      828   0.00000   0.00000   169:    if( !($top = $$h) ) {
       96   0.00004   0.01000   170: $$h = $el;
        0   0.00000   0.00000   171:    } else {
      732   0.00002   0.00000   172: link_to_left_of $top->{left}, $el ;
      732   0.00001   0.00000   173: link_to_left_of $el,$top;
      732   0.00000   0.00000   174: $$h = $el if $v->cmp($top->{val}) < 0;
        0   0.00000   0.00000   175:    }
        0   0.00000   0.00000   176:}
        0   0.00000   0.00000   177:
        0   0.00000   0.00000   178:sub top {
      882   0.00021   0.01000   179:    my $h = shift;
      882   0.00025   0.00000   180:    $$h && $$h->{val};
        0   0.00000   0.00000   181:}
        0   0.00000   0.00000   182:
        0   0.00000   0.00000   183:*minimum = \&top;
        0   0.00000   0.00000   184:
        0   0.00000   0.00000   185:sub extract_top {
      828   0.00071   0.01000   186:    my $h = shift;
      828   0.00022   0.01000   187:    my $el = $$h or return undef;
      828   0.00001   0.00000   188:    my $ltop = $el->{left};
      828   0.00008   0.01000   189:    my $cur;
      828   0.00185   0.02000   190:    my $next;
        0   0.00000   0.00000   191:
        0   0.00000   0.00000   192:    # $el is the heap with the lowest value
        0   0.00000   0.00000   193:    # move all of $el's children (if any) to
        0   0.00000   0.00000   194:    # $ltop and $el)
      828   0.00001   0.02000   195:    if( $cur = $el->{child} ) {
        0   0.00000   0.00000   196: # remember the beginning of the list of
      458   0.00001   0.01000   197: my $first = $cur;
      458   0.00001   0.00000   198: do {
        0   0.00000   0.00000   199:     # the children are moving to the top,
        0   0.00000   0.00000   200:     # pointer for all of them
        0   0.00000   0.00000   201:     $cur->{p} = undef;
        0   0.00000   0.00000   202: } until ($cur = $cur->{right}) == $first;
        0   0.00000   0.00000   203:
        0   0.00000   0.00000   204: # remember the end of the list
      458   0.00001   0.02000   205: $cur = $cur->{left};
      458   0.00010   0.01000   206: link_to_left_of $ltop, $first;
      458   0.00045   0.01000   207: link_to_left_of $cur, $el;
        0   0.00000   0.00000   208:    }
        0   0.00000   0.00000   209:
      828   0.00005   0.01000   210:    if( $el->{right} == $el ) {
        0   0.00000   0.00000   211: # $el had no siblings or children, the top
        0   0.00000   0.00000   212: # and $el is being removed
       96   0.00000   0.00000   213: $$h = undef;
        0   0.00000   0.00000   214:    } else {
      732   0.00003   0.01000   215: link_to_left_of $el->{left}, $$h = $el-
        0   0.00000   0.00000   216: # now all those loose ends have to be merged
        0   0.00000   0.00000   217: # search for the
        0   0.00000   0.00000   218: # new smallest element
      732   0.00003   0.01000   219: $h->consolidate;
        0   0.00000   0.00000   220:    }
        0   0.00000   0.00000   221:
        0   0.00000   0.00000   222:    # extract the actual value and return
        0   0.00000   0.00000   223:    # but break all of its links so that it
      828   0.00000   0.00000   224:    my $top = $el->{val};
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Heap071/Fibonacci.pm  Page 148
       =================================================================
    count wall tm  cpu time line
      828   0.00001   0.01000   225:    $top->heap(undef);
      828   0.00028   0.00000   226:    $el->{left} = $el->{right} = $el->{p} =
        0   0.00000   0.00000   227: undef;
      828   0.00002   0.00000   228:    $top;
        0   0.00000   0.00000   229:}
        0   0.00000   0.00000   230:
        0   0.00000   0.00000   231:*extract_minimum = \&extract_top;
        0   0.00000   0.00000   232:
        0   0.00000   0.00000   233:sub absorb {
        0   0.00000   0.00000   234:    my $h = shift;
        0   0.00000   0.00000   235:    my $h2 = shift;
        0   0.00000   0.00000   236:
        0   0.00000   0.00000   237:    my $el = $$h;
        0   0.00000   0.00000   238:    unless( $el ) {
        0   0.00000   0.00000   239: $$h = $$h2;
        0   0.00000   0.00000   240: $$h2 = undef;
        0   0.00000   0.00000   241: return $h;
        0   0.00000   0.00000   242:    }
        0   0.00000   0.00000   243:
        0   0.00000   0.00000   244:    my $el2 = $$h2 or return $h;
        0   0.00000   0.00000   245:
        0   0.00000   0.00000   246:    # add $el2 and its siblings to the head
        0   0.00000   0.00000   247:    # at start, $ell -> $el -> ... -> $ell is
        0   0.00000   0.00000   248:    #    $el->{left})
        0   0.00000   0.00000   249:    #           $el2l -> $el2 -> ... -> $el2l
        0   0.00000   0.00000   250:    # at end, $ell -> $el2l -> ... -> $el2 ->
        0   0.00000   0.00000   251:    #    all on $h
        0   0.00000   0.00000   252:    my $el2l = $el2->{left};
        0   0.00000   0.00000   253:    link_to_left_of $el->{left}, $el2;
        0   0.00000   0.00000   254:    link_to_left_of $el2l, $el;
        0   0.00000   0.00000   255:
        0   0.00000   0.00000   256:    # change the top link if needed
        0   0.00000   0.00000   257:    $$h = $el2 if $el->{val}->cmp( $el2-
        0   0.00000   0.00000   258:
        0   0.00000   0.00000   259:    # clean out $h2
        0   0.00000   0.00000   260:    $$h2 = undef;
        0   0.00000   0.00000   261:
        0   0.00000   0.00000   262:    # return the heap
        0   0.00000   0.00000   263:    $h;
        0   0.00000   0.00000   264:}
        0   0.00000   0.00000   265:
        0   0.00000   0.00000   266:# a key has been decreased, it may have to
        0   0.00000   0.00000   267:sub decrease_key {
        0   0.00000   0.00000   268:    my $h = shift;
        0   0.00000   0.00000   269:    my $top = $$h;
        0   0.00000   0.00000   270:    my $v = shift;
        0   0.00000   0.00000   271:    my $el = $v->heap or return undef;
        0   0.00000   0.00000   272:    my $p;
        0   0.00000   0.00000   273:
        0   0.00000   0.00000   274:    # first, link $h to $el if it is now the
        0   0.00000   0.00000   275:    # soon link $el to $top to properly put
        0   0.00000   0.00000   276:    # if it isn't already there)
        0   0.00000   0.00000   277:    $$h = $el if $top->{val}->cmp( $v ) > 0;
        0   0.00000   0.00000   278:
        0   0.00000   0.00000   279:    if( $p = $el->{p} and $v->cmp($p->{val})
        0   0.00000   0.00000   280: # remove $el from its parent's list - it is
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Heap071/Fibonacci.pm  Page 149
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   281:
        0   0.00000   0.00000   282: ascending_cut $top, $p, $el;
        0   0.00000   0.00000   283:    }
        0   0.00000   0.00000   284:
        0   0.00000   0.00000   285:    $v;
        0   0.00000   0.00000   286:}
        0   0.00000   0.00000   287:
        0   0.00000   0.00000   288:
        0   0.00000   0.00000   289:# to delete an item, we bubble it to the top
        0   0.00000   0.00000   290:# had been decreased to -infinity), and then
        0   0.00000   0.00000   291:sub delete {
        0   0.00000   0.00000   292:    my $h = shift;
        0   0.00000   0.00000   293:    my $v = shift;
        0   0.00000   0.00000   294:    my $el = $v->heap or return undef;
        0   0.00000   0.00000   295:
        0   0.00000   0.00000   296:    # if there is a parent, cut $el to the
        0   0.00000   0.00000   297:    # key decreased to a smaller value than
        0   0.00000   0.00000   298:    my $p;
        0   0.00000   0.00000   299:    $p = $el->{p} and ascending_cut $$h, $p,
        0   0.00000   0.00000   300:
        0   0.00000   0.00000   301:    # $el is in the top list now, make it
        0   0.00000   0.00000   302:    # remove it
        0   0.00000   0.00000   303:    $$h = $el;
        0   0.00000   0.00000   304:    $h->extract_top;
        0   0.00000   0.00000   305:}
        0   0.00000   0.00000   306:
        0   0.00000   0.00000   307:
        0   0.00000   0.00000   308:#############################################
        0   0.00000   0.00000   309:
        0   0.00000   0.00000   310:sub elem {
      828   0.00001   0.01000   311:    my $v = shift;
      828   0.00002   0.01000   312:    my $el = undef;
      828   0.00005   0.02000   313:    $el = {
        0   0.00000   0.00000   314: p => undef,
        0   0.00000   0.00000   315: degree => 0,
        0   0.00000   0.00000   316: mark => 0,
        0   0.00000   0.00000   317: child => undef,
        0   0.00000   0.00000   318: val => $v,
        0   0.00000   0.00000   319: left => undef,
        0   0.00000   0.00000   320: right => undef,
        0   0.00000   0.00000   321:    };
      828   0.00002   0.00000   322:    $el->{left} = $el->{right} = $el;
      828   0.00020   0.01000   323:    $v->heap($el);
      828   0.00000   0.00000   324:    $el;
        0   0.00000   0.00000   325:}
        0   0.00000   0.00000   326:
        0   0.00000   0.00000   327:sub elem_DESTROY {
       54   0.00000   0.00000   328:    my $el = shift;
       54   0.00000   0.00000   329:    my $ch;
       54   0.00000   0.00000   330:    my $next;
       54   0.00000   0.00000   331:    $el->{left}->{right} = undef;
        0   0.00000   0.00000   332:
       54   0.00000   0.00000   333:    while( $el ) {
       54   0.00000   0.00000   334: $ch = $el->{child} and elem_DESTROY $ch;
       54   0.00000   0.00000   335: $next = $el->{right};
        0   0.00000   0.00000   336:
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Heap071/Fibonacci.pm  Page 150
       =================================================================
    count wall tm  cpu time line
       54   0.00000   0.00000   337: defined $el->{val} and $el->{val}-
       54   0.00000   0.00000   338: $el->{child} = $el->{right} = $el->{left} =
        0   0.00000   0.00000   339:     = undef;
       54   0.00017   0.00000   340: $el = $next;
        0   0.00000   0.00000   341:    }
        0   0.00000   0.00000   342:}
        0   0.00000   0.00000   343:
        0   0.00000   0.00000   344:sub link_to_left_of {
     4544   0.00110   0.03000   345:    my $l = shift;
     4544   0.00011   0.02000   346:    my $r = shift;
        0   0.00000   0.00000   347:
     4544   0.00019   0.06000   348:    $l->{right} = $r;
     4544   0.00307   0.06000   349:    $r->{left} = $l;
        0   0.00000   0.00000   350:}
        0   0.00000   0.00000   351:
        0   0.00000   0.00000   352:sub link_as_parent_of {
      630   0.00001   0.01000   353:    my $p = shift;
      630   0.00002   0.03000   354:    my $c = shift;
        0   0.00000   0.00000   355:
      630   0.00000   0.00000   356:    my $pc;
        0   0.00000   0.00000   357:
      630   0.00000   0.00000   358:    if( $pc = $p->{child} ) {
      172   0.00000   0.00000   359: link_to_left_of $pc->{left}, $c;
      172   0.00000   0.00000   360: link_to_left_of $c, $pc;
        0   0.00000   0.00000   361:    } else {
      458   0.00000   0.00000   362: link_to_left_of $c, $c;
        0   0.00000   0.00000   363:    }
      630   0.00000   0.00000   364:    $p->{child} = $c;
      630   0.00002   0.00000   365:    $c->{p} = $p;
      630   0.00001   0.00000   366:    $p->{degree}++;
      630   0.00007   0.00000   367:    $c->{mark} = 0;
      630   0.00046   0.00000   368:    $p;
        0   0.00000   0.00000   369:}
        0   0.00000   0.00000   370:
        0   0.00000   0.00000   371:sub consolidate {
      732   0.00001   0.03000   372:    my $h = shift;
        0   0.00000   0.00000   373:
      732   0.00001   0.02000   374:    my $cur;
      732   0.00001   0.01000   375:    my $this;
      732   0.00026   0.02000   376:    my $next = $$h;
      732   0.00047   0.00000   377:    my $last = $next->{left};
      732   0.00001   0.00000   378:    my @a;
      732   0.00001   0.02000   379:    do {
        0   0.00000   0.00000   380: # examine next item on top list
     1614   0.00001   0.00000   381: $this = $cur = $next;
     1614   0.00004   0.01000   382: $next = $cur->{right};
     1614   0.00045   0.00000   383: my $d = $cur->{degree};
     1614   0.00025   0.03000   384: my $alt;
     1614   0.00002   0.01000   385: while( $alt = $a[$d] ) {
        0   0.00000   0.00000   386:     # we already saw another item of the
        0   0.00000   0.00000   387:     # put the larger valued one under the
        0   0.00000   0.00000   388:     # one - switch $cur and $alt if
        0   0.00000   0.00000   389:     # is the smaller
      630   0.00044   0.00000   390:     ($cur,$alt) = ($alt,$cur)
        0   0.00000   0.00000   391:  if $cur->{val}->cmp( $alt->{val} ) > 0;
        0   0.00000   0.00000   392:     # remove $alt from the top list
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Heap071/Fibonacci.pm  Page 151
       =================================================================
    count wall tm  cpu time line
      630   0.00003   0.02000   393:     link_to_left_of $alt->{left}, $alt-
        0   0.00000   0.00000   394:     # and put it under $cur
      630   0.00045   0.00000   395:     link_as_parent_of $cur, $alt;
        0   0.00000   0.00000   396:     # make sure that $h still points to a
      630   0.00002   0.00000   397:     $$h = $cur;
        0   0.00000   0.00000   398:     # we've removed the old $d degree entry
      630   0.00046   0.00000   399:     $a[$d] = undef;
        0   0.00000   0.00000   400:     # and we now have a $d+1 degree entry to
        0   0.00000   0.00000   401:     # into @a
      630   0.00000   0.00000   402:     ++$d;
        0   0.00000   0.00000   403: }
        0   0.00000   0.00000   404: # found a previously unused degree
     1614   0.00020   0.01000   405: $a[$d] = $cur;
        0   0.00000   0.00000   406:    } until $this == $last;
      732   0.00003   0.00000   407:    $cur = $$h;
      732   0.00001   0.02000   408:    for $cur (grep defined, @a) {
      984   0.00001   0.02000   409: $$h = $cur if $$h->{val}->cmp( $cur->{val} )
        0   0.00000   0.00000   410:    }
        0   0.00000   0.00000   411:}
        0   0.00000   0.00000   412:
        0   0.00000   0.00000   413:sub ascending_cut {
        0   0.00000   0.00000   414:    my $top = shift;
        0   0.00000   0.00000   415:    my $p = shift;
        0   0.00000   0.00000   416:    my $el = shift;
        0   0.00000   0.00000   417:
        0   0.00000   0.00000   418:    while( 1 ) {
        0   0.00000   0.00000   419: if( --$p->{degree} ) {
        0   0.00000   0.00000   420:     # there are still other children below
        0   0.00000   0.00000   421:     my $l = $el->{left};
        0   0.00000   0.00000   422:     $p->{child} = $l;
        0   0.00000   0.00000   423:     link_to_left_of $l, $el->{right};
        0   0.00000   0.00000   424: } else {
        0   0.00000   0.00000   425:     # $el was the only child of $p
        0   0.00000   0.00000   426:     $p->{child} = undef;
        0   0.00000   0.00000   427: }
        0   0.00000   0.00000   428: link_to_left_of $top->{left}, $el;
        0   0.00000   0.00000   429: link_to_left_of $el, $top;
        0   0.00000   0.00000   430: $el->{p} = undef;
        0   0.00000   0.00000   431: $el->{mark} = 0;
        0   0.00000   0.00000   432:
        0   0.00000   0.00000   433: # propagate up the list
        0   0.00000   0.00000   434: $el = $p;
        0   0.00000   0.00000   435:
        0   0.00000   0.00000   436: # quit at the top
        0   0.00000   0.00000   437: last unless $p = $el->{p};
        0   0.00000   0.00000   438:
        0   0.00000   0.00000   439: # quit if we can mark $el
        0   0.00000   0.00000   440: $el->{mark} = 1, last unless $el->{mark};
        0   0.00000   0.00000   441:    }
        0   0.00000   0.00000   442:}
        0   0.00000   0.00000   443:
        0   0.00000   0.00000   444:
        0   0.00000   0.00000   445:1;
        0   0.00000   0.00000   446:
        0   0.00000   0.00000   447:__END__
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 152
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:package Test::Builder;
        0   0.00000   0.00000     2:
        0   0.00000   0.00000     3:use 5.006;
        0   0.00000   0.00000     4:use strict;
        0   0.00000   0.00000     5:use warnings;
        0   0.00000   0.00000     6:
        0   0.00000   0.00000     7:our $VERSION = '0.92';
        0   0.00000   0.00000     8:$VERSION = eval $VERSION;    ## no critic
        0   0.00000   0.00000     9:
        0   0.00000   0.00000    10:BEGIN {
        0   0.00000   0.00000    11:    if( $] < 5.008 ) {
        0   0.00000   0.00000    12:        require Test::Builder::IO::Scalar;
        0   0.00000   0.00000    13:    }
        0   0.00000   0.00000    14:}
        0   0.00000   0.00000    15:
        0   0.00000   0.00000    16:
        0   0.00000   0.00000    17:# Make Test::Builder thread-safe for
        0   0.00000   0.00000    18:BEGIN {
        0   0.00000   0.00000    19:    use Config;
        0   0.00000   0.00000    20:    # Load threads::shared when threads are
        0   0.00000   0.00000    21:    # 5.8.0's threads are so busted we no
        0   0.00000   0.00000    22:    if( $] >= 5.008001 &&
        0   0.00000   0.00000    23:        require threads::shared;
        0   0.00000   0.00000    24:
        0   0.00000   0.00000    25:        # Hack around YET ANOTHER
        0   0.00000   0.00000    26:        # occassionally forget the contents
        0   0.00000   0.00000    27:        # So we first copy the data, then
        0   0.00000   0.00000    28:        *share = sub (\[$@%]) {
        0   0.00000   0.00000    29:            my $type = ref $_[0];
        0   0.00000   0.00000    30:            my $data;
        0   0.00000   0.00000    31:
        0   0.00000   0.00000    32:            if( $type eq 'HASH' ) {
        0   0.00000   0.00000    33:                %$data = %{ $_[0] };
        0   0.00000   0.00000    34:            }
        0   0.00000   0.00000    35:            elsif( $type eq 'ARRAY' ) {
        0   0.00000   0.00000    36:                @$data = @{ $_[0] };
        0   0.00000   0.00000    37:            }
        0   0.00000   0.00000    38:            elsif( $type eq 'SCALAR' ) {
        0   0.00000   0.00000    39:                $$data = ${ $_[0] };
        0   0.00000   0.00000    40:            }
        0   0.00000   0.00000    41:            else {
        0   0.00000   0.00000    42:                die( "Unknown type: " . $type
        0   0.00000   0.00000    43:            }
        0   0.00000   0.00000    44:
        0   0.00000   0.00000    45:            $_[0] = &threads::shared::share(
        0   0.00000   0.00000    46:
        0   0.00000   0.00000    47:            if( $type eq 'HASH' ) {
        0   0.00000   0.00000    48:                %{ $_[0] } = %$data;
        0   0.00000   0.00000    49:            }
        0   0.00000   0.00000    50:            elsif( $type eq 'ARRAY' ) {
        0   0.00000   0.00000    51:                @{ $_[0] } = @$data;
        0   0.00000   0.00000    52:            }
        0   0.00000   0.00000    53:            elsif( $type eq 'SCALAR' ) {
        0   0.00000   0.00000    54:                ${ $_[0] } = $$data;
        0   0.00000   0.00000    55:            }
        0   0.00000   0.00000    56:            else {
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 153
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000    57:                die( "Unknown type: " . $type
        0   0.00000   0.00000    58:            }
        0   0.00000   0.00000    59:
        0   0.00000   0.00000    60:            return $_[0];
        0   0.00000   0.00000    61:        };
        0   0.00000   0.00000    62:    }
        0   0.00000   0.00000    63:    # 5.8.0's threads::shared is busted when
        0   0.00000   0.00000    64:    # and earlier Perls just don't have that
        0   0.00000   0.00000    65:    else {
        2   0.00000   0.00000    66:        *share = sub { return $_[0] };
        1   0.00000   0.00000    67:        *lock  = sub { 0 };
        0   0.00000   0.00000    68:    }
        0   0.00000   0.00000    69:}
        0   0.00000   0.00000    70:
        0   0.00000   0.00000    71:=head1 NAME
        0   0.00000   0.00000    72:
        0   0.00000   0.00000    73:
        0   0.00000   0.00000    74:
        0   0.00000   0.00000    75:
        0   0.00000   0.00000    76:
        0   0.00000   0.00000    77:
        0   0.00000   0.00000    78:
        0   0.00000   0.00000    79:
        0   0.00000   0.00000    80:
        0   0.00000   0.00000    81:
        0   0.00000   0.00000    82:
        0   0.00000   0.00000    83:
        0   0.00000   0.00000    84:
        0   0.00000   0.00000    85:
        0   0.00000   0.00000    86:
        0   0.00000   0.00000    87:
        0   0.00000   0.00000    88:
        0   0.00000   0.00000    89:
        0   0.00000   0.00000    90:
        0   0.00000   0.00000    91:
        0   0.00000   0.00000    92:
        0   0.00000   0.00000    93:
        0   0.00000   0.00000    94:
        0   0.00000   0.00000    95:
        0   0.00000   0.00000    96:
        0   0.00000   0.00000    97:
        0   0.00000   0.00000    98:
        0   0.00000   0.00000    99:
        0   0.00000   0.00000   100:
        0   0.00000   0.00000   101:
        0   0.00000   0.00000   102:
        0   0.00000   0.00000   103:
        0   0.00000   0.00000   104:
        0   0.00000   0.00000   105:
        0   0.00000   0.00000   106:
        0   0.00000   0.00000   107:
        0   0.00000   0.00000   108:
        0   0.00000   0.00000   109:
        0   0.00000   0.00000   110:
        0   0.00000   0.00000   111:
        0   0.00000   0.00000   112:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 154
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   113:
        0   0.00000   0.00000   114:
        0   0.00000   0.00000   115:
        0   0.00000   0.00000   116:
        0   0.00000   0.00000   117:
        0   0.00000   0.00000   118:
        0   0.00000   0.00000   119:my $Test = Test::Builder->new;
        0   0.00000   0.00000   120:
        0   0.00000   0.00000   121:sub new {
        1   0.00000   0.00000   122:    my($class) = shift;
        1   0.00000   0.00000   123:    $Test ||= $class->create;
        1   0.00000   0.00000   124:    return $Test;
        0   0.00000   0.00000   125:}
        0   0.00000   0.00000   126:
        0   0.00000   0.00000   127:=item B<create>
        0   0.00000   0.00000   128:
        0   0.00000   0.00000   129:
        0   0.00000   0.00000   130:
        0   0.00000   0.00000   131:
        0   0.00000   0.00000   132:
        0   0.00000   0.00000   133:
        0   0.00000   0.00000   134:
        0   0.00000   0.00000   135:
        0   0.00000   0.00000   136:
        0   0.00000   0.00000   137:
        0   0.00000   0.00000   138:
        0   0.00000   0.00000   139:
        0   0.00000   0.00000   140:
        0   0.00000   0.00000   141:sub create {
        0   0.00000   0.00000   142:    my $class = shift;
        0   0.00000   0.00000   143:
        0   0.00000   0.00000   144:    my $self = bless {}, $class;
        0   0.00000   0.00000   145:    $self->reset;
        0   0.00000   0.00000   146:
        0   0.00000   0.00000   147:    return $self;
        0   0.00000   0.00000   148:}
        0   0.00000   0.00000   149:
        0   0.00000   0.00000   150:=item B<reset>
        0   0.00000   0.00000   151:
        0   0.00000   0.00000   152:
        0   0.00000   0.00000   153:
        0   0.00000   0.00000   154:
        0   0.00000   0.00000   155:
        0   0.00000   0.00000   156:
        0   0.00000   0.00000   157:
        0   0.00000   0.00000   158:
        0   0.00000   0.00000   159:
        0   0.00000   0.00000   160:our $Level;
        0   0.00000   0.00000   161:
        0   0.00000   0.00000   162:sub reset {    ## no critic
        0   0.00000   0.00000   163:    my($self) = @_;
        0   0.00000   0.00000   164:
        0   0.00000   0.00000   165:    # We leave this a global because it has
        0   0.00000   0.00000   166:    # hash keys is just asking for pain.
        0   0.00000   0.00000   167:    $Level = 1;
        0   0.00000   0.00000   168:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 155
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   169:    $self->{Have_Plan}    = 0;
        0   0.00000   0.00000   170:    $self->{No_Plan}      = 0;
        0   0.00000   0.00000   171:    $self->{Have_Output_Plan} = 0;
        0   0.00000   0.00000   172:
        0   0.00000   0.00000   173:    $self->{Original_Pid} = $$;
        0   0.00000   0.00000   174:
        0   0.00000   0.00000   175:    share( $self->{Curr_Test} );
        0   0.00000   0.00000   176:    $self->{Curr_Test} = 0;
        0   0.00000   0.00000   177:    $self->{Test_Results} = &share( [] );
        0   0.00000   0.00000   178:
        0   0.00000   0.00000   179:    $self->{Exported_To}    = undef;
        0   0.00000   0.00000   180:    $self->{Expected_Tests} = 0;
        0   0.00000   0.00000   181:
        0   0.00000   0.00000   182:    $self->{Skip_All} = 0;
        0   0.00000   0.00000   183:
        0   0.00000   0.00000   184:    $self->{Use_Nums} = 1;
        0   0.00000   0.00000   185:
        0   0.00000   0.00000   186:    $self->{No_Header} = 0;
        0   0.00000   0.00000   187:    $self->{No_Ending} = 0;
        0   0.00000   0.00000   188:
        0   0.00000   0.00000   189:    $self->{Todo}       = undef;
        0   0.00000   0.00000   190:    $self->{Todo_Stack} = [];
        0   0.00000   0.00000   191:    $self->{Start_Todo} = 0;
        0   0.00000   0.00000   192:    $self->{Opened_Testhandles} = 0;
        0   0.00000   0.00000   193:
        0   0.00000   0.00000   194:    $self->_dup_stdhandles;
        0   0.00000   0.00000   195:
        0   0.00000   0.00000   196:    return;
        0   0.00000   0.00000   197:}
        0   0.00000   0.00000   198:
        0   0.00000   0.00000   199:=back
        0   0.00000   0.00000   200:
        0   0.00000   0.00000   201:
        0   0.00000   0.00000   202:
        0   0.00000   0.00000   203:
        0   0.00000   0.00000   204:
        0   0.00000   0.00000   205:
        0   0.00000   0.00000   206:
        0   0.00000   0.00000   207:
        0   0.00000   0.00000   208:
        0   0.00000   0.00000   209:
        0   0.00000   0.00000   210:
        0   0.00000   0.00000   211:
        0   0.00000   0.00000   212:
        0   0.00000   0.00000   213:
        0   0.00000   0.00000   214:
        0   0.00000   0.00000   215:
        0   0.00000   0.00000   216:
        0   0.00000   0.00000   217:
        0   0.00000   0.00000   218:
        0   0.00000   0.00000   219:
        0   0.00000   0.00000   220:
        0   0.00000   0.00000   221:my %plan_cmds = (
        0   0.00000   0.00000   222:    no_plan     => \&no_plan,
        0   0.00000   0.00000   223:    skip_all    => \&skip_all,
        0   0.00000   0.00000   224:    tests       => \&_plan_tests,
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 156
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   225:);
        0   0.00000   0.00000   226:
        0   0.00000   0.00000   227:sub plan {
        0   0.00000   0.00000   228:    my( $self, $cmd, $arg ) = @_;
        0   0.00000   0.00000   229:
        0   0.00000   0.00000   230:    return unless $cmd;
        0   0.00000   0.00000   231:
        0   0.00000   0.00000   232:    local $Level = $Level + 1;
        0   0.00000   0.00000   233:
        0   0.00000   0.00000   234:    $self->croak("You tried to plan twice")
        0   0.00000   0.00000   235:
        0   0.00000   0.00000   236:    if( my $method = $plan_cmds{$cmd} ) {
        0   0.00000   0.00000   237:        local $Level = $Level + 1;
        0   0.00000   0.00000   238:        $self->$method($arg);
        0   0.00000   0.00000   239:    }
        0   0.00000   0.00000   240:    else {
        0   0.00000   0.00000   241:        my @args = grep { defined } ( $cmd,
        0   0.00000   0.00000   242:        $self->croak("plan() doesn't
        0   0.00000   0.00000   243:    }
        0   0.00000   0.00000   244:
        0   0.00000   0.00000   245:    return 1;
        0   0.00000   0.00000   246:}
        0   0.00000   0.00000   247:
        0   0.00000   0.00000   248:
        0   0.00000   0.00000   249:sub _plan_tests {
        0   0.00000   0.00000   250:    my($self, $arg) = @_;
        0   0.00000   0.00000   251:
        0   0.00000   0.00000   252:    if($arg) {
        0   0.00000   0.00000   253:        local $Level = $Level + 1;
        0   0.00000   0.00000   254:        return $self->expected_tests($arg);
        0   0.00000   0.00000   255:    }
        0   0.00000   0.00000   256:    elsif( !defined $arg ) {
        0   0.00000   0.00000   257:        $self->croak("Got an undefined number
        0   0.00000   0.00000   258:    }
        0   0.00000   0.00000   259:    else {
        0   0.00000   0.00000   260:        $self->croak("You said to run 0
        0   0.00000   0.00000   261:    }
        0   0.00000   0.00000   262:
        0   0.00000   0.00000   263:    return;
        0   0.00000   0.00000   264:}
        0   0.00000   0.00000   265:
        0   0.00000   0.00000   266:
        0   0.00000   0.00000   267:=item B<expected_tests>
        0   0.00000   0.00000   268:
        0   0.00000   0.00000   269:
        0   0.00000   0.00000   270:
        0   0.00000   0.00000   271:
        0   0.00000   0.00000   272:
        0   0.00000   0.00000   273:
        0   0.00000   0.00000   274:
        0   0.00000   0.00000   275:
        0   0.00000   0.00000   276:
        0   0.00000   0.00000   277:sub expected_tests {
        0   0.00000   0.00000   278:    my $self = shift;
        0   0.00000   0.00000   279:    my($max) = @_;
        0   0.00000   0.00000   280:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 157
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   281:    if(@_) {
        0   0.00000   0.00000   282:        $self->croak("Number of tests must be
        0   0.00000   0.00000   283:          unless $max =~ /^\+?\d+$/;
        0   0.00000   0.00000   284:
        0   0.00000   0.00000   285:        $self->{Expected_Tests} = $max;
        0   0.00000   0.00000   286:        $self->{Have_Plan}      = 1;
        0   0.00000   0.00000   287:
        0   0.00000   0.00000   288:        $self->_output_plan($max) unless
        0   0.00000   0.00000   289:    }
        0   0.00000   0.00000   290:    return $self->{Expected_Tests};
        0   0.00000   0.00000   291:}
        0   0.00000   0.00000   292:
        0   0.00000   0.00000   293:=item B<no_plan>
        0   0.00000   0.00000   294:
        0   0.00000   0.00000   295:
        0   0.00000   0.00000   296:
        0   0.00000   0.00000   297:
        0   0.00000   0.00000   298:
        0   0.00000   0.00000   299:
        0   0.00000   0.00000   300:
        0   0.00000   0.00000   301:sub no_plan {
        0   0.00000   0.00000   302:    my($self, $arg) = @_;
        0   0.00000   0.00000   303:
        0   0.00000   0.00000   304:    $self->carp("no_plan takes no arguments")
        0   0.00000   0.00000   305:
        0   0.00000   0.00000   306:    $self->{No_Plan}   = 1;
        0   0.00000   0.00000   307:    $self->{Have_Plan} = 1;
        0   0.00000   0.00000   308:
        0   0.00000   0.00000   309:    return 1;
        0   0.00000   0.00000   310:}
        0   0.00000   0.00000   311:
        0   0.00000   0.00000   312:
        0   0.00000   0.00000   313:=begin private
        0   0.00000   0.00000   314:
        0   0.00000   0.00000   315:
        0   0.00000   0.00000   316:
        0   0.00000   0.00000   317:
        0   0.00000   0.00000   318:
        0   0.00000   0.00000   319:
        0   0.00000   0.00000   320:
        0   0.00000   0.00000   321:
        0   0.00000   0.00000   322:
        0   0.00000   0.00000   323:
        0   0.00000   0.00000   324:
        0   0.00000   0.00000   325:
        0   0.00000   0.00000   326:
        0   0.00000   0.00000   327:
        0   0.00000   0.00000   328:
        0   0.00000   0.00000   329:
        0   0.00000   0.00000   330:
        0   0.00000   0.00000   331:
        0   0.00000   0.00000   332:
        0   0.00000   0.00000   333:
        0   0.00000   0.00000   334:
        0   0.00000   0.00000   335:sub _output_plan {
        0   0.00000   0.00000   336:    my($self, $max, $directive, $reason) =
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 158
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   337:
        0   0.00000   0.00000   338:    $self->carp("The plan was already
        0   0.00000   0.00000   339:
        0   0.00000   0.00000   340:    my $plan = "1..$max";
        0   0.00000   0.00000   341:    $plan .= " # $directive" if defined
        0   0.00000   0.00000   342:    $plan .= " $reason"      if defined
        0   0.00000   0.00000   343:
        0   0.00000   0.00000   344:    $self->_print("$plan\n");
        0   0.00000   0.00000   345:
        0   0.00000   0.00000   346:    $self->{Have_Output_Plan} = 1;
        0   0.00000   0.00000   347:
        0   0.00000   0.00000   348:    return;
        0   0.00000   0.00000   349:}
        0   0.00000   0.00000   350:
        0   0.00000   0.00000   351:=item B<done_testing>
        0   0.00000   0.00000   352:
        0   0.00000   0.00000   353:
        0   0.00000   0.00000   354:
        0   0.00000   0.00000   355:
        0   0.00000   0.00000   356:
        0   0.00000   0.00000   357:
        0   0.00000   0.00000   358:
        0   0.00000   0.00000   359:
        0   0.00000   0.00000   360:
        0   0.00000   0.00000   361:
        0   0.00000   0.00000   362:
        0   0.00000   0.00000   363:
        0   0.00000   0.00000   364:
        0   0.00000   0.00000   365:
        0   0.00000   0.00000   366:
        0   0.00000   0.00000   367:
        0   0.00000   0.00000   368:
        0   0.00000   0.00000   369:
        0   0.00000   0.00000   370:
        0   0.00000   0.00000   371:
        0   0.00000   0.00000   372:
        0   0.00000   0.00000   373:
        0   0.00000   0.00000   374:
        0   0.00000   0.00000   375:
        0   0.00000   0.00000   376:
        0   0.00000   0.00000   377:
        0   0.00000   0.00000   378:
        0   0.00000   0.00000   379:
        0   0.00000   0.00000   380:
        0   0.00000   0.00000   381:
        0   0.00000   0.00000   382:
        0   0.00000   0.00000   383:
        0   0.00000   0.00000   384:
        0   0.00000   0.00000   385:
        0   0.00000   0.00000   386:sub done_testing {
        0   0.00000   0.00000   387:    my($self, $num_tests) = @_;
        0   0.00000   0.00000   388:
        0   0.00000   0.00000   389:    # If done_testing() specified the number
        0   0.00000   0.00000   390:    if( defined $num_tests ) {
        0   0.00000   0.00000   391:        $self->{No_Plan} = 0;
        0   0.00000   0.00000   392:    }
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 159
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   393:    else {
        0   0.00000   0.00000   394:        $num_tests = $self->current_test;
        0   0.00000   0.00000   395:    }
        0   0.00000   0.00000   396:
        0   0.00000   0.00000   397:    if( $self->{Done_Testing} ) {
        0   0.00000   0.00000   398:        my($file, $line) = @{$self-
        0   0.00000   0.00000   399:        $self->ok(0, "done_testing() was
        0   0.00000   0.00000   400:        return;
        0   0.00000   0.00000   401:    }
        0   0.00000   0.00000   402:
        0   0.00000   0.00000   403:    $self->{Done_Testing} = [caller];
        0   0.00000   0.00000   404:
        0   0.00000   0.00000   405:    if( $self->expected_tests && $num_tests
        0   0.00000   0.00000   406:        $self->ok(0, "planned to run @{[
        0   0.00000   0.00000   407:                     "but done_testing()
        0   0.00000   0.00000   408:    }
        0   0.00000   0.00000   409:    else {
        0   0.00000   0.00000   410:        $self->{Expected_Tests} = $num_tests;
        0   0.00000   0.00000   411:    }
        0   0.00000   0.00000   412:
        0   0.00000   0.00000   413:    $self->_output_plan($num_tests) unless
        0   0.00000   0.00000   414:
        0   0.00000   0.00000   415:    $self->{Have_Plan} = 1;
        0   0.00000   0.00000   416:
        0   0.00000   0.00000   417:    return 1;
        0   0.00000   0.00000   418:}
        0   0.00000   0.00000   419:
        0   0.00000   0.00000   420:
        0   0.00000   0.00000   421:=item B<has_plan>
        0   0.00000   0.00000   422:
        0   0.00000   0.00000   423:
        0   0.00000   0.00000   424:
        0   0.00000   0.00000   425:
        0   0.00000   0.00000   426:
        0   0.00000   0.00000   427:
        0   0.00000   0.00000   428:
        0   0.00000   0.00000   429:
        0   0.00000   0.00000   430:
        0   0.00000   0.00000   431:sub has_plan {
        0   0.00000   0.00000   432:    my $self = shift;
        0   0.00000   0.00000   433:
        0   0.00000   0.00000   434:    return( $self->{Expected_Tests} ) if
        0   0.00000   0.00000   435:    return('no_plan') if $self->{No_Plan};
        0   0.00000   0.00000   436:    return(undef);
        0   0.00000   0.00000   437:}
        0   0.00000   0.00000   438:
        0   0.00000   0.00000   439:=item B<skip_all>
        0   0.00000   0.00000   440:
        0   0.00000   0.00000   441:
        0   0.00000   0.00000   442:
        0   0.00000   0.00000   443:
        0   0.00000   0.00000   444:
        0   0.00000   0.00000   445:
        0   0.00000   0.00000   446:
        0   0.00000   0.00000   447:
        0   0.00000   0.00000   448:sub skip_all {
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 160
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   449:    my( $self, $reason ) = @_;
        0   0.00000   0.00000   450:
        0   0.00000   0.00000   451:    $self->{Skip_All} = 1;
        0   0.00000   0.00000   452:
        0   0.00000   0.00000   453:    $self->_output_plan(0, "SKIP", $reason)
        0   0.00000   0.00000   454:    exit(0);
        0   0.00000   0.00000   455:}
        0   0.00000   0.00000   456:
        0   0.00000   0.00000   457:=item B<exported_to>
        0   0.00000   0.00000   458:
        0   0.00000   0.00000   459:
        0   0.00000   0.00000   460:
        0   0.00000   0.00000   461:
        0   0.00000   0.00000   462:
        0   0.00000   0.00000   463:
        0   0.00000   0.00000   464:
        0   0.00000   0.00000   465:
        0   0.00000   0.00000   466:
        0   0.00000   0.00000   467:
        0   0.00000   0.00000   468:
        0   0.00000   0.00000   469:
        0   0.00000   0.00000   470:sub exported_to {
        0   0.00000   0.00000   471:    my( $self, $pack ) = @_;
        0   0.00000   0.00000   472:
        0   0.00000   0.00000   473:    if( defined $pack ) {
        0   0.00000   0.00000   474:        $self->{Exported_To} = $pack;
        0   0.00000   0.00000   475:    }
        0   0.00000   0.00000   476:    return $self->{Exported_To};
        0   0.00000   0.00000   477:}
        0   0.00000   0.00000   478:
        0   0.00000   0.00000   479:=back
        0   0.00000   0.00000   480:
        0   0.00000   0.00000   481:
        0   0.00000   0.00000   482:
        0   0.00000   0.00000   483:
        0   0.00000   0.00000   484:
        0   0.00000   0.00000   485:
        0   0.00000   0.00000   486:
        0   0.00000   0.00000   487:
        0   0.00000   0.00000   488:
        0   0.00000   0.00000   489:
        0   0.00000   0.00000   490:
        0   0.00000   0.00000   491:
        0   0.00000   0.00000   492:
        0   0.00000   0.00000   493:
        0   0.00000   0.00000   494:
        0   0.00000   0.00000   495:
        0   0.00000   0.00000   496:
        0   0.00000   0.00000   497:
        0   0.00000   0.00000   498:
        0   0.00000   0.00000   499:
        0   0.00000   0.00000   500:sub ok {
        1   0.00000   0.00000   501:    my( $self, $test, $name ) = @_;
        0   0.00000   0.00000   502:
        0   0.00000   0.00000   503:    # $test might contain an object which we
        0   0.00000   0.00000   504:    # store, so we turn it into a boolean.
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 161
       =================================================================
    count wall tm  cpu time line
        1   0.00000   0.00000   505:    $test = $test ? 1 : 0;
        0   0.00000   0.00000   506:
        1   0.00000   0.00000   507:    lock $self->{Curr_Test};
        1   0.00000   0.00000   508:    $self->{Curr_Test}++;
        0   0.00000   0.00000   509:
        0   0.00000   0.00000   510:    # In case $name is a string overloaded
        1   0.00000   0.00000   511:    $self->_unoverload_str( \$name );
        0   0.00000   0.00000   512:
        1   0.00000   0.00000   513:    $self->diag(<<"ERR") if defined $name and
        0   0.00000   0.00000   514:    You named your test '$name'.  You
        0   0.00000   0.00000   515:    Very confusing.
        0   0.00000   0.00000   516:ERR
        0   0.00000   0.00000   517:
        0   0.00000   0.00000   518:    # Capture the value of $TODO for the rest
        0   0.00000   0.00000   519:    # so it can more easily be found by other
        1   0.00000   0.00000   520:    my $todo    = $self->todo();
        1   0.00000   0.00000   521:    my $in_todo = $self->in_todo;
        1   0.00000   0.00000   522:    local $self->{Todo} = $todo if $in_todo;
        0   0.00000   0.00000   523:
        1   0.00000   0.00000   524:    $self->_unoverload_str( \$todo );
        0   0.00000   0.00000   525:
        1   0.00000   0.00000   526:    my $out;
        1   0.00000   0.00000   527:    my $result = &share( {} );
        0   0.00000   0.00000   528:
        1   0.00000   0.00000   529:    unless($test) {
        1   0.00000   0.00000   530:        $out .= "not ";
        1   0.00000   0.00000   531:        @$result{ 'ok', 'actual_ok' } = ( (
        0   0.00000   0.00000   532:    }
        0   0.00000   0.00000   533:    else {
        0   0.00000   0.00000   534:        @$result{ 'ok', 'actual_ok' } = ( 1,
        0   0.00000   0.00000   535:    }
        0   0.00000   0.00000   536:
        1   0.00000   0.00000   537:    $out .= "ok";
        1   0.00000   0.00000   538:    $out .= " $self->{Curr_Test}" if $self-
        0   0.00000   0.00000   539:
        1   0.00000   0.00000   540:    if( defined $name ) {
        1   0.00000   0.00000   541:        $name =~ s|#|\\#|g;    # # in a name
        1   0.00000   0.00000   542:        $out .= " - $name";
        1   0.00000   0.00000   543:        $result->{name} = $name;
        0   0.00000   0.00000   544:    }
        0   0.00000   0.00000   545:    else {
        0   0.00000   0.00000   546:        $result->{name} = '';
        0   0.00000   0.00000   547:    }
        0   0.00000   0.00000   548:
        1   0.00000   0.00000   549:    if( $self->in_todo ) {
        0   0.00000   0.00000   550:        $out .= " # TODO $todo";
        0   0.00000   0.00000   551:        $result->{reason} = $todo;
        0   0.00000   0.00000   552:        $result->{type}   = 'todo';
        0   0.00000   0.00000   553:    }
        0   0.00000   0.00000   554:    else {
        1   0.00000   0.00000   555:        $result->{reason} = '';
        1   0.00000   0.00000   556:        $result->{type}   = '';
        0   0.00000   0.00000   557:    }
        0   0.00000   0.00000   558:
        1   0.00000   0.00000   559:    $self->{Test_Results}[ $self->{Curr_Test}
        1   0.00000   0.00000   560:    $out .= "\n";
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 162
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   561:
        1   0.00000   0.00000   562:    $self->_print($out);
        0   0.00000   0.00000   563:
        1   0.00000   0.00000   564:    unless($test) {
        1   0.00000   0.00000   565:        my $msg = $self->in_todo ? "Failed
        1   0.00000   0.00000   566:        $self->_print_to_fh( $self->_diag_fh,
        0   0.00000   0.00000   567:
        1   0.00000   0.00000   568:        my( undef, $file, $line ) = $self-
        1   0.00000   0.00000   569:        if( defined $name ) {
        1   0.00000   0.00000   570:            $self->diag(qq[  $msg test
        1   0.00000   0.00000   571:            $self->diag(qq[  at $file line
        0   0.00000   0.00000   572:        }
        0   0.00000   0.00000   573:        else {
        0   0.00000   0.00000   574:            $self->diag(qq[  $msg test at
        0   0.00000   0.00000   575:        }
        0   0.00000   0.00000   576:    }
        0   0.00000   0.00000   577:
        1   0.00000   0.00000   578:    return $test ? 1 : 0;
        0   0.00000   0.00000   579:}
        0   0.00000   0.00000   580:
        0   0.00000   0.00000   581:sub _unoverload {
        4   0.00000   0.00000   582:    my $self = shift;
        4   0.00000   0.00000   583:    my $type = shift;
        0   0.00000   0.00000   584:
        8   0.00000   0.00000   585:    $self->_try(sub { require overload; },
        0   0.00000   0.00000   586:
        4   0.00000   0.00000   587:    foreach my $thing (@_) {
        6   0.00000   0.00000   588:        if( $self->_is_object($$thing) ) {
        0   0.00000   0.00000   589:            if( my $string_meth =
        0   0.00000   0.00000   590:                $$thing = $$thing-
        0   0.00000   0.00000   591:            }
        0   0.00000   0.00000   592:        }
        0   0.00000   0.00000   593:    }
        0   0.00000   0.00000   594:
        4   0.00000   0.00000   595:    return;
        0   0.00000   0.00000   596:}
        0   0.00000   0.00000   597:
        0   0.00000   0.00000   598:sub _is_object {
        6   0.00000   0.00000   599:    my( $self, $thing ) = @_;
        0   0.00000   0.00000   600:
       12   0.00000   0.00000   601:    return $self->_try( sub { ref $thing &&
        0   0.00000   0.00000   602:}
        0   0.00000   0.00000   603:
        0   0.00000   0.00000   604:sub _unoverload_str {
        4   0.00000   0.00000   605:    my $self = shift;
        0   0.00000   0.00000   606:
        4   0.00000   0.00000   607:    return $self->_unoverload( q[""], @_ );
        0   0.00000   0.00000   608:}
        0   0.00000   0.00000   609:
        0   0.00000   0.00000   610:sub _unoverload_num {
        0   0.00000   0.00000   611:    my $self = shift;
        0   0.00000   0.00000   612:
        0   0.00000   0.00000   613:    $self->_unoverload( '0+', @_ );
        0   0.00000   0.00000   614:
        0   0.00000   0.00000   615:    for my $val (@_) {
        0   0.00000   0.00000   616:        next unless $self-
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 163
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   617:        $$val = $$val + 0;
        0   0.00000   0.00000   618:    }
        0   0.00000   0.00000   619:
        0   0.00000   0.00000   620:    return;
        0   0.00000   0.00000   621:}
        0   0.00000   0.00000   622:
        0   0.00000   0.00000   623:# This is a hack to detect a dualvar such as
        0   0.00000   0.00000   624:sub _is_dualvar {
        0   0.00000   0.00000   625:    my( $self, $val ) = @_;
        0   0.00000   0.00000   626:
        0   0.00000   0.00000   627:    # Objects are not dualvars.
        0   0.00000   0.00000   628:    return 0 if ref $val;
        0   0.00000   0.00000   629:
        0   0.00000   0.00000   630:    no warnings 'numeric';
        0   0.00000   0.00000   631:    my $numval = $val + 0;
        0   0.00000   0.00000   632:    return $numval != 0 and $numval ne $val ?
        0   0.00000   0.00000   633:}
        0   0.00000   0.00000   634:
        0   0.00000   0.00000   635:=item B<is_eq>
        0   0.00000   0.00000   636:
        0   0.00000   0.00000   637:
        0   0.00000   0.00000   638:
        0   0.00000   0.00000   639:
        0   0.00000   0.00000   640:
        0   0.00000   0.00000   641:
        0   0.00000   0.00000   642:
        0   0.00000   0.00000   643:
        0   0.00000   0.00000   644:
        0   0.00000   0.00000   645:
        0   0.00000   0.00000   646:
        0   0.00000   0.00000   647:
        0   0.00000   0.00000   648:
        0   0.00000   0.00000   649:
        0   0.00000   0.00000   650:
        0   0.00000   0.00000   651:sub is_eq {
        1   0.00000   0.00000   652:    my( $self, $got, $expect, $name ) = @_;
        1   0.00000   0.00000   653:    local $Level = $Level + 1;
        0   0.00000   0.00000   654:
        1   0.00000   0.00000   655:    $self->_unoverload_str( \$got, \$expect
        0   0.00000   0.00000   656:
        1   0.00000   0.00000   657:    if( !defined $got || !defined $expect ) {
        0   0.00000   0.00000   658:        # undef only matches undef and
        0   0.00000   0.00000   659:        my $test = !defined $got && !defined
        0   0.00000   0.00000   660:
        0   0.00000   0.00000   661:        $self->ok( $test, $name );
        0   0.00000   0.00000   662:        $self->_is_diag( $got, 'eq', $expect
        0   0.00000   0.00000   663:        return $test;
        0   0.00000   0.00000   664:    }
        0   0.00000   0.00000   665:
        1   0.00000   0.00000   666:    return $self->cmp_ok( $got, 'eq',
        0   0.00000   0.00000   667:}
        0   0.00000   0.00000   668:
        0   0.00000   0.00000   669:sub is_num {
        0   0.00000   0.00000   670:    my( $self, $got, $expect, $name ) = @_;
        0   0.00000   0.00000   671:    local $Level = $Level + 1;
        0   0.00000   0.00000   672:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 164
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   673:    $self->_unoverload_num( \$got, \$expect
        0   0.00000   0.00000   674:
        0   0.00000   0.00000   675:    if( !defined $got || !defined $expect ) {
        0   0.00000   0.00000   676:        # undef only matches undef and
        0   0.00000   0.00000   677:        my $test = !defined $got && !defined
        0   0.00000   0.00000   678:
        0   0.00000   0.00000   679:        $self->ok( $test, $name );
        0   0.00000   0.00000   680:        $self->_is_diag( $got, '==', $expect
        0   0.00000   0.00000   681:        return $test;
        0   0.00000   0.00000   682:    }
        0   0.00000   0.00000   683:
        0   0.00000   0.00000   684:    return $self->cmp_ok( $got, '==',
        0   0.00000   0.00000   685:}
        0   0.00000   0.00000   686:
        0   0.00000   0.00000   687:sub _diag_fmt {
        2   0.00000   0.00000   688:    my( $self, $type, $val ) = @_;
        0   0.00000   0.00000   689:
        2   0.00000   0.00000   690:    if( defined $$val ) {
        2   0.00000   0.00000   691:        if( $type eq 'eq' or $type eq 'ne' )
        0   0.00000   0.00000   692:            # quote and force string context
        2   0.00000   0.00000   693:            $$val = "'$$val'";
        0   0.00000   0.00000   694:        }
        0   0.00000   0.00000   695:        else {
        0   0.00000   0.00000   696:            # force numeric context
        0   0.00000   0.00000   697:            $self->_unoverload_num($val);
        0   0.00000   0.00000   698:        }
        0   0.00000   0.00000   699:    }
        0   0.00000   0.00000   700:    else {
        0   0.00000   0.00000   701:        $$val = 'undef';
        0   0.00000   0.00000   702:    }
        0   0.00000   0.00000   703:
        2   0.00000   0.00000   704:    return;
        0   0.00000   0.00000   705:}
        0   0.00000   0.00000   706:
        0   0.00000   0.00000   707:sub _is_diag {
        1   0.00000   0.00000   708:    my( $self, $got, $type, $expect ) = @_;
        0   0.00000   0.00000   709:
        2   0.00000   0.00000   710:    $self->_diag_fmt( $type, $_ ) for \$got,
        0   0.00000   0.00000   711:
        1   0.00000   0.00000   712:    local $Level = $Level + 1;
        1   0.00000   0.00000   713:    return $self->diag(<<"DIAGNOSTIC");
        0   0.00000   0.00000   714:         got: $got
        0   0.00000   0.00000   715:    expected: $expect
        0   0.00000   0.00000   716:DIAGNOSTIC
        0   0.00000   0.00000   717:
        0   0.00000   0.00000   718:}
        0   0.00000   0.00000   719:
        0   0.00000   0.00000   720:sub _isnt_diag {
        0   0.00000   0.00000   721:    my( $self, $got, $type ) = @_;
        0   0.00000   0.00000   722:
        0   0.00000   0.00000   723:    $self->_diag_fmt( $type, \$got );
        0   0.00000   0.00000   724:
        0   0.00000   0.00000   725:    local $Level = $Level + 1;
        0   0.00000   0.00000   726:    return $self->diag(<<"DIAGNOSTIC");
        0   0.00000   0.00000   727:         got: $got
        0   0.00000   0.00000   728:    expected: anything else
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 165
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   729:DIAGNOSTIC
        0   0.00000   0.00000   730:}
        0   0.00000   0.00000   731:
        0   0.00000   0.00000   732:=item B<isnt_eq>
        0   0.00000   0.00000   733:
        0   0.00000   0.00000   734:
        0   0.00000   0.00000   735:
        0   0.00000   0.00000   736:
        0   0.00000   0.00000   737:
        0   0.00000   0.00000   738:
        0   0.00000   0.00000   739:
        0   0.00000   0.00000   740:
        0   0.00000   0.00000   741:
        0   0.00000   0.00000   742:
        0   0.00000   0.00000   743:
        0   0.00000   0.00000   744:
        0   0.00000   0.00000   745:
        0   0.00000   0.00000   746:
        0   0.00000   0.00000   747:
        0   0.00000   0.00000   748:sub isnt_eq {
        0   0.00000   0.00000   749:    my( $self, $got, $dont_expect, $name ) =
        0   0.00000   0.00000   750:    local $Level = $Level + 1;
        0   0.00000   0.00000   751:
        0   0.00000   0.00000   752:    if( !defined $got || !defined
        0   0.00000   0.00000   753:        # undef only matches undef and
        0   0.00000   0.00000   754:        my $test = defined $got || defined
        0   0.00000   0.00000   755:
        0   0.00000   0.00000   756:        $self->ok( $test, $name );
        0   0.00000   0.00000   757:        $self->_isnt_diag( $got, 'ne' )
        0   0.00000   0.00000   758:        return $test;
        0   0.00000   0.00000   759:    }
        0   0.00000   0.00000   760:
        0   0.00000   0.00000   761:    return $self->cmp_ok( $got, 'ne',
        0   0.00000   0.00000   762:}
        0   0.00000   0.00000   763:
        0   0.00000   0.00000   764:sub isnt_num {
        0   0.00000   0.00000   765:    my( $self, $got, $dont_expect, $name ) =
        0   0.00000   0.00000   766:    local $Level = $Level + 1;
        0   0.00000   0.00000   767:
        0   0.00000   0.00000   768:    if( !defined $got || !defined
        0   0.00000   0.00000   769:        # undef only matches undef and
        0   0.00000   0.00000   770:        my $test = defined $got || defined
        0   0.00000   0.00000   771:
        0   0.00000   0.00000   772:        $self->ok( $test, $name );
        0   0.00000   0.00000   773:        $self->_isnt_diag( $got, '!=' )
        0   0.00000   0.00000   774:        return $test;
        0   0.00000   0.00000   775:    }
        0   0.00000   0.00000   776:
        0   0.00000   0.00000   777:    return $self->cmp_ok( $got, '!=',
        0   0.00000   0.00000   778:}
        0   0.00000   0.00000   779:
        0   0.00000   0.00000   780:=item B<like>
        0   0.00000   0.00000   781:
        0   0.00000   0.00000   782:
        0   0.00000   0.00000   783:
        0   0.00000   0.00000   784:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 166
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   785:
        0   0.00000   0.00000   786:
        0   0.00000   0.00000   787:
        0   0.00000   0.00000   788:
        0   0.00000   0.00000   789:
        0   0.00000   0.00000   790:
        0   0.00000   0.00000   791:
        0   0.00000   0.00000   792:
        0   0.00000   0.00000   793:
        0   0.00000   0.00000   794:
        0   0.00000   0.00000   795:
        0   0.00000   0.00000   796:
        0   0.00000   0.00000   797:
        0   0.00000   0.00000   798:
        0   0.00000   0.00000   799:sub like {
        0   0.00000   0.00000   800:    my( $self, $this, $regex, $name ) = @_;
        0   0.00000   0.00000   801:
        0   0.00000   0.00000   802:    local $Level = $Level + 1;
        0   0.00000   0.00000   803:    return $self->_regex_ok( $this, $regex,
        0   0.00000   0.00000   804:}
        0   0.00000   0.00000   805:
        0   0.00000   0.00000   806:sub unlike {
        0   0.00000   0.00000   807:    my( $self, $this, $regex, $name ) = @_;
        0   0.00000   0.00000   808:
        0   0.00000   0.00000   809:    local $Level = $Level + 1;
        0   0.00000   0.00000   810:    return $self->_regex_ok( $this, $regex,
        0   0.00000   0.00000   811:}
        0   0.00000   0.00000   812:
        0   0.00000   0.00000   813:=item B<cmp_ok>
        0   0.00000   0.00000   814:
        0   0.00000   0.00000   815:
        0   0.00000   0.00000   816:
        0   0.00000   0.00000   817:
        0   0.00000   0.00000   818:
        0   0.00000   0.00000   819:
        0   0.00000   0.00000   820:
        0   0.00000   0.00000   821:
        0   0.00000   0.00000   822:
        0   0.00000   0.00000   823:my %numeric_cmps = map { ( $_, 1 ) } ( "<",
        0   0.00000   0.00000   824:
        0   0.00000   0.00000   825:sub cmp_ok {
        1   0.00000   0.00000   826:    my( $self, $got, $type, $expect, $name )
        0   0.00000   0.00000   827:
        1   0.00000   0.00000   828:    my $test;
        1   0.00000   0.00000   829:    my $error;
        0   0.00000   0.00000   830:    {
        0   0.00000   0.00000   831:        ## no critic
        0   0.00000   0.00000   832:
        2   0.00000   0.00000   833:        local( $@, $!, $SIG{__DIE__} );    #
        0   0.00000   0.00000   834:
        1   0.00000   0.00000   835:        my($pack, $file, $line) = $self-
        0   0.00000   0.00000   836:
        1   0.00009   0.00000   837:        $test = eval qq[
        0   0.00000   0.00000   838:#line 1 "cmp_ok [from $file line $line]"
        0   0.00000   0.00000   839:\$got $type \$expect;
        0   0.00000   0.00000   840:];
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 167
       =================================================================
    count wall tm  cpu time line
        1   0.00000   0.00000   841:        $error = $@;
        0   0.00000   0.00000   842:    }
        1   0.00000   0.00000   843:    local $Level = $Level + 1;
        1   0.00000   0.00000   844:    my $ok = $self->ok( $test, $name );
        0   0.00000   0.00000   845:
        0   0.00000   0.00000   846:    # Treat overloaded objects as numbers if
        0   0.00000   0.00000   847:    # numeric comparison.
        1   0.00000   0.00000   848:    my $unoverload
        0   0.00000   0.00000   849:      = $numeric_cmps{$type}
        0   0.00000   0.00000   850:      ? '_unoverload_num'
        0   0.00000   0.00000   851:      : '_unoverload_str';
        0   0.00000   0.00000   852:
        1   0.00000   0.00000   853:    $self->diag(<<"END") if $error;
        0   0.00000   0.00000   854:An error occurred while using $type:
        0   0.00000   0.00000   855:------------------------------------
        0   0.00000   0.00000   856:$error
        0   0.00000   0.00000   857:------------------------------------
        0   0.00000   0.00000   858:END
        0   0.00000   0.00000   859:
        1   0.00000   0.00000   860:    unless($ok) {
        1   0.00000   0.00000   861:        $self->$unoverload( \$got, \$expect
        0   0.00000   0.00000   862:
        1   0.00000   0.00000   863:        if( $type =~ /^(eq|==)$/ ) {
        0   0.00000   0.00000   864:            $self->_is_diag( $got, $type,
        0   0.00000   0.00000   865:        }
        0   0.00000   0.00000   866:        elsif( $type =~ /^(ne|!=)$/ ) {
        0   0.00000   0.00000   867:            $self->_isnt_diag( $got, $type );
        0   0.00000   0.00000   868:        }
        0   0.00000   0.00000   869:        else {
        0   0.00000   0.00000   870:            $self->_cmp_diag( $got, $type,
        0   0.00000   0.00000   871:        }
        0   0.00000   0.00000   872:    }
        1   0.00002   0.00000   873:    return $ok;
        0   0.00000   0.00000   874:}
        0   0.00000   0.00000   875:
        0   0.00000   0.00000   876:sub _cmp_diag {
        0   0.00000   0.00000   877:    my( $self, $got, $type, $expect ) = @_;
        0   0.00000   0.00000   878:
        0   0.00000   0.00000   879:    $got    = defined $got    ? "'$got'"    :
        0   0.00000   0.00000   880:    $expect = defined $expect ? "'$expect'" :
        0   0.00000   0.00000   881:
        0   0.00000   0.00000   882:    local $Level = $Level + 1;
        0   0.00000   0.00000   883:    return $self->diag(<<"DIAGNOSTIC");
        0   0.00000   0.00000   884:    $got
        0   0.00000   0.00000   885:        $type
        0   0.00000   0.00000   886:    $expect
        0   0.00000   0.00000   887:DIAGNOSTIC
        0   0.00000   0.00000   888:}
        0   0.00000   0.00000   889:
        0   0.00000   0.00000   890:sub _caller_context {
        0   0.00000   0.00000   891:    my $self = shift;
        0   0.00000   0.00000   892:
        0   0.00000   0.00000   893:    my( $pack, $file, $line ) = $self-
        0   0.00000   0.00000   894:
        0   0.00000   0.00000   895:    my $code = '';
        0   0.00000   0.00000   896:    $code .= "#line $line $file\n" if defined
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 168
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   897:
        0   0.00000   0.00000   898:    return $code;
        0   0.00000   0.00000   899:}
        0   0.00000   0.00000   900:
        0   0.00000   0.00000   901:=back
        0   0.00000   0.00000   902:
        0   0.00000   0.00000   903:
        0   0.00000   0.00000   904:
        0   0.00000   0.00000   905:
        0   0.00000   0.00000   906:
        0   0.00000   0.00000   907:
        0   0.00000   0.00000   908:
        0   0.00000   0.00000   909:
        0   0.00000   0.00000   910:
        0   0.00000   0.00000   911:
        0   0.00000   0.00000   912:
        0   0.00000   0.00000   913:
        0   0.00000   0.00000   914:
        0   0.00000   0.00000   915:
        0   0.00000   0.00000   916:
        0   0.00000   0.00000   917:
        0   0.00000   0.00000   918:
        0   0.00000   0.00000   919:
        0   0.00000   0.00000   920:
        0   0.00000   0.00000   921:
        0   0.00000   0.00000   922:sub BAIL_OUT {
        0   0.00000   0.00000   923:    my( $self, $reason ) = @_;
        0   0.00000   0.00000   924:
        0   0.00000   0.00000   925:    $self->{Bailed_Out} = 1;
        0   0.00000   0.00000   926:    $self->_print("Bail out!  $reason");
        0   0.00000   0.00000   927:    exit 255;
        0   0.00000   0.00000   928:}
        0   0.00000   0.00000   929:
        0   0.00000   0.00000   930:=for deprecated
        0   0.00000   0.00000   931:
        0   0.00000   0.00000   932:
        0   0.00000   0.00000   933:
        0   0.00000   0.00000   934:
        0   0.00000   0.00000   935:*BAILOUT = \&BAIL_OUT;
        0   0.00000   0.00000   936:
        0   0.00000   0.00000   937:=item B<skip>
        0   0.00000   0.00000   938:
        0   0.00000   0.00000   939:
        0   0.00000   0.00000   940:
        0   0.00000   0.00000   941:
        0   0.00000   0.00000   942:
        0   0.00000   0.00000   943:
        0   0.00000   0.00000   944:
        0   0.00000   0.00000   945:
        0   0.00000   0.00000   946:sub skip {
        0   0.00000   0.00000   947:    my( $self, $why ) = @_;
        0   0.00000   0.00000   948:    $why ||= '';
        0   0.00000   0.00000   949:    $self->_unoverload_str( \$why );
        0   0.00000   0.00000   950:
        0   0.00000   0.00000   951:    lock( $self->{Curr_Test} );
        0   0.00000   0.00000   952:    $self->{Curr_Test}++;
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 169
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   953:
        0   0.00000   0.00000   954:    $self->{Test_Results}[ $self->{Curr_Test}
        0   0.00000   0.00000   955:        {
        0   0.00000   0.00000   956:            'ok'      => 1,
        0   0.00000   0.00000   957:            actual_ok => 1,
        0   0.00000   0.00000   958:            name      => '',
        0   0.00000   0.00000   959:            type      => 'skip',
        0   0.00000   0.00000   960:            reason    => $why,
        0   0.00000   0.00000   961:        }
        0   0.00000   0.00000   962:    );
        0   0.00000   0.00000   963:
        0   0.00000   0.00000   964:    my $out = "ok";
        0   0.00000   0.00000   965:    $out .= " $self->{Curr_Test}" if $self-
        0   0.00000   0.00000   966:    $out .= " # skip";
        0   0.00000   0.00000   967:    $out .= " $why"               if length
        0   0.00000   0.00000   968:    $out .= "\n";
        0   0.00000   0.00000   969:
        0   0.00000   0.00000   970:    $self->_print($out);
        0   0.00000   0.00000   971:
        0   0.00000   0.00000   972:    return 1;
        0   0.00000   0.00000   973:}
        0   0.00000   0.00000   974:
        0   0.00000   0.00000   975:=item B<todo_skip>
        0   0.00000   0.00000   976:
        0   0.00000   0.00000   977:
        0   0.00000   0.00000   978:
        0   0.00000   0.00000   979:
        0   0.00000   0.00000   980:
        0   0.00000   0.00000   981:
        0   0.00000   0.00000   982:
        0   0.00000   0.00000   983:
        0   0.00000   0.00000   984:
        0   0.00000   0.00000   985:
        0   0.00000   0.00000   986:
        0   0.00000   0.00000   987:sub todo_skip {
        0   0.00000   0.00000   988:    my( $self, $why ) = @_;
        0   0.00000   0.00000   989:    $why ||= '';
        0   0.00000   0.00000   990:
        0   0.00000   0.00000   991:    lock( $self->{Curr_Test} );
        0   0.00000   0.00000   992:    $self->{Curr_Test}++;
        0   0.00000   0.00000   993:
        0   0.00000   0.00000   994:    $self->{Test_Results}[ $self->{Curr_Test}
        0   0.00000   0.00000   995:        {
        0   0.00000   0.00000   996:            'ok'      => 1,
        0   0.00000   0.00000   997:            actual_ok => 0,
        0   0.00000   0.00000   998:            name      => '',
        0   0.00000   0.00000   999:            type      => 'todo_skip',
        0   0.00000   0.00000  1000:            reason    => $why,
        0   0.00000   0.00000  1001:        }
        0   0.00000   0.00000  1002:    );
        0   0.00000   0.00000  1003:
        0   0.00000   0.00000  1004:    my $out = "not ok";
        0   0.00000   0.00000  1005:    $out .= " $self->{Curr_Test}" if $self-
        0   0.00000   0.00000  1006:    $out .= " # TODO & SKIP $why\n";
        0   0.00000   0.00000  1007:
        0   0.00000   0.00000  1008:    $self->_print($out);
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 170
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1009:
        0   0.00000   0.00000  1010:    return 1;
        0   0.00000   0.00000  1011:}
        0   0.00000   0.00000  1012:
        0   0.00000   0.00000  1013:=begin _unimplemented
        0   0.00000   0.00000  1014:
        0   0.00000   0.00000  1015:
        0   0.00000   0.00000  1016:
        0   0.00000   0.00000  1017:
        0   0.00000   0.00000  1018:
        0   0.00000   0.00000  1019:
        0   0.00000   0.00000  1020:
        0   0.00000   0.00000  1021:
        0   0.00000   0.00000  1022:
        0   0.00000   0.00000  1023:
        0   0.00000   0.00000  1024:
        0   0.00000   0.00000  1025:
        0   0.00000   0.00000  1026:
        0   0.00000   0.00000  1027:
        0   0.00000   0.00000  1028:
        0   0.00000   0.00000  1029:
        0   0.00000   0.00000  1030:
        0   0.00000   0.00000  1031:
        0   0.00000   0.00000  1032:
        0   0.00000   0.00000  1033:
        0   0.00000   0.00000  1034:
        0   0.00000   0.00000  1035:
        0   0.00000   0.00000  1036:
        0   0.00000   0.00000  1037:
        0   0.00000   0.00000  1038:
        0   0.00000   0.00000  1039:
        0   0.00000   0.00000  1040:
        0   0.00000   0.00000  1041:
        0   0.00000   0.00000  1042:
        0   0.00000   0.00000  1043:
        0   0.00000   0.00000  1044:
        0   0.00000   0.00000  1045:
        0   0.00000   0.00000  1046:
        0   0.00000   0.00000  1047:
        0   0.00000   0.00000  1048:
        0   0.00000   0.00000  1049:
        0   0.00000   0.00000  1050:
        0   0.00000   0.00000  1051:
        0   0.00000   0.00000  1052:
        0   0.00000   0.00000  1053:
        0   0.00000   0.00000  1054:
        0   0.00000   0.00000  1055:
        0   0.00000   0.00000  1056:
        0   0.00000   0.00000  1057:
        0   0.00000   0.00000  1058:
        0   0.00000   0.00000  1059:
        0   0.00000   0.00000  1060:
        0   0.00000   0.00000  1061:
        0   0.00000   0.00000  1062:
        0   0.00000   0.00000  1063:
        0   0.00000   0.00000  1064:sub maybe_regex {
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 171
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1065:    my( $self, $regex ) = @_;
        0   0.00000   0.00000  1066:    my $usable_regex = undef;
        0   0.00000   0.00000  1067:
        0   0.00000   0.00000  1068:    return $usable_regex unless defined
        0   0.00000   0.00000  1069:
        0   0.00000   0.00000  1070:    my( $re, $opts );
        0   0.00000   0.00000  1071:
        0   0.00000   0.00000  1072:    # Check for qr/foo/
        0   0.00000   0.00000  1073:    if( _is_qr($regex) ) {
        0   0.00000   0.00000  1074:        $usable_regex = $regex;
        0   0.00000   0.00000  1075:    }
        0   0.00000   0.00000  1076:    # Check for '/foo/' or 'm,foo,'
        0   0.00000   0.00000  1077:    elsif(( $re, $opts )        = $regex =~
        0   0.00000   0.00000  1078:          ( undef, $re, $opts ) = $regex =~
        0   0.00000   0.00000  1079:    )
        0   0.00000   0.00000  1080:    {
        0   0.00000   0.00000  1081:        $usable_regex = length $opts ?
        0   0.00000   0.00000  1082:    }
        0   0.00000   0.00000  1083:
        0   0.00000   0.00000  1084:    return $usable_regex;
        0   0.00000   0.00000  1085:}
        0   0.00000   0.00000  1086:
        0   0.00000   0.00000  1087:sub _is_qr {
        0   0.00000   0.00000  1088:    my $regex = shift;
        0   0.00000   0.00000  1089:
        0   0.00000   0.00000  1090:    # is_regexp() checks for regexes in a
        0   0.00000   0.00000  1091:    # blessed.
        0   0.00000   0.00000  1092:    return re::is_regexp($regex) if defined
        0   0.00000   0.00000  1093:    return ref $regex eq 'Regexp';
        0   0.00000   0.00000  1094:}
        0   0.00000   0.00000  1095:
        0   0.00000   0.00000  1096:sub _regex_ok {
        0   0.00000   0.00000  1097:    my( $self, $this, $regex, $cmp, $name ) =
        0   0.00000   0.00000  1098:
        0   0.00000   0.00000  1099:    my $ok           = 0;
        0   0.00000   0.00000  1100:    my $usable_regex = $self-
        0   0.00000   0.00000  1101:    unless( defined $usable_regex ) {
        0   0.00000   0.00000  1102:        local $Level = $Level + 1;
        0   0.00000   0.00000  1103:        $ok = $self->ok( 0, $name );
        0   0.00000   0.00000  1104:        $self->diag("    '$regex' doesn't
        0   0.00000   0.00000  1105:        return $ok;
        0   0.00000   0.00000  1106:    }
        0   0.00000   0.00000  1107:
        0   0.00000   0.00000  1108:    {
        0   0.00000   0.00000  1109:        ## no critic
        0   0.00000   0.00000  1110:
        0   0.00000   0.00000  1111:        my $test;
        0   0.00000   0.00000  1112:        my $code = $self->_caller_context;
        0   0.00000   0.00000  1113:
        0   0.00000   0.00000  1114:        local( $@, $!, $SIG{__DIE__} );    #
        0   0.00000   0.00000  1115:
        0   0.00000   0.00000  1116:        # Yes, it has to look like this or
        0   0.00000   0.00000  1117:        # directive.
        0   0.00000   0.00000  1118:        # Don't ask me, man, I just work
        0   0.00000   0.00000  1119:        $test = eval "
        0   0.00000   0.00000  1120:$code" . q{$test = $this =~ /$usable_regex/ ?
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 172
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1121:
        0   0.00000   0.00000  1122:        $test = !$test if $cmp eq '!~';
        0   0.00000   0.00000  1123:
        0   0.00000   0.00000  1124:        local $Level = $Level + 1;
        0   0.00000   0.00000  1125:        $ok = $self->ok( $test, $name );
        0   0.00000   0.00000  1126:    }
        0   0.00000   0.00000  1127:
        0   0.00000   0.00000  1128:    unless($ok) {
        0   0.00000   0.00000  1129:        $this = defined $this ? "'$this'" :
        0   0.00000   0.00000  1130:        my $match = $cmp eq '=~' ? "doesn't
        0   0.00000   0.00000  1131:
        0   0.00000   0.00000  1132:        local $Level = $Level + 1;
        0   0.00000   0.00000  1133:        $self->diag( sprintf <<'DIAGNOSTIC',
        0   0.00000   0.00000  1134:                  %s
        0   0.00000   0.00000  1135:    %13s '%s'
        0   0.00000   0.00000  1136:DIAGNOSTIC
        0   0.00000   0.00000  1137:
        0   0.00000   0.00000  1138:    }
        0   0.00000   0.00000  1139:
        0   0.00000   0.00000  1140:    return $ok;
        0   0.00000   0.00000  1141:}
        0   0.00000   0.00000  1142:
        0   0.00000   0.00000  1143:# I'm not ready to publish this.  It doesn't
        0   0.00000   0.00000  1144:# values from the code or context.
        0   0.00000   0.00000  1145:
        0   0.00000   0.00000  1146:=begin private
        0   0.00000   0.00000  1147:
        0   0.00000   0.00000  1148:
        0   0.00000   0.00000  1149:
        0   0.00000   0.00000  1150:
        0   0.00000   0.00000  1151:
        0   0.00000   0.00000  1152:
        0   0.00000   0.00000  1153:
        0   0.00000   0.00000  1154:
        0   0.00000   0.00000  1155:
        0   0.00000   0.00000  1156:
        0   0.00000   0.00000  1157:
        0   0.00000   0.00000  1158:
        0   0.00000   0.00000  1159:
        0   0.00000   0.00000  1160:
        0   0.00000   0.00000  1161:
        0   0.00000   0.00000  1162:
        0   0.00000   0.00000  1163:
        0   0.00000   0.00000  1164:sub _try {
       10   0.00000   0.00000  1165:    my( $self, $code, %opts ) = @_;
        0   0.00000   0.00000  1166:
       10   0.00000   0.00000  1167:    my $error;
       10   0.00000   0.00000  1168:    my $return;
        0   0.00000   0.00000  1169:    {
       20   0.00000   0.00000  1170:        local $!;               # eval can
       10   0.00000   0.00000  1171:        local $@;               # don't set
       10   0.00000   0.00000  1172:        local $SIG{__DIE__};    # don't trip
       20   0.00000   0.00000  1173:        $return = eval { $code->() };
       10   0.00000   0.00000  1174:        $error = $@;
        0   0.00000   0.00000  1175:    }
        0   0.00000   0.00000  1176:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 173
       =================================================================
    count wall tm  cpu time line
       10   0.00000   0.00000  1177:    die $error if $error and
        0   0.00000   0.00000  1178:
       10   0.00000   0.00000  1179:    return wantarray ? ( $return, $error ) :
        0   0.00000   0.00000  1180:}
        0   0.00000   0.00000  1181:
        0   0.00000   0.00000  1182:=end private
        0   0.00000   0.00000  1183:
        0   0.00000   0.00000  1184:
        0   0.00000   0.00000  1185:
        0   0.00000   0.00000  1186:
        0   0.00000   0.00000  1187:
        0   0.00000   0.00000  1188:
        0   0.00000   0.00000  1189:
        0   0.00000   0.00000  1190:
        0   0.00000   0.00000  1191:
        0   0.00000   0.00000  1192:
        0   0.00000   0.00000  1193:sub is_fh {
        0   0.00000   0.00000  1194:    my $self     = shift;
        0   0.00000   0.00000  1195:    my $maybe_fh = shift;
        0   0.00000   0.00000  1196:    return 0 unless defined $maybe_fh;
        0   0.00000   0.00000  1197:
        0   0.00000   0.00000  1198:    return 1 if ref $maybe_fh  eq 'GLOB';
        0   0.00000   0.00000  1199:    return 1 if ref \$maybe_fh eq 'GLOB';
        0   0.00000   0.00000  1200:
        0   0.00000   0.00000  1201:    return eval { $maybe_fh-
        0   0.00000   0.00000  1202:           # 5.5.4's tied() and can() doesn't
        0   0.00000   0.00000  1203:           eval { ( tied($maybe_fh) || '' )-
        0   0.00000   0.00000  1204:}
        0   0.00000   0.00000  1205:
        0   0.00000   0.00000  1206:=back
        0   0.00000   0.00000  1207:
        0   0.00000   0.00000  1208:
        0   0.00000   0.00000  1209:
        0   0.00000   0.00000  1210:
        0   0.00000   0.00000  1211:
        0   0.00000   0.00000  1212:
        0   0.00000   0.00000  1213:
        0   0.00000   0.00000  1214:
        0   0.00000   0.00000  1215:
        0   0.00000   0.00000  1216:
        0   0.00000   0.00000  1217:
        0   0.00000   0.00000  1218:
        0   0.00000   0.00000  1219:
        0   0.00000   0.00000  1220:
        0   0.00000   0.00000  1221:
        0   0.00000   0.00000  1222:
        0   0.00000   0.00000  1223:
        0   0.00000   0.00000  1224:
        0   0.00000   0.00000  1225:
        0   0.00000   0.00000  1226:
        0   0.00000   0.00000  1227:
        0   0.00000   0.00000  1228:
        0   0.00000   0.00000  1229:
        0   0.00000   0.00000  1230:
        0   0.00000   0.00000  1231:
        0   0.00000   0.00000  1232:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 174
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1233:
        0   0.00000   0.00000  1234:
        0   0.00000   0.00000  1235:
        0   0.00000   0.00000  1236:
        0   0.00000   0.00000  1237:sub level {
       11   0.00000   0.00000  1238:    my( $self, $level ) = @_;
        0   0.00000   0.00000  1239:
       11   0.00000   0.00000  1240:    if( defined $level ) {
        0   0.00000   0.00000  1241:        $Level = $level;
        0   0.00000   0.00000  1242:    }
       11   0.00000   0.00000  1243:    return $Level;
        0   0.00000   0.00000  1244:}
        0   0.00000   0.00000  1245:
        0   0.00000   0.00000  1246:=item B<use_numbers>
        0   0.00000   0.00000  1247:
        0   0.00000   0.00000  1248:
        0   0.00000   0.00000  1249:
        0   0.00000   0.00000  1250:
        0   0.00000   0.00000  1251:
        0   0.00000   0.00000  1252:
        0   0.00000   0.00000  1253:
        0   0.00000   0.00000  1254:
        0   0.00000   0.00000  1255:
        0   0.00000   0.00000  1256:
        0   0.00000   0.00000  1257:
        0   0.00000   0.00000  1258:
        0   0.00000   0.00000  1259:
        0   0.00000   0.00000  1260:
        0   0.00000   0.00000  1261:
        0   0.00000   0.00000  1262:
        0   0.00000   0.00000  1263:
        0   0.00000   0.00000  1264:
        0   0.00000   0.00000  1265:
        0   0.00000   0.00000  1266:
        0   0.00000   0.00000  1267:
        0   0.00000   0.00000  1268:
        0   0.00000   0.00000  1269:sub use_numbers {
        1   0.00000   0.00000  1270:    my( $self, $use_nums ) = @_;
        0   0.00000   0.00000  1271:
        1   0.00000   0.00000  1272:    if( defined $use_nums ) {
        0   0.00000   0.00000  1273:        $self->{Use_Nums} = $use_nums;
        0   0.00000   0.00000  1274:    }
        1   0.00000   0.00000  1275:    return $self->{Use_Nums};
        0   0.00000   0.00000  1276:}
        0   0.00000   0.00000  1277:
        0   0.00000   0.00000  1278:=item B<no_diag>
        0   0.00000   0.00000  1279:
        0   0.00000   0.00000  1280:
        0   0.00000   0.00000  1281:
        0   0.00000   0.00000  1282:
        0   0.00000   0.00000  1283:
        0   0.00000   0.00000  1284:
        0   0.00000   0.00000  1285:
        0   0.00000   0.00000  1286:
        0   0.00000   0.00000  1287:
        0   0.00000   0.00000  1288:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 175
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1289:
        0   0.00000   0.00000  1290:
        0   0.00000   0.00000  1291:
        0   0.00000   0.00000  1292:
        0   0.00000   0.00000  1293:
        0   0.00000   0.00000  1294:
        0   0.00000   0.00000  1295:
        0   0.00000   0.00000  1296:
        0   0.00000   0.00000  1297:
        0   0.00000   0.00000  1298:
        0   0.00000   0.00000  1299:
        0   0.00000   0.00000  1300:
        0   0.00000   0.00000  1301:
        0   0.00000   0.00000  1302:foreach my $attribute (qw(No_Header No_Ending
        0   0.00000   0.00000  1303:    my $method = lc $attribute;
        0   0.00000   0.00000  1304:
        0   0.00000   0.00000  1305:    my $code = sub {
        5   0.00000   0.00000  1306:        my( $self, $no ) = @_;
        0   0.00000   0.00000  1307:
        5   0.00000   0.00000  1308:        if( defined $no ) {
        0   0.00000   0.00000  1309:            $self->{$attribute} = $no;
        0   0.00000   0.00000  1310:        }
        5   0.00000   0.00000  1311:        return $self->{$attribute};
        0   0.00000   0.00000  1312:    };
        0   0.00000   0.00000  1313:
        0   0.00000   0.00000  1314:    no strict 'refs';    ## no critic
        0   0.00000   0.00000  1315:    *{ __PACKAGE__ . '::' . $method } =
        0   0.00000   0.00000  1316:}
        0   0.00000   0.00000  1317:
        0   0.00000   0.00000  1318:=back
        0   0.00000   0.00000  1319:
        0   0.00000   0.00000  1320:
        0   0.00000   0.00000  1321:
        0   0.00000   0.00000  1322:
        0   0.00000   0.00000  1323:
        0   0.00000   0.00000  1324:
        0   0.00000   0.00000  1325:
        0   0.00000   0.00000  1326:
        0   0.00000   0.00000  1327:
        0   0.00000   0.00000  1328:
        0   0.00000   0.00000  1329:
        0   0.00000   0.00000  1330:
        0   0.00000   0.00000  1331:
        0   0.00000   0.00000  1332:
        0   0.00000   0.00000  1333:
        0   0.00000   0.00000  1334:
        0   0.00000   0.00000  1335:
        0   0.00000   0.00000  1336:
        0   0.00000   0.00000  1337:
        0   0.00000   0.00000  1338:
        0   0.00000   0.00000  1339:
        0   0.00000   0.00000  1340:
        0   0.00000   0.00000  1341:
        0   0.00000   0.00000  1342:
        0   0.00000   0.00000  1343:
        0   0.00000   0.00000  1344:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 176
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1345:
        0   0.00000   0.00000  1346:
        0   0.00000   0.00000  1347:
        0   0.00000   0.00000  1348:
        0   0.00000   0.00000  1349:
        0   0.00000   0.00000  1350:
        0   0.00000   0.00000  1351:
        0   0.00000   0.00000  1352:
        0   0.00000   0.00000  1353:
        0   0.00000   0.00000  1354:
        0   0.00000   0.00000  1355:sub diag {
        4   0.00000   0.00000  1356:    my $self = shift;
        0   0.00000   0.00000  1357:
        4   0.00000   0.00000  1358:    $self->_print_comment( $self->_diag_fh,
        0   0.00000   0.00000  1359:}
        0   0.00000   0.00000  1360:
        0   0.00000   0.00000  1361:=item B<note>
        0   0.00000   0.00000  1362:
        0   0.00000   0.00000  1363:
        0   0.00000   0.00000  1364:
        0   0.00000   0.00000  1365:
        0   0.00000   0.00000  1366:
        0   0.00000   0.00000  1367:
        0   0.00000   0.00000  1368:
        0   0.00000   0.00000  1369:
        0   0.00000   0.00000  1370:sub note {
        0   0.00000   0.00000  1371:    my $self = shift;
        0   0.00000   0.00000  1372:
        0   0.00000   0.00000  1373:    $self->_print_comment( $self->output, @_
        0   0.00000   0.00000  1374:}
        0   0.00000   0.00000  1375:
        0   0.00000   0.00000  1376:sub _diag_fh {
        4   0.00000   0.00000  1377:    my $self = shift;
        0   0.00000   0.00000  1378:
        4   0.00000   0.00000  1379:    local $Level = $Level + 1;
        4   0.00000   0.00000  1380:    return $self->in_todo ? $self-
        0   0.00000   0.00000  1381:}
        0   0.00000   0.00000  1382:
        0   0.00000   0.00000  1383:sub _print_comment {
        4   0.00000   0.00000  1384:    my( $self, $fh, @msgs ) = @_;
        0   0.00000   0.00000  1385:
        4   0.00000   0.00000  1386:    return if $self->no_diag;
        4   0.00000   0.00000  1387:    return unless @msgs;
        0   0.00000   0.00000  1388:
        0   0.00000   0.00000  1389:    # Prevent printing headers when compiling
        4   0.00000   0.00000  1390:    return if $^C;
        0   0.00000   0.00000  1391:
        0   0.00000   0.00000  1392:    # Smash args together like print does.
        0   0.00000   0.00000  1393:    # Convert undef to 'undef' so its
        4   0.00000   0.00000  1394:    my $msg = join '', map { defined($_) ? $_
        0   0.00000   0.00000  1395:
        0   0.00000   0.00000  1396:    # Escape the beginning, _print will take
        4   0.00000   0.00000  1397:    $msg =~ s/^/# /;
        0   0.00000   0.00000  1398:
        4   0.00000   0.00000  1399:    local $Level = $Level + 1;
        4   0.00000   0.00000  1400:    $self->_print_to_fh( $fh, $msg );
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 177
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1401:
        4   0.00000   0.00000  1402:    return 0;
        0   0.00000   0.00000  1403:}
        0   0.00000   0.00000  1404:
        0   0.00000   0.00000  1405:=item B<explain>
        0   0.00000   0.00000  1406:
        0   0.00000   0.00000  1407:
        0   0.00000   0.00000  1408:
        0   0.00000   0.00000  1409:
        0   0.00000   0.00000  1410:
        0   0.00000   0.00000  1411:
        0   0.00000   0.00000  1412:
        0   0.00000   0.00000  1413:
        0   0.00000   0.00000  1414:
        0   0.00000   0.00000  1415:
        0   0.00000   0.00000  1416:
        0   0.00000   0.00000  1417:
        0   0.00000   0.00000  1418:
        0   0.00000   0.00000  1419:
        0   0.00000   0.00000  1420:sub explain {
        0   0.00000   0.00000  1421:    my $self = shift;
        0   0.00000   0.00000  1422:
        0   0.00000   0.00000  1423:    return map {
        0   0.00000   0.00000  1424:        ref $_
        0   0.00000   0.00000  1425:          ? do {
        0   0.00000   0.00000  1426:            $self->_try(sub { require
        0   0.00000   0.00000  1427:
        0   0.00000   0.00000  1428:            my $dumper = Data::Dumper->new(
        0   0.00000   0.00000  1429:            $dumper->Indent(1)->Terse(1);
        0   0.00000   0.00000  1430:            $dumper->Sortkeys(1) if $dumper-
        0   0.00000   0.00000  1431:            $dumper->Dump;
        0   0.00000   0.00000  1432:          }
        0   0.00000   0.00000  1433:          : $_
        0   0.00000   0.00000  1434:    } @_;
        0   0.00000   0.00000  1435:}
        0   0.00000   0.00000  1436:
        0   0.00000   0.00000  1437:=begin _private
        0   0.00000   0.00000  1438:
        0   0.00000   0.00000  1439:
        0   0.00000   0.00000  1440:
        0   0.00000   0.00000  1441:
        0   0.00000   0.00000  1442:
        0   0.00000   0.00000  1443:
        0   0.00000   0.00000  1444:
        0   0.00000   0.00000  1445:
        0   0.00000   0.00000  1446:
        0   0.00000   0.00000  1447:
        0   0.00000   0.00000  1448:
        0   0.00000   0.00000  1449:sub _print {
        1   0.00000   0.00000  1450:    my $self = shift;
        1   0.00000   0.00000  1451:    return $self->_print_to_fh( $self-
        0   0.00000   0.00000  1452:}
        0   0.00000   0.00000  1453:
        0   0.00000   0.00000  1454:sub _print_to_fh {
        5   0.00000   0.00000  1455:    my( $self, $fh, @msgs ) = @_;
        0   0.00000   0.00000  1456:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 178
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1457:    # Prevent printing headers when only
        0   0.00000   0.00000  1458:    # tests are deparsed with B::Deparse
        5   0.00000   0.00000  1459:    return if $^C;
        0   0.00000   0.00000  1460:
        5   0.00000   0.00000  1461:    my $msg = join '', @msgs;
        0   0.00000   0.00000  1462:
        5   0.00000   0.00000  1463:    local( $\, $", $, ) = ( undef, ' ', '' );
        0   0.00000   0.00000  1464:
        0   0.00000   0.00000  1465:    # Escape each line after the first with a
        0   0.00000   0.00000  1466:    # confuse Test::Harness.
        5   0.00000   0.00000  1467:    $msg =~ s{\n(?!\z)}{\n# }sg;
        0   0.00000   0.00000  1468:
        0   0.00000   0.00000  1469:    # Stick a newline on the end if it needs
        5   0.00000   0.00000  1470:    $msg .= "\n" unless $msg =~ /\n\z/;
        0   0.00000   0.00000  1471:
        5   0.00110   0.00000  1472:    return print $fh $msg;
        0   0.00000   0.00000  1473:}
        0   0.00000   0.00000  1474:
        0   0.00000   0.00000  1475:=item B<output>
        0   0.00000   0.00000  1476:
        0   0.00000   0.00000  1477:
        0   0.00000   0.00000  1478:
        0   0.00000   0.00000  1479:
        0   0.00000   0.00000  1480:
        0   0.00000   0.00000  1481:
        0   0.00000   0.00000  1482:
        0   0.00000   0.00000  1483:
        0   0.00000   0.00000  1484:
        0   0.00000   0.00000  1485:
        0   0.00000   0.00000  1486:
        0   0.00000   0.00000  1487:
        0   0.00000   0.00000  1488:
        0   0.00000   0.00000  1489:
        0   0.00000   0.00000  1490:
        0   0.00000   0.00000  1491:
        0   0.00000   0.00000  1492:
        0   0.00000   0.00000  1493:
        0   0.00000   0.00000  1494:
        0   0.00000   0.00000  1495:
        0   0.00000   0.00000  1496:
        0   0.00000   0.00000  1497:
        0   0.00000   0.00000  1498:
        0   0.00000   0.00000  1499:
        0   0.00000   0.00000  1500:
        0   0.00000   0.00000  1501:
        0   0.00000   0.00000  1502:
        0   0.00000   0.00000  1503:
        0   0.00000   0.00000  1504:
        0   0.00000   0.00000  1505:
        0   0.00000   0.00000  1506:
        0   0.00000   0.00000  1507:
        0   0.00000   0.00000  1508:sub output {
        1   0.00000   0.00000  1509:    my( $self, $fh ) = @_;
        0   0.00000   0.00000  1510:
        1   0.00000   0.00000  1511:    if( defined $fh ) {
        0   0.00000   0.00000  1512:        $self->{Out_FH} = $self-
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 179
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1513:    }
        1   0.00000   0.00000  1514:    return $self->{Out_FH};
        0   0.00000   0.00000  1515:}
        0   0.00000   0.00000  1516:
        0   0.00000   0.00000  1517:sub failure_output {
        4   0.00000   0.00000  1518:    my( $self, $fh ) = @_;
        0   0.00000   0.00000  1519:
        4   0.00000   0.00000  1520:    if( defined $fh ) {
        0   0.00000   0.00000  1521:        $self->{Fail_FH} = $self-
        0   0.00000   0.00000  1522:    }
        4   0.00000   0.00000  1523:    return $self->{Fail_FH};
        0   0.00000   0.00000  1524:}
        0   0.00000   0.00000  1525:
        0   0.00000   0.00000  1526:sub todo_output {
        0   0.00000   0.00000  1527:    my( $self, $fh ) = @_;
        0   0.00000   0.00000  1528:
        0   0.00000   0.00000  1529:    if( defined $fh ) {
        0   0.00000   0.00000  1530:        $self->{Todo_FH} = $self-
        0   0.00000   0.00000  1531:    }
        0   0.00000   0.00000  1532:    return $self->{Todo_FH};
        0   0.00000   0.00000  1533:}
        0   0.00000   0.00000  1534:
        0   0.00000   0.00000  1535:sub _new_fh {
        0   0.00000   0.00000  1536:    my $self = shift;
        0   0.00000   0.00000  1537:    my($file_or_fh) = shift;
        0   0.00000   0.00000  1538:
        0   0.00000   0.00000  1539:    my $fh;
        0   0.00000   0.00000  1540:    if( $self->is_fh($file_or_fh) ) {
        0   0.00000   0.00000  1541:        $fh = $file_or_fh;
        0   0.00000   0.00000  1542:    }
        0   0.00000   0.00000  1543:    elsif( ref $file_or_fh eq 'SCALAR' ) {
        0   0.00000   0.00000  1544:        # Scalar refs as filehandles was
        0   0.00000   0.00000  1545:        if( $] >= 5.008 ) {
        0   0.00000   0.00000  1546:            open $fh, ">>", $file_or_fh
        0   0.00000   0.00000  1547:              or $self->croak("Can't open
        0   0.00000   0.00000  1548:        }
        0   0.00000   0.00000  1549:        # Emulate scalar ref filehandles with
        0   0.00000   0.00000  1550:        else {
        0   0.00000   0.00000  1551:            $fh = Test::Builder::IO::Scalar-
        0   0.00000   0.00000  1552:              or $self->croak("Can't tie
        0   0.00000   0.00000  1553:        }
        0   0.00000   0.00000  1554:    }
        0   0.00000   0.00000  1555:    else {
        0   0.00000   0.00000  1556:        open $fh, ">", $file_or_fh
        0   0.00000   0.00000  1557:          or $self->croak("Can't open test
        0   0.00000   0.00000  1558:        _autoflush($fh);
        0   0.00000   0.00000  1559:    }
        0   0.00000   0.00000  1560:
        0   0.00000   0.00000  1561:    return $fh;
        0   0.00000   0.00000  1562:}
        0   0.00000   0.00000  1563:
        0   0.00000   0.00000  1564:sub _autoflush {
        0   0.00000   0.00000  1565:    my($fh) = shift;
        0   0.00000   0.00000  1566:    my $old_fh = select $fh;
        0   0.00000   0.00000  1567:    $| = 1;
        0   0.00000   0.00000  1568:    select $old_fh;
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 180
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1569:
        0   0.00000   0.00000  1570:    return;
        0   0.00000   0.00000  1571:}
        0   0.00000   0.00000  1572:
        0   0.00000   0.00000  1573:my( $Testout, $Testerr );
        0   0.00000   0.00000  1574:
        0   0.00000   0.00000  1575:sub _dup_stdhandles {
        0   0.00000   0.00000  1576:    my $self = shift;
        0   0.00000   0.00000  1577:
        0   0.00000   0.00000  1578:    $self->_open_testhandles;
        0   0.00000   0.00000  1579:
        0   0.00000   0.00000  1580:    # Set everything to unbuffered else plain
        0   0.00000   0.00000  1581:    # come out in the wrong order from our
        0   0.00000   0.00000  1582:    _autoflush($Testout);
        0   0.00000   0.00000  1583:    _autoflush( \*STDOUT );
        0   0.00000   0.00000  1584:    _autoflush($Testerr);
        0   0.00000   0.00000  1585:    _autoflush( \*STDERR );
        0   0.00000   0.00000  1586:
        0   0.00000   0.00000  1587:    $self->reset_outputs;
        0   0.00000   0.00000  1588:
        0   0.00000   0.00000  1589:    return;
        0   0.00000   0.00000  1590:}
        0   0.00000   0.00000  1591:
        0   0.00000   0.00000  1592:sub _open_testhandles {
        0   0.00000   0.00000  1593:    my $self = shift;
        0   0.00000   0.00000  1594:
        0   0.00000   0.00000  1595:    return if $self->{Opened_Testhandles};
        0   0.00000   0.00000  1596:
        0   0.00000   0.00000  1597:    # We dup STDOUT and STDERR so people can
        0   0.00000   0.00000  1598:    # test suites while still getting normal
        0   0.00000   0.00000  1599:    open( $Testout, ">&STDOUT" ) or die
        0   0.00000   0.00000  1600:    open( $Testerr, ">&STDERR" ) or die
        0   0.00000   0.00000  1601:
        0   0.00000   0.00000  1602:    #    $self->_copy_io_layers( \*STDOUT,
        0   0.00000   0.00000  1603:    #    $self->_copy_io_layers( \*STDERR,
        0   0.00000   0.00000  1604:
        0   0.00000   0.00000  1605:    $self->{Opened_Testhandles} = 1;
        0   0.00000   0.00000  1606:
        0   0.00000   0.00000  1607:    return;
        0   0.00000   0.00000  1608:}
        0   0.00000   0.00000  1609:
        0   0.00000   0.00000  1610:sub _copy_io_layers {
        0   0.00000   0.00000  1611:    my( $self, $src, $dst ) = @_;
        0   0.00000   0.00000  1612:
        0   0.00000   0.00000  1613:    $self->_try(
        0   0.00000   0.00000  1614:        sub {
        0   0.00000   0.00000  1615:            require PerlIO;
        0   0.00000   0.00000  1616:            my @src_layers =
        0   0.00000   0.00000  1617:
        0   0.00000   0.00000  1618:            binmode $dst, join " ", map
        0   0.00000   0.00000  1619:        }
        0   0.00000   0.00000  1620:    );
        0   0.00000   0.00000  1621:
        0   0.00000   0.00000  1622:    return;
        0   0.00000   0.00000  1623:}
        0   0.00000   0.00000  1624:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 181
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1625:=item reset_outputs
        0   0.00000   0.00000  1626:
        0   0.00000   0.00000  1627:
        0   0.00000   0.00000  1628:
        0   0.00000   0.00000  1629:
        0   0.00000   0.00000  1630:
        0   0.00000   0.00000  1631:
        0   0.00000   0.00000  1632:
        0   0.00000   0.00000  1633:sub reset_outputs {
        0   0.00000   0.00000  1634:    my $self = shift;
        0   0.00000   0.00000  1635:
        0   0.00000   0.00000  1636:    $self->output        ($Testout);
        0   0.00000   0.00000  1637:    $self->failure_output($Testerr);
        0   0.00000   0.00000  1638:    $self->todo_output   ($Testout);
        0   0.00000   0.00000  1639:
        0   0.00000   0.00000  1640:    return;
        0   0.00000   0.00000  1641:}
        0   0.00000   0.00000  1642:
        0   0.00000   0.00000  1643:=item carp
        0   0.00000   0.00000  1644:
        0   0.00000   0.00000  1645:
        0   0.00000   0.00000  1646:
        0   0.00000   0.00000  1647:
        0   0.00000   0.00000  1648:
        0   0.00000   0.00000  1649:
        0   0.00000   0.00000  1650:
        0   0.00000   0.00000  1651:
        0   0.00000   0.00000  1652:
        0   0.00000   0.00000  1653:
        0   0.00000   0.00000  1654:
        0   0.00000   0.00000  1655:
        0   0.00000   0.00000  1656:
        0   0.00000   0.00000  1657:
        0   0.00000   0.00000  1658:
        0   0.00000   0.00000  1659:sub _message_at_caller {
        0   0.00000   0.00000  1660:    my $self = shift;
        0   0.00000   0.00000  1661:
        0   0.00000   0.00000  1662:    local $Level = $Level + 1;
        0   0.00000   0.00000  1663:    my( $pack, $file, $line ) = $self-
        0   0.00000   0.00000  1664:    return join( "", @_ ) . " at $file line
        0   0.00000   0.00000  1665:}
        0   0.00000   0.00000  1666:
        0   0.00000   0.00000  1667:sub carp {
        0   0.00000   0.00000  1668:    my $self = shift;
        0   0.00000   0.00000  1669:    return warn $self-
        0   0.00000   0.00000  1670:}
        0   0.00000   0.00000  1671:
        0   0.00000   0.00000  1672:sub croak {
        0   0.00000   0.00000  1673:    my $self = shift;
        0   0.00000   0.00000  1674:    return die $self->_message_at_caller(@_);
        0   0.00000   0.00000  1675:}
        0   0.00000   0.00000  1676:
        0   0.00000   0.00000  1677:
        0   0.00000   0.00000  1678:=back
        0   0.00000   0.00000  1679:
        0   0.00000   0.00000  1680:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 182
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1681:
        0   0.00000   0.00000  1682:
        0   0.00000   0.00000  1683:
        0   0.00000   0.00000  1684:
        0   0.00000   0.00000  1685:
        0   0.00000   0.00000  1686:
        0   0.00000   0.00000  1687:
        0   0.00000   0.00000  1688:
        0   0.00000   0.00000  1689:
        0   0.00000   0.00000  1690:
        0   0.00000   0.00000  1691:
        0   0.00000   0.00000  1692:
        0   0.00000   0.00000  1693:
        0   0.00000   0.00000  1694:
        0   0.00000   0.00000  1695:
        0   0.00000   0.00000  1696:
        0   0.00000   0.00000  1697:
        0   0.00000   0.00000  1698:
        0   0.00000   0.00000  1699:sub current_test {
        0   0.00000   0.00000  1700:    my( $self, $num ) = @_;
        0   0.00000   0.00000  1701:
        0   0.00000   0.00000  1702:    lock( $self->{Curr_Test} );
        0   0.00000   0.00000  1703:    if( defined $num ) {
        0   0.00000   0.00000  1704:        $self->{Curr_Test} = $num;
        0   0.00000   0.00000  1705:
        0   0.00000   0.00000  1706:        # If the test counter is being pushed
        0   0.00000   0.00000  1707:        my $test_results = $self-
        0   0.00000   0.00000  1708:        if( $num > @$test_results ) {
        0   0.00000   0.00000  1709:            my $start = @$test_results ?
        0   0.00000   0.00000  1710:            for( $start .. $num - 1 ) {
        0   0.00000   0.00000  1711:                $test_results->[$_] = &share(
        0   0.00000   0.00000  1712:                    {
        0   0.00000   0.00000  1713:                        'ok'      => 1,
        0   0.00000   0.00000  1714:                        actual_ok => undef,
        0   0.00000   0.00000  1715:                        reason    =>
        0   0.00000   0.00000  1716:                        type      =>
        0   0.00000   0.00000  1717:                        name      => undef
        0   0.00000   0.00000  1718:                    }
        0   0.00000   0.00000  1719:                );
        0   0.00000   0.00000  1720:            }
        0   0.00000   0.00000  1721:        }
        0   0.00000   0.00000  1722:        # If backward, wipe history.  Its
        0   0.00000   0.00000  1723:        elsif( $num < @$test_results ) {
        0   0.00000   0.00000  1724:            $#{$test_results} = $num - 1;
        0   0.00000   0.00000  1725:        }
        0   0.00000   0.00000  1726:    }
        0   0.00000   0.00000  1727:    return $self->{Curr_Test};
        0   0.00000   0.00000  1728:}
        0   0.00000   0.00000  1729:
        0   0.00000   0.00000  1730:=item B<summary>
        0   0.00000   0.00000  1731:
        0   0.00000   0.00000  1732:
        0   0.00000   0.00000  1733:
        0   0.00000   0.00000  1734:
        0   0.00000   0.00000  1735:
        0   0.00000   0.00000  1736:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 183
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1737:
        0   0.00000   0.00000  1738:
        0   0.00000   0.00000  1739:
        0   0.00000   0.00000  1740:
        0   0.00000   0.00000  1741:sub summary {
        0   0.00000   0.00000  1742:    my($self) = shift;
        0   0.00000   0.00000  1743:
        0   0.00000   0.00000  1744:    return map { $_->{'ok'} } @{ $self-
        0   0.00000   0.00000  1745:}
        0   0.00000   0.00000  1746:
        0   0.00000   0.00000  1747:=item B<details>
        0   0.00000   0.00000  1748:
        0   0.00000   0.00000  1749:
        0   0.00000   0.00000  1750:
        0   0.00000   0.00000  1751:
        0   0.00000   0.00000  1752:
        0   0.00000   0.00000  1753:
        0   0.00000   0.00000  1754:
        0   0.00000   0.00000  1755:
        0   0.00000   0.00000  1756:
        0   0.00000   0.00000  1757:
        0   0.00000   0.00000  1758:
        0   0.00000   0.00000  1759:
        0   0.00000   0.00000  1760:
        0   0.00000   0.00000  1761:
        0   0.00000   0.00000  1762:
        0   0.00000   0.00000  1763:
        0   0.00000   0.00000  1764:
        0   0.00000   0.00000  1765:
        0   0.00000   0.00000  1766:
        0   0.00000   0.00000  1767:
        0   0.00000   0.00000  1768:
        0   0.00000   0.00000  1769:
        0   0.00000   0.00000  1770:
        0   0.00000   0.00000  1771:
        0   0.00000   0.00000  1772:
        0   0.00000   0.00000  1773:
        0   0.00000   0.00000  1774:
        0   0.00000   0.00000  1775:
        0   0.00000   0.00000  1776:
        0   0.00000   0.00000  1777:
        0   0.00000   0.00000  1778:
        0   0.00000   0.00000  1779:
        0   0.00000   0.00000  1780:
        0   0.00000   0.00000  1781:
        0   0.00000   0.00000  1782:
        0   0.00000   0.00000  1783:
        0   0.00000   0.00000  1784:
        0   0.00000   0.00000  1785:
        0   0.00000   0.00000  1786:
        0   0.00000   0.00000  1787:
        0   0.00000   0.00000  1788:
        0   0.00000   0.00000  1789:
        0   0.00000   0.00000  1790:
        0   0.00000   0.00000  1791:
        0   0.00000   0.00000  1792:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 184
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1793:
        0   0.00000   0.00000  1794:
        0   0.00000   0.00000  1795:
        0   0.00000   0.00000  1796:sub details {
        0   0.00000   0.00000  1797:    my $self = shift;
        0   0.00000   0.00000  1798:    return @{ $self->{Test_Results} };
        0   0.00000   0.00000  1799:}
        0   0.00000   0.00000  1800:
        0   0.00000   0.00000  1801:=item B<todo>
        0   0.00000   0.00000  1802:
        0   0.00000   0.00000  1803:
        0   0.00000   0.00000  1804:
        0   0.00000   0.00000  1805:
        0   0.00000   0.00000  1806:
        0   0.00000   0.00000  1807:
        0   0.00000   0.00000  1808:
        0   0.00000   0.00000  1809:
        0   0.00000   0.00000  1810:
        0   0.00000   0.00000  1811:
        0   0.00000   0.00000  1812:
        0   0.00000   0.00000  1813:
        0   0.00000   0.00000  1814:
        0   0.00000   0.00000  1815:
        0   0.00000   0.00000  1816:
        0   0.00000   0.00000  1817:
        0   0.00000   0.00000  1818:
        0   0.00000   0.00000  1819:
        0   0.00000   0.00000  1820:
        0   0.00000   0.00000  1821:
        0   0.00000   0.00000  1822:
        0   0.00000   0.00000  1823:
        0   0.00000   0.00000  1824:
        0   0.00000   0.00000  1825:sub todo {
        1   0.00000   0.00000  1826:    my( $self, $pack ) = @_;
        0   0.00000   0.00000  1827:
        1   0.00000   0.00000  1828:    return $self->{Todo} if defined $self-
        0   0.00000   0.00000  1829:
        1   0.00000   0.00000  1830:    local $Level = $Level + 1;
        1   0.00000   0.00000  1831:    my $todo = $self->find_TODO($pack);
        1   0.00000   0.00000  1832:    return $todo if defined $todo;
        0   0.00000   0.00000  1833:
        1   0.00000   0.00000  1834:    return '';
        0   0.00000   0.00000  1835:}
        0   0.00000   0.00000  1836:
        0   0.00000   0.00000  1837:=item B<find_TODO>
        0   0.00000   0.00000  1838:
        0   0.00000   0.00000  1839:
        0   0.00000   0.00000  1840:
        0   0.00000   0.00000  1841:
        0   0.00000   0.00000  1842:
        0   0.00000   0.00000  1843:
        0   0.00000   0.00000  1844:
        0   0.00000   0.00000  1845:
        0   0.00000   0.00000  1846:
        0   0.00000   0.00000  1847:sub find_TODO {
        9   0.00000   0.00000  1848:    my( $self, $pack ) = @_;
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 185
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1849:
        9   0.00000   0.00000  1850:    $pack = $pack || $self->caller(1) ||
        9   0.00002   0.00000  1851:    return unless $pack;
        0   0.00000   0.00000  1852:
        0   0.00000   0.00000  1853:    no strict 'refs';    ## no critic
        9   0.00000   0.00000  1854:    return ${ $pack . '::TODO' };
        0   0.00000   0.00000  1855:}
        0   0.00000   0.00000  1856:
        0   0.00000   0.00000  1857:=item B<in_todo>
        0   0.00000   0.00000  1858:
        0   0.00000   0.00000  1859:
        0   0.00000   0.00000  1860:
        0   0.00000   0.00000  1861:
        0   0.00000   0.00000  1862:
        0   0.00000   0.00000  1863:
        0   0.00000   0.00000  1864:
        0   0.00000   0.00000  1865:sub in_todo {
        8   0.00000   0.00000  1866:    my $self = shift;
        0   0.00000   0.00000  1867:
        8   0.00000   0.00000  1868:    local $Level = $Level + 1;
        8   0.00000   0.00000  1869:    return( defined $self->{Todo} || $self-
        0   0.00000   0.00000  1870:}
        0   0.00000   0.00000  1871:
        0   0.00000   0.00000  1872:=item B<todo_start>
        0   0.00000   0.00000  1873:
        0   0.00000   0.00000  1874:
        0   0.00000   0.00000  1875:
        0   0.00000   0.00000  1876:
        0   0.00000   0.00000  1877:
        0   0.00000   0.00000  1878:
        0   0.00000   0.00000  1879:
        0   0.00000   0.00000  1880:
        0   0.00000   0.00000  1881:
        0   0.00000   0.00000  1882:
        0   0.00000   0.00000  1883:
        0   0.00000   0.00000  1884:
        0   0.00000   0.00000  1885:
        0   0.00000   0.00000  1886:
        0   0.00000   0.00000  1887:
        0   0.00000   0.00000  1888:
        0   0.00000   0.00000  1889:
        0   0.00000   0.00000  1890:
        0   0.00000   0.00000  1891:
        0   0.00000   0.00000  1892:
        0   0.00000   0.00000  1893:
        0   0.00000   0.00000  1894:
        0   0.00000   0.00000  1895:
        0   0.00000   0.00000  1896:
        0   0.00000   0.00000  1897:
        0   0.00000   0.00000  1898:
        0   0.00000   0.00000  1899:
        0   0.00000   0.00000  1900:
        0   0.00000   0.00000  1901:
        0   0.00000   0.00000  1902:
        0   0.00000   0.00000  1903:
        0   0.00000   0.00000  1904:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 186
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1905:
        0   0.00000   0.00000  1906:
        0   0.00000   0.00000  1907:
        0   0.00000   0.00000  1908:
        0   0.00000   0.00000  1909:
        0   0.00000   0.00000  1910:
        0   0.00000   0.00000  1911:
        0   0.00000   0.00000  1912:
        0   0.00000   0.00000  1913:
        0   0.00000   0.00000  1914:
        0   0.00000   0.00000  1915:sub todo_start {
        0   0.00000   0.00000  1916:    my $self = shift;
        0   0.00000   0.00000  1917:    my $message = @_ ? shift : '';
        0   0.00000   0.00000  1918:
        0   0.00000   0.00000  1919:    $self->{Start_Todo}++;
        0   0.00000   0.00000  1920:    if( $self->in_todo ) {
        0   0.00000   0.00000  1921:        push @{ $self->{Todo_Stack} } =>
        0   0.00000   0.00000  1922:    }
        0   0.00000   0.00000  1923:    $self->{Todo} = $message;
        0   0.00000   0.00000  1924:
        0   0.00000   0.00000  1925:    return;
        0   0.00000   0.00000  1926:}
        0   0.00000   0.00000  1927:
        0   0.00000   0.00000  1928:=item C<todo_end>
        0   0.00000   0.00000  1929:
        0   0.00000   0.00000  1930:
        0   0.00000   0.00000  1931:
        0   0.00000   0.00000  1932:
        0   0.00000   0.00000  1933:
        0   0.00000   0.00000  1934:
        0   0.00000   0.00000  1935:
        0   0.00000   0.00000  1936:
        0   0.00000   0.00000  1937:sub todo_end {
        0   0.00000   0.00000  1938:    my $self = shift;
        0   0.00000   0.00000  1939:
        0   0.00000   0.00000  1940:    if( !$self->{Start_Todo} ) {
        0   0.00000   0.00000  1941:        $self->croak('todo_end() called
        0   0.00000   0.00000  1942:    }
        0   0.00000   0.00000  1943:
        0   0.00000   0.00000  1944:    $self->{Start_Todo}--;
        0   0.00000   0.00000  1945:
        0   0.00000   0.00000  1946:    if( $self->{Start_Todo} && @{ $self-
        0   0.00000   0.00000  1947:        $self->{Todo} = pop @{ $self-
        0   0.00000   0.00000  1948:    }
        0   0.00000   0.00000  1949:    else {
        0   0.00000   0.00000  1950:        delete $self->{Todo};
        0   0.00000   0.00000  1951:    }
        0   0.00000   0.00000  1952:
        0   0.00000   0.00000  1953:    return;
        0   0.00000   0.00000  1954:}
        0   0.00000   0.00000  1955:
        0   0.00000   0.00000  1956:=item B<caller>
        0   0.00000   0.00000  1957:
        0   0.00000   0.00000  1958:
        0   0.00000   0.00000  1959:
        0   0.00000   0.00000  1960:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 187
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1961:
        0   0.00000   0.00000  1962:
        0   0.00000   0.00000  1963:
        0   0.00000   0.00000  1964:
        0   0.00000   0.00000  1965:
        0   0.00000   0.00000  1966:
        0   0.00000   0.00000  1967:
        0   0.00000   0.00000  1968:
        0   0.00000   0.00000  1969:
        0   0.00000   0.00000  1970:sub caller {    ## no critic
       11   0.00000   0.00000  1971:    my( $self, $height ) = @_;
       11   0.00000   0.00000  1972:    $height ||= 0;
        0   0.00000   0.00000  1973:
       11   0.00000   0.00000  1974:    my $level = $self->level + $height + 1;
       11   0.00000   0.00000  1975:    my @caller;
       11   0.00000   0.00000  1976:    do {
       11   0.00001   0.00000  1977:        @caller = CORE::caller( $level );
       11   0.00000   0.00000  1978:        $level--;
        0   0.00000   0.00000  1979:    } until @caller;
       11   0.00000   0.00000  1980:    return wantarray ? @caller : $caller[0];
        0   0.00000   0.00000  1981:}
        0   0.00000   0.00000  1982:
        0   0.00000   0.00000  1983:=back
        0   0.00000   0.00000  1984:
        0   0.00000   0.00000  1985:
        0   0.00000   0.00000  1986:
        0   0.00000   0.00000  1987:=begin _private
        0   0.00000   0.00000  1988:
        0   0.00000   0.00000  1989:
        0   0.00000   0.00000  1990:
        0   0.00000   0.00000  1991:
        0   0.00000   0.00000  1992:
        0   0.00000   0.00000  1993:
        0   0.00000   0.00000  1994:
        0   0.00000   0.00000  1995:
        0   0.00000   0.00000  1996:
        0   0.00000   0.00000  1997:
        0   0.00000   0.00000  1998:
        0   0.00000   0.00000  1999:
        0   0.00000   0.00000  2000:
        0   0.00000   0.00000  2001:#'#
        0   0.00000   0.00000  2002:sub _sanity_check {
        0   0.00000   0.00000  2003:    my $self = shift;
        0   0.00000   0.00000  2004:
        0   0.00000   0.00000  2005:    $self->_whoa( $self->{Curr_Test} < 0,
        0   0.00000   0.00000  2006:    $self->_whoa( $self->{Curr_Test} != @{
        0   0.00000   0.00000  2007:        'Somehow you got a different number
        0   0.00000   0.00000  2008:
        0   0.00000   0.00000  2009:    return;
        0   0.00000   0.00000  2010:}
        0   0.00000   0.00000  2011:
        0   0.00000   0.00000  2012:=item B<_whoa>
        0   0.00000   0.00000  2013:
        0   0.00000   0.00000  2014:
        0   0.00000   0.00000  2015:
        0   0.00000   0.00000  2016:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 188
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2017:
        0   0.00000   0.00000  2018:
        0   0.00000   0.00000  2019:
        0   0.00000   0.00000  2020:
        0   0.00000   0.00000  2021:
        0   0.00000   0.00000  2022:sub _whoa {
        0   0.00000   0.00000  2023:    my( $self, $check, $desc ) = @_;
        0   0.00000   0.00000  2024:    if($check) {
        0   0.00000   0.00000  2025:        local $Level = $Level + 1;
        0   0.00000   0.00000  2026:        $self->croak(<<"WHOA");
        0   0.00000   0.00000  2027:WHOA!  $desc
        0   0.00000   0.00000  2028:This should never happen!  Please contact the
        0   0.00000   0.00000  2029:WHOA
        0   0.00000   0.00000  2030:    }
        0   0.00000   0.00000  2031:
        0   0.00000   0.00000  2032:    return;
        0   0.00000   0.00000  2033:}
        0   0.00000   0.00000  2034:
        0   0.00000   0.00000  2035:=item B<_my_exit>
        0   0.00000   0.00000  2036:
        0   0.00000   0.00000  2037:
        0   0.00000   0.00000  2038:
        0   0.00000   0.00000  2039:
        0   0.00000   0.00000  2040:
        0   0.00000   0.00000  2041:
        0   0.00000   0.00000  2042:
        0   0.00000   0.00000  2043:
        0   0.00000   0.00000  2044:
        0   0.00000   0.00000  2045:
        0   0.00000   0.00000  2046:sub _my_exit {
        1   0.00000   0.00000  2047:    $? = $_[0];    ## no critic
        0   0.00000   0.00000  2048:
        1   0.00000   0.00000  2049:    return 1;
        0   0.00000   0.00000  2050:}
        0   0.00000   0.00000  2051:
        0   0.00000   0.00000  2052:=back
        0   0.00000   0.00000  2053:
        0   0.00000   0.00000  2054:
        0   0.00000   0.00000  2055:
        0   0.00000   0.00000  2056:
        0   0.00000   0.00000  2057:
        0   0.00000   0.00000  2058:sub _ending {
        1   0.00000   0.00000  2059:    my $self = shift;
        0   0.00000   0.00000  2060:
        1   0.00000   0.00000  2061:    my $real_exit_code = $?;
        0   0.00000   0.00000  2062:
        0   0.00000   0.00000  2063:    # Don't bother with an ending if this is
        0   0.00000   0.00000  2064:    # should do the ending.
        1   0.00000   0.00000  2065:    if( $self->{Original_Pid} != $$ ) {
        0   0.00000   0.00000  2066:        return;
        0   0.00000   0.00000  2067:    }
        0   0.00000   0.00000  2068:
        0   0.00000   0.00000  2069:    # Ran tests but never declared a plan or
        1   0.00000   0.00000  2070:    if( !$self->{Have_Plan} and $self-
        0   0.00000   0.00000  2071:        $self->diag("Tests were run but no
        0   0.00000   0.00000  2072:    }
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 189
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2073:
        0   0.00000   0.00000  2074:    # Exit if plan() was never called.  This
        0   0.00000   0.00000  2075:    # doesn't puke.
        1   0.00000   0.00000  2076:    if( !$self->{Have_Plan} ) {
        0   0.00000   0.00000  2077:        return;
        0   0.00000   0.00000  2078:    }
        0   0.00000   0.00000  2079:
        0   0.00000   0.00000  2080:    # Don't do an ending if we bailed out.
        1   0.00000   0.00000  2081:    if( $self->{Bailed_Out} ) {
        0   0.00000   0.00000  2082:        return;
        0   0.00000   0.00000  2083:    }
        0   0.00000   0.00000  2084:
        0   0.00000   0.00000  2085:    # Figure out if we passed or failed and
        1   0.00000   0.00000  2086:    my $test_results = $self->{Test_Results};
        1   0.00000   0.00000  2087:    if(@$test_results) {
        0   0.00000   0.00000  2088:        # The plan?  We have no plan.
        1   0.00000   0.00000  2089:        if( $self->{No_Plan} ) {
        0   0.00000   0.00000  2090:            $self->_output_plan($self-
        0   0.00000   0.00000  2091:            $self->{Expected_Tests} = $self-
        0   0.00000   0.00000  2092:        }
        0   0.00000   0.00000  2093:
        0   0.00000   0.00000  2094:        # Auto-extended arrays and elements
        0   0.00000   0.00000  2095:        # filled in with a shared reference
        0   0.00000   0.00000  2096:        # ithreads.  So we have to fill them
        1   0.00000   0.00000  2097:        my $empty_result = &share( {} );
        1   0.00000   0.00000  2098:        for my $idx ( 0 .. $self-
        1   0.00000   0.00000  2099:            $test_results->[$idx] =
        0   0.00000   0.00000  2100:              unless defined $test_results-
        0   0.00000   0.00000  2101:        }
        0   0.00000   0.00000  2102:
        1   0.00000   0.00000  2103:        my $num_failed = grep !$_->{'ok'},
        0   0.00000   0.00000  2104:
        1   0.00000   0.00000  2105:        my $num_extra = $self->{Curr_Test} -
        0   0.00000   0.00000  2106:
        1   0.00000   0.00000  2107:        if( $num_extra != 0 ) {
        0   0.00000   0.00000  2108:            my $s = $self->{Expected_Tests}
        0   0.00000   0.00000  2109:            $self->diag(<<"FAIL");
        0   0.00000   0.00000  2110:Looks like you planned $self-
        0   0.00000   0.00000  2111:FAIL
        0   0.00000   0.00000  2112:        }
        0   0.00000   0.00000  2113:
        1   0.00000   0.00000  2114:        if($num_failed) {
        1   0.00000   0.00000  2115:            my $num_tests = $self-
        1   0.00000   0.00000  2116:            my $s = $num_failed == 1 ? '' :
        0   0.00000   0.00000  2117:
        1   0.00000   0.00000  2118:            my $qualifier = $num_extra == 0 ?
        0   0.00000   0.00000  2119:
        1   0.00000   0.00000  2120:            $self->diag(<<"FAIL");
        0   0.00000   0.00000  2121:Looks like you failed $num_failed test$s of
        0   0.00000   0.00000  2122:FAIL
        0   0.00000   0.00000  2123:        }
        0   0.00000   0.00000  2124:
        1   0.00000   0.00000  2125:        if($real_exit_code) {
        0   0.00000   0.00000  2126:            $self->diag(<<"FAIL");
        0   0.00000   0.00000  2127:Looks like your test exited with
        0   0.00000   0.00000  2128:FAIL
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 190
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2129:
        0   0.00000   0.00000  2130:            _my_exit($real_exit_code) &&
        0   0.00000   0.00000  2131:        }
        0   0.00000   0.00000  2132:
        1   0.00000   0.00000  2133:        my $exit_code;
        1   0.00000   0.00000  2134:        if($num_failed) {
        0   0.00000   0.00000  2135:            $exit_code = $num_failed <= 254 ?
        0   0.00000   0.00000  2136:        }
        0   0.00000   0.00000  2137:        elsif( $num_extra != 0 ) {
        0   0.00000   0.00000  2138:            $exit_code = 255;
        0   0.00000   0.00000  2139:        }
        0   0.00000   0.00000  2140:        else {
        0   0.00000   0.00000  2141:            $exit_code = 0;
        0   0.00000   0.00000  2142:        }
        0   0.00000   0.00000  2143:
        1   0.00000   0.00000  2144:        _my_exit($exit_code) && return;
        0   0.00000   0.00000  2145:    }
        0   0.00000   0.00000  2146:    elsif( $self->{Skip_All} ) {
        0   0.00000   0.00000  2147:        _my_exit(0) && return;
        0   0.00000   0.00000  2148:    }
        0   0.00000   0.00000  2149:    elsif($real_exit_code) {
        0   0.00000   0.00000  2150:        $self->diag(<<"FAIL");
        0   0.00000   0.00000  2151:Looks like your test exited with
        0   0.00000   0.00000  2152:FAIL
        0   0.00000   0.00000  2153:        _my_exit($real_exit_code) && return;
        0   0.00000   0.00000  2154:    }
        0   0.00000   0.00000  2155:    else {
        0   0.00000   0.00000  2156:        $self->diag("No tests run!\n");
        0   0.00000   0.00000  2157:        _my_exit(255) && return;
        0   0.00000   0.00000  2158:    }
        0   0.00000   0.00000  2159:
        0   0.00000   0.00000  2160:    $self->_whoa( 1, "We fell off the end of
        0   0.00000   0.00000  2161:}
        0   0.00000   0.00000  2162:
        0   0.00000   0.00000  2163:END {
        1   0.00000   0.00000  2164:    $Test->_ending if defined $Test and
        0   0.00000   0.00000  2165:}
        0   0.00000   0.00000  2166:
        0   0.00000   0.00000  2167:=head1 EXIT CODES
        0   0.00000   0.00000  2168:
        0   0.00000   0.00000  2169:
        0   0.00000   0.00000  2170:
        0   0.00000   0.00000  2171:
        0   0.00000   0.00000  2172:
        0   0.00000   0.00000  2173:
        0   0.00000   0.00000  2174:
        0   0.00000   0.00000  2175:
        0   0.00000   0.00000  2176:
        0   0.00000   0.00000  2177:
        0   0.00000   0.00000  2178:
        0   0.00000   0.00000  2179:
        0   0.00000   0.00000  2180:
        0   0.00000   0.00000  2181:
        0   0.00000   0.00000  2182:
        0   0.00000   0.00000  2183:
        0   0.00000   0.00000  2184:
           ================ SmallProf version 2.02 ================
            Profile of /usr/local/share/perl/5.10.0/Test/Builder.pm    Page 191
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  2185:
        0   0.00000   0.00000  2186:
        0   0.00000   0.00000  2187:
        0   0.00000   0.00000  2188:
        0   0.00000   0.00000  2189:
        0   0.00000   0.00000  2190:
        0   0.00000   0.00000  2191:
        0   0.00000   0.00000  2192:
        0   0.00000   0.00000  2193:
        0   0.00000   0.00000  2194:
        0   0.00000   0.00000  2195:
        0   0.00000   0.00000  2196:
        0   0.00000   0.00000  2197:
        0   0.00000   0.00000  2198:
        0   0.00000   0.00000  2199:
        0   0.00000   0.00000  2200:
        0   0.00000   0.00000  2201:
        0   0.00000   0.00000  2202:
        0   0.00000   0.00000  2203:
        0   0.00000   0.00000  2204:
        0   0.00000   0.00000  2205:
        0   0.00000   0.00000  2206:
        0   0.00000   0.00000  2207:
        0   0.00000   0.00000  2208:
        0   0.00000   0.00000  2209:
        0   0.00000   0.00000  2210:
        0   0.00000   0.00000  2211:
        0   0.00000   0.00000  2212:
        0   0.00000   0.00000  2213:
        0   0.00000   0.00000  2214:
        0   0.00000   0.00000  2215:
        0   0.00000   0.00000  2216:
        0   0.00000   0.00000  2217:
        0   0.00000   0.00000  2218:
        0   0.00000   0.00000  2219:
        0   0.00000   0.00000  2220:
        0   0.00000   0.00000  2221:
        0   0.00000   0.00000  2222:
        0   0.00000   0.00000  2223:
        0   0.00000   0.00000  2224:
        0   0.00000   0.00000  2225:
        0   0.00000   0.00000  2226:
        0   0.00000   0.00000  2227:
        0   0.00000   0.00000  2228:
        0   0.00000   0.00000  2229:
        0   0.00000   0.00000  2230:
        0   0.00000   0.00000  2231:
        0   0.00000   0.00000  2232:
        0   0.00000   0.00000  2233:
        0   0.00000   0.00000  2234:
        0   0.00000   0.00000  2235:
        0   0.00000   0.00000  2236:
        0   0.00000   0.00000  2237:
        0   0.00000   0.00000  2238:1;
        0   0.00000   0.00000  2239:
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Test/Builder/Module.p Page 192
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:package Test::Builder::Module;
        0   0.00000   0.00000     2:
        0   0.00000   0.00000     3:use strict;
        0   0.00000   0.00000     4:
        0   0.00000   0.00000     5:use Test::Builder;
        0   0.00000   0.00000     6:
        0   0.00000   0.00000     7:require Exporter;
        0   0.00000   0.00000     8:our @ISA = qw(Exporter);
        0   0.00000   0.00000     9:
        0   0.00000   0.00000    10:our $VERSION = '0.92';
        0   0.00000   0.00000    11:$VERSION = eval $VERSION;      ## no critic
        0   0.00000   0.00000    12:
        0   0.00000   0.00000    13:# 5.004's Exporter doesn't have
        0   0.00000   0.00000    14:my $_export_to_level = sub {
        0   0.00000   0.00000    15:    my $pkg   = shift;
        0   0.00000   0.00000    16:    my $level = shift;
        0   0.00000   0.00000    17:    (undef) = shift;    # redundant arg
        0   0.00000   0.00000    18:    my $callpkg = caller($level);
        0   0.00000   0.00000    19:    $pkg->export( $callpkg, @_ );
        0   0.00000   0.00000    20:};
        0   0.00000   0.00000    21:
        0   0.00000   0.00000    22:=head1 NAME
        0   0.00000   0.00000    23:
        0   0.00000   0.00000    24:
        0   0.00000   0.00000    25:
        0   0.00000   0.00000    26:
        0   0.00000   0.00000    27:
        0   0.00000   0.00000    28:
        0   0.00000   0.00000    29:
        0   0.00000   0.00000    30:
        0   0.00000   0.00000    31:
        0   0.00000   0.00000    32:
        0   0.00000   0.00000    33:
        0   0.00000   0.00000    34:
        0   0.00000   0.00000    35:
        0   0.00000   0.00000    36:
        0   0.00000   0.00000    37:
        0   0.00000   0.00000    38:
        0   0.00000   0.00000    39:
        0   0.00000   0.00000    40:
        0   0.00000   0.00000    41:
        0   0.00000   0.00000    42:
        0   0.00000   0.00000    43:
        0   0.00000   0.00000    44:
        0   0.00000   0.00000    45:
        0   0.00000   0.00000    46:
        0   0.00000   0.00000    47:
        0   0.00000   0.00000    48:
        0   0.00000   0.00000    49:
        0   0.00000   0.00000    50:
        0   0.00000   0.00000    51:
        0   0.00000   0.00000    52:
        0   0.00000   0.00000    53:
        0   0.00000   0.00000    54:
        0   0.00000   0.00000    55:
        0   0.00000   0.00000    56:
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Test/Builder/Module.p Page 193
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000    57:
        0   0.00000   0.00000    58:
        0   0.00000   0.00000    59:
        0   0.00000   0.00000    60:
        0   0.00000   0.00000    61:
        0   0.00000   0.00000    62:
        0   0.00000   0.00000    63:
        0   0.00000   0.00000    64:
        0   0.00000   0.00000    65:
        0   0.00000   0.00000    66:
        0   0.00000   0.00000    67:
        0   0.00000   0.00000    68:
        0   0.00000   0.00000    69:
        0   0.00000   0.00000    70:
        0   0.00000   0.00000    71:
        0   0.00000   0.00000    72:
        0   0.00000   0.00000    73:
        0   0.00000   0.00000    74:
        0   0.00000   0.00000    75:
        0   0.00000   0.00000    76:
        0   0.00000   0.00000    77:
        0   0.00000   0.00000    78:
        0   0.00000   0.00000    79:
        0   0.00000   0.00000    80:
        0   0.00000   0.00000    81:
        0   0.00000   0.00000    82:
        0   0.00000   0.00000    83:
        0   0.00000   0.00000    84:sub import {
        0   0.00000   0.00000    85:    my($class) = shift;
        0   0.00000   0.00000    86:
        0   0.00000   0.00000    87:    # Don't run all this when loading
        0   0.00000   0.00000    88:    return 1 if $class eq
        0   0.00000   0.00000    89:
        0   0.00000   0.00000    90:    my $test = $class->builder;
        0   0.00000   0.00000    91:
        0   0.00000   0.00000    92:    my $caller = caller;
        0   0.00000   0.00000    93:
        0   0.00000   0.00000    94:    $test->exported_to($caller);
        0   0.00000   0.00000    95:
        0   0.00000   0.00000    96:    $class->import_extra( \@_ );
        0   0.00000   0.00000    97:    my(@imports) = $class->_strip_imports(
        0   0.00000   0.00000    98:
        0   0.00000   0.00000    99:    $test->plan(@_);
        0   0.00000   0.00000   100:
        0   0.00000   0.00000   101:    $class->$_export_to_level( 1, $class,
        0   0.00000   0.00000   102:}
        0   0.00000   0.00000   103:
        0   0.00000   0.00000   104:sub _strip_imports {
        0   0.00000   0.00000   105:    my $class = shift;
        0   0.00000   0.00000   106:    my $list  = shift;
        0   0.00000   0.00000   107:
        0   0.00000   0.00000   108:    my @imports = ();
        0   0.00000   0.00000   109:    my @other   = ();
        0   0.00000   0.00000   110:    my $idx     = 0;
        0   0.00000   0.00000   111:    while( $idx <= $#{$list} ) {
        0   0.00000   0.00000   112:        my $item = $list->[$idx];
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Test/Builder/Module.p Page 194
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   113:
        0   0.00000   0.00000   114:        if( defined $item and $item eq
        0   0.00000   0.00000   115:            push @imports, @{ $list->[ $idx +
        0   0.00000   0.00000   116:            $idx++;
        0   0.00000   0.00000   117:        }
        0   0.00000   0.00000   118:        else {
        0   0.00000   0.00000   119:            push @other, $item;
        0   0.00000   0.00000   120:        }
        0   0.00000   0.00000   121:
        0   0.00000   0.00000   122:        $idx++;
        0   0.00000   0.00000   123:    }
        0   0.00000   0.00000   124:
        0   0.00000   0.00000   125:    @$list = @other;
        0   0.00000   0.00000   126:
        0   0.00000   0.00000   127:    return @imports;
        0   0.00000   0.00000   128:}
        0   0.00000   0.00000   129:
        0   0.00000   0.00000   130:=head3 import_extra
        0   0.00000   0.00000   131:
        0   0.00000   0.00000   132:
        0   0.00000   0.00000   133:
        0   0.00000   0.00000   134:
        0   0.00000   0.00000   135:
        0   0.00000   0.00000   136:
        0   0.00000   0.00000   137:
        0   0.00000   0.00000   138:
        0   0.00000   0.00000   139:
        0   0.00000   0.00000   140:
        0   0.00000   0.00000   141:
        0   0.00000   0.00000   142:
        0   0.00000   0.00000   143:
        0   0.00000   0.00000   144:
        0   0.00000   0.00000   145:
        0   0.00000   0.00000   146:
        0   0.00000   0.00000   147:sub import_extra { }
        0   0.00000   0.00000   148:
        0   0.00000   0.00000   149:=head2 Builder
        0   0.00000   0.00000   150:
        0   0.00000   0.00000   151:
        0   0.00000   0.00000   152:
        0   0.00000   0.00000   153:
        0   0.00000   0.00000   154:
        0   0.00000   0.00000   155:
        0   0.00000   0.00000   156:
        0   0.00000   0.00000   157:
        0   0.00000   0.00000   158:
        0   0.00000   0.00000   159:
        0   0.00000   0.00000   160:
        0   0.00000   0.00000   161:
        0   0.00000   0.00000   162:
        0   0.00000   0.00000   163:
        0   0.00000   0.00000   164:
        0   0.00000   0.00000   165:
        0   0.00000   0.00000   166:
        0   0.00000   0.00000   167:
        0   0.00000   0.00000   168:
           ================ SmallProf version 2.02 ================
         Profile of /usr/local/share/perl/5.10.0/Test/Builder/Module.p Page 195
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   169:
        0   0.00000   0.00000   170:
        0   0.00000   0.00000   171:
        0   0.00000   0.00000   172:
        0   0.00000   0.00000   173:
        0   0.00000   0.00000   174:
        0   0.00000   0.00000   175:
        0   0.00000   0.00000   176:
        0   0.00000   0.00000   177:sub builder {
        1   0.00000   0.00000   178:    return Test::Builder->new;
        0   0.00000   0.00000   179:}
        0   0.00000   0.00000   180:
        0   0.00000   0.00000   181:1;
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 196
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:package Test::More;
        0   0.00000   0.00000     2:
        0   0.00000   0.00000     3:use 5.006;
        0   0.00000   0.00000     4:use strict;
        0   0.00000   0.00000     5:use warnings;
        0   0.00000   0.00000     6:
        0   0.00000   0.00000     7:#---- perlcritic exemptions. ----#
        0   0.00000   0.00000     8:
        0   0.00000   0.00000     9:# We use a lot of subroutine prototypes
        0   0.00000   0.00000    10:## no critic
        0   0.00000   0.00000    11:
        0   0.00000   0.00000    12:# Can't use Carp because it might cause
        0   0.00000   0.00000    13:# even though the module being used forgot to
        0   0.00000   0.00000    14:# actually happened.
        0   0.00000   0.00000    15:sub _carp {
        0   0.00000   0.00000    16:    my( $file, $line ) = ( caller(1) )[ 1, 2
        0   0.00000   0.00000    17:    return warn @_, " at $file line $line\n";
        0   0.00000   0.00000    18:}
        0   0.00000   0.00000    19:
        0   0.00000   0.00000    20:our $VERSION = '0.92';
        0   0.00000   0.00000    21:$VERSION = eval $VERSION;    ## no critic
        0   0.00000   0.00000    22:
        0   0.00000   0.00000    23:use Test::Builder::Module;
        0   0.00000   0.00000    24:our @ISA    = qw(Test::Builder::Module);
        0   0.00000   0.00000    25:our @EXPORT = qw(ok use_ok require_ok
        0   0.00000   0.00000    26:  is isnt like unlike is_deeply
        0   0.00000   0.00000    27:  cmp_ok
        0   0.00000   0.00000    28:  skip todo todo_skip
        0   0.00000   0.00000    29:  pass fail
        0   0.00000   0.00000    30:  eq_array eq_hash eq_set
        0   0.00000   0.00000    31:  $TODO
        0   0.00000   0.00000    32:  plan
        0   0.00000   0.00000    33:  done_testing
        0   0.00000   0.00000    34:  can_ok isa_ok new_ok
        0   0.00000   0.00000    35:  diag note explain
        0   0.00000   0.00000    36:  BAIL_OUT
        0   0.00000   0.00000    37:);
        0   0.00000   0.00000    38:
        0   0.00000   0.00000    39:=head1 NAME
        0   0.00000   0.00000    40:
        0   0.00000   0.00000    41:
        0   0.00000   0.00000    42:
        0   0.00000   0.00000    43:
        0   0.00000   0.00000    44:
        0   0.00000   0.00000    45:
        0   0.00000   0.00000    46:
        0   0.00000   0.00000    47:
        0   0.00000   0.00000    48:
        0   0.00000   0.00000    49:
        0   0.00000   0.00000    50:
        0   0.00000   0.00000    51:
        0   0.00000   0.00000    52:
        0   0.00000   0.00000    53:
        0   0.00000   0.00000    54:
        0   0.00000   0.00000    55:
        0   0.00000   0.00000    56:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 197
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000    57:
        0   0.00000   0.00000    58:
        0   0.00000   0.00000    59:
        0   0.00000   0.00000    60:
        0   0.00000   0.00000    61:
        0   0.00000   0.00000    62:
        0   0.00000   0.00000    63:
        0   0.00000   0.00000    64:
        0   0.00000   0.00000    65:
        0   0.00000   0.00000    66:
        0   0.00000   0.00000    67:
        0   0.00000   0.00000    68:
        0   0.00000   0.00000    69:
        0   0.00000   0.00000    70:
        0   0.00000   0.00000    71:
        0   0.00000   0.00000    72:
        0   0.00000   0.00000    73:
        0   0.00000   0.00000    74:
        0   0.00000   0.00000    75:
        0   0.00000   0.00000    76:
        0   0.00000   0.00000    77:
        0   0.00000   0.00000    78:
        0   0.00000   0.00000    79:
        0   0.00000   0.00000    80:
        0   0.00000   0.00000    81:
        0   0.00000   0.00000    82:
        0   0.00000   0.00000    83:
        0   0.00000   0.00000    84:
        0   0.00000   0.00000    85:
        0   0.00000   0.00000    86:
        0   0.00000   0.00000    87:
        0   0.00000   0.00000    88:
        0   0.00000   0.00000    89:
        0   0.00000   0.00000    90:
        0   0.00000   0.00000    91:
        0   0.00000   0.00000    92:
        0   0.00000   0.00000    93:
        0   0.00000   0.00000    94:
        0   0.00000   0.00000    95:
        0   0.00000   0.00000    96:
        0   0.00000   0.00000    97:
        0   0.00000   0.00000    98:
        0   0.00000   0.00000    99:
        0   0.00000   0.00000   100:
        0   0.00000   0.00000   101:
        0   0.00000   0.00000   102:
        0   0.00000   0.00000   103:
        0   0.00000   0.00000   104:
        0   0.00000   0.00000   105:
        0   0.00000   0.00000   106:
        0   0.00000   0.00000   107:
        0   0.00000   0.00000   108:
        0   0.00000   0.00000   109:
        0   0.00000   0.00000   110:
        0   0.00000   0.00000   111:
        0   0.00000   0.00000   112:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 198
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   113:
        0   0.00000   0.00000   114:
        0   0.00000   0.00000   115:
        0   0.00000   0.00000   116:
        0   0.00000   0.00000   117:
        0   0.00000   0.00000   118:
        0   0.00000   0.00000   119:
        0   0.00000   0.00000   120:
        0   0.00000   0.00000   121:
        0   0.00000   0.00000   122:
        0   0.00000   0.00000   123:
        0   0.00000   0.00000   124:
        0   0.00000   0.00000   125:
        0   0.00000   0.00000   126:
        0   0.00000   0.00000   127:
        0   0.00000   0.00000   128:
        0   0.00000   0.00000   129:
        0   0.00000   0.00000   130:
        0   0.00000   0.00000   131:
        0   0.00000   0.00000   132:
        0   0.00000   0.00000   133:
        0   0.00000   0.00000   134:
        0   0.00000   0.00000   135:
        0   0.00000   0.00000   136:
        0   0.00000   0.00000   137:
        0   0.00000   0.00000   138:
        0   0.00000   0.00000   139:
        0   0.00000   0.00000   140:
        0   0.00000   0.00000   141:
        0   0.00000   0.00000   142:
        0   0.00000   0.00000   143:
        0   0.00000   0.00000   144:
        0   0.00000   0.00000   145:
        0   0.00000   0.00000   146:
        0   0.00000   0.00000   147:
        0   0.00000   0.00000   148:
        0   0.00000   0.00000   149:
        0   0.00000   0.00000   150:
        0   0.00000   0.00000   151:
        0   0.00000   0.00000   152:
        0   0.00000   0.00000   153:
        0   0.00000   0.00000   154:
        0   0.00000   0.00000   155:
        0   0.00000   0.00000   156:
        0   0.00000   0.00000   157:
        0   0.00000   0.00000   158:
        0   0.00000   0.00000   159:
        0   0.00000   0.00000   160:
        0   0.00000   0.00000   161:
        0   0.00000   0.00000   162:
        0   0.00000   0.00000   163:
        0   0.00000   0.00000   164:
        0   0.00000   0.00000   165:sub plan {
        0   0.00000   0.00000   166:    my $tb = Test::More->builder;
        0   0.00000   0.00000   167:
        0   0.00000   0.00000   168:    return $tb->plan(@_);
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 199
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   169:}
        0   0.00000   0.00000   170:
        0   0.00000   0.00000   171:# This implements "use Test::More 'no_diag'"
        0   0.00000   0.00000   172:# deprecated.
        0   0.00000   0.00000   173:sub import_extra {
        0   0.00000   0.00000   174:    my $class = shift;
        0   0.00000   0.00000   175:    my $list  = shift;
        0   0.00000   0.00000   176:
        0   0.00000   0.00000   177:    my @other = ();
        0   0.00000   0.00000   178:    my $idx   = 0;
        0   0.00000   0.00000   179:    while( $idx <= $#{$list} ) {
        0   0.00000   0.00000   180:        my $item = $list->[$idx];
        0   0.00000   0.00000   181:
        0   0.00000   0.00000   182:        if( defined $item and $item eq
        0   0.00000   0.00000   183:            $class->builder->no_diag(1);
        0   0.00000   0.00000   184:        }
        0   0.00000   0.00000   185:        else {
        0   0.00000   0.00000   186:            push @other, $item;
        0   0.00000   0.00000   187:        }
        0   0.00000   0.00000   188:
        0   0.00000   0.00000   189:        $idx++;
        0   0.00000   0.00000   190:    }
        0   0.00000   0.00000   191:
        0   0.00000   0.00000   192:    @$list = @other;
        0   0.00000   0.00000   193:
        0   0.00000   0.00000   194:    return;
        0   0.00000   0.00000   195:}
        0   0.00000   0.00000   196:
        0   0.00000   0.00000   197:=over 4
        0   0.00000   0.00000   198:
        0   0.00000   0.00000   199:
        0   0.00000   0.00000   200:
        0   0.00000   0.00000   201:
        0   0.00000   0.00000   202:
        0   0.00000   0.00000   203:
        0   0.00000   0.00000   204:
        0   0.00000   0.00000   205:
        0   0.00000   0.00000   206:
        0   0.00000   0.00000   207:
        0   0.00000   0.00000   208:
        0   0.00000   0.00000   209:
        0   0.00000   0.00000   210:
        0   0.00000   0.00000   211:
        0   0.00000   0.00000   212:
        0   0.00000   0.00000   213:
        0   0.00000   0.00000   214:
        0   0.00000   0.00000   215:
        0   0.00000   0.00000   216:
        0   0.00000   0.00000   217:
        0   0.00000   0.00000   218:sub done_testing {
        0   0.00000   0.00000   219:    my $tb = Test::More->builder;
        0   0.00000   0.00000   220:    $tb->done_testing(@_);
        0   0.00000   0.00000   221:}
        0   0.00000   0.00000   222:
        0   0.00000   0.00000   223:=head2 Test names
        0   0.00000   0.00000   224:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 200
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   225:
        0   0.00000   0.00000   226:
        0   0.00000   0.00000   227:
        0   0.00000   0.00000   228:
        0   0.00000   0.00000   229:
        0   0.00000   0.00000   230:
        0   0.00000   0.00000   231:
        0   0.00000   0.00000   232:
        0   0.00000   0.00000   233:
        0   0.00000   0.00000   234:
        0   0.00000   0.00000   235:
        0   0.00000   0.00000   236:
        0   0.00000   0.00000   237:
        0   0.00000   0.00000   238:
        0   0.00000   0.00000   239:
        0   0.00000   0.00000   240:
        0   0.00000   0.00000   241:
        0   0.00000   0.00000   242:
        0   0.00000   0.00000   243:
        0   0.00000   0.00000   244:
        0   0.00000   0.00000   245:
        0   0.00000   0.00000   246:
        0   0.00000   0.00000   247:
        0   0.00000   0.00000   248:
        0   0.00000   0.00000   249:
        0   0.00000   0.00000   250:
        0   0.00000   0.00000   251:
        0   0.00000   0.00000   252:
        0   0.00000   0.00000   253:
        0   0.00000   0.00000   254:
        0   0.00000   0.00000   255:
        0   0.00000   0.00000   256:
        0   0.00000   0.00000   257:
        0   0.00000   0.00000   258:
        0   0.00000   0.00000   259:
        0   0.00000   0.00000   260:
        0   0.00000   0.00000   261:
        0   0.00000   0.00000   262:
        0   0.00000   0.00000   263:
        0   0.00000   0.00000   264:
        0   0.00000   0.00000   265:
        0   0.00000   0.00000   266:
        0   0.00000   0.00000   267:
        0   0.00000   0.00000   268:
        0   0.00000   0.00000   269:
        0   0.00000   0.00000   270:
        0   0.00000   0.00000   271:
        0   0.00000   0.00000   272:
        0   0.00000   0.00000   273:
        0   0.00000   0.00000   274:
        0   0.00000   0.00000   275:
        0   0.00000   0.00000   276:
        0   0.00000   0.00000   277:
        0   0.00000   0.00000   278:
        0   0.00000   0.00000   279:
        0   0.00000   0.00000   280:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 201
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   281:
        0   0.00000   0.00000   282:
        0   0.00000   0.00000   283:
        0   0.00000   0.00000   284:
        0   0.00000   0.00000   285:
        0   0.00000   0.00000   286:
        0   0.00000   0.00000   287:
        0   0.00000   0.00000   288:
        0   0.00000   0.00000   289:
        0   0.00000   0.00000   290:
        0   0.00000   0.00000   291:sub ok ($;$) {
        0   0.00000   0.00000   292:    my( $test, $name ) = @_;
        0   0.00000   0.00000   293:    my $tb = Test::More->builder;
        0   0.00000   0.00000   294:
        0   0.00000   0.00000   295:    return $tb->ok( $test, $name );
        0   0.00000   0.00000   296:}
        0   0.00000   0.00000   297:
        0   0.00000   0.00000   298:=item B<is>
        0   0.00000   0.00000   299:
        0   0.00000   0.00000   300:
        0   0.00000   0.00000   301:
        0   0.00000   0.00000   302:
        0   0.00000   0.00000   303:
        0   0.00000   0.00000   304:
        0   0.00000   0.00000   305:
        0   0.00000   0.00000   306:
        0   0.00000   0.00000   307:
        0   0.00000   0.00000   308:
        0   0.00000   0.00000   309:
        0   0.00000   0.00000   310:
        0   0.00000   0.00000   311:
        0   0.00000   0.00000   312:
        0   0.00000   0.00000   313:
        0   0.00000   0.00000   314:
        0   0.00000   0.00000   315:
        0   0.00000   0.00000   316:
        0   0.00000   0.00000   317:
        0   0.00000   0.00000   318:
        0   0.00000   0.00000   319:
        0   0.00000   0.00000   320:
        0   0.00000   0.00000   321:
        0   0.00000   0.00000   322:
        0   0.00000   0.00000   323:
        0   0.00000   0.00000   324:
        0   0.00000   0.00000   325:
        0   0.00000   0.00000   326:
        0   0.00000   0.00000   327:
        0   0.00000   0.00000   328:
        0   0.00000   0.00000   329:
        0   0.00000   0.00000   330:
        0   0.00000   0.00000   331:
        0   0.00000   0.00000   332:
        0   0.00000   0.00000   333:
        0   0.00000   0.00000   334:
        0   0.00000   0.00000   335:
        0   0.00000   0.00000   336:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 202
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   337:
        0   0.00000   0.00000   338:
        0   0.00000   0.00000   339:
        0   0.00000   0.00000   340:
        0   0.00000   0.00000   341:
        0   0.00000   0.00000   342:
        0   0.00000   0.00000   343:
        0   0.00000   0.00000   344:
        0   0.00000   0.00000   345:
        0   0.00000   0.00000   346:
        0   0.00000   0.00000   347:
        0   0.00000   0.00000   348:
        0   0.00000   0.00000   349:
        0   0.00000   0.00000   350:
        0   0.00000   0.00000   351:
        0   0.00000   0.00000   352:
        0   0.00000   0.00000   353:
        0   0.00000   0.00000   354:
        0   0.00000   0.00000   355:
        0   0.00000   0.00000   356:
        0   0.00000   0.00000   357:
        0   0.00000   0.00000   358:
        0   0.00000   0.00000   359:
        0   0.00000   0.00000   360:
        0   0.00000   0.00000   361:
        0   0.00000   0.00000   362:
        0   0.00000   0.00000   363:
        0   0.00000   0.00000   364:
        0   0.00000   0.00000   365:
        0   0.00000   0.00000   366:
        0   0.00000   0.00000   367:
        0   0.00000   0.00000   368:
        0   0.00000   0.00000   369:sub is ($$;$) {
        1   0.00003   0.00000   370:    my $tb = Test::More->builder;
        0   0.00000   0.00000   371:
        1   0.00000   0.00000   372:    return $tb->is_eq(@_);
        0   0.00000   0.00000   373:}
        0   0.00000   0.00000   374:
        0   0.00000   0.00000   375:sub isnt ($$;$) {
        0   0.00000   0.00000   376:    my $tb = Test::More->builder;
        0   0.00000   0.00000   377:
        0   0.00000   0.00000   378:    return $tb->isnt_eq(@_);
        0   0.00000   0.00000   379:}
        0   0.00000   0.00000   380:
        0   0.00000   0.00000   381:*isn't = \&isnt;
        0   0.00000   0.00000   382:
        0   0.00000   0.00000   383:=item B<like>
        0   0.00000   0.00000   384:
        0   0.00000   0.00000   385:
        0   0.00000   0.00000   386:
        0   0.00000   0.00000   387:
        0   0.00000   0.00000   388:
        0   0.00000   0.00000   389:
        0   0.00000   0.00000   390:
        0   0.00000   0.00000   391:
        0   0.00000   0.00000   392:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 203
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   393:
        0   0.00000   0.00000   394:
        0   0.00000   0.00000   395:
        0   0.00000   0.00000   396:
        0   0.00000   0.00000   397:
        0   0.00000   0.00000   398:
        0   0.00000   0.00000   399:
        0   0.00000   0.00000   400:
        0   0.00000   0.00000   401:
        0   0.00000   0.00000   402:
        0   0.00000   0.00000   403:
        0   0.00000   0.00000   404:
        0   0.00000   0.00000   405:
        0   0.00000   0.00000   406:
        0   0.00000   0.00000   407:
        0   0.00000   0.00000   408:
        0   0.00000   0.00000   409:
        0   0.00000   0.00000   410:
        0   0.00000   0.00000   411:
        0   0.00000   0.00000   412:
        0   0.00000   0.00000   413:sub like ($$;$) {
        0   0.00000   0.00000   414:    my $tb = Test::More->builder;
        0   0.00000   0.00000   415:
        0   0.00000   0.00000   416:    return $tb->like(@_);
        0   0.00000   0.00000   417:}
        0   0.00000   0.00000   418:
        0   0.00000   0.00000   419:=item B<unlike>
        0   0.00000   0.00000   420:
        0   0.00000   0.00000   421:
        0   0.00000   0.00000   422:
        0   0.00000   0.00000   423:
        0   0.00000   0.00000   424:
        0   0.00000   0.00000   425:
        0   0.00000   0.00000   426:
        0   0.00000   0.00000   427:
        0   0.00000   0.00000   428:sub unlike ($$;$) {
        0   0.00000   0.00000   429:    my $tb = Test::More->builder;
        0   0.00000   0.00000   430:
        0   0.00000   0.00000   431:    return $tb->unlike(@_);
        0   0.00000   0.00000   432:}
        0   0.00000   0.00000   433:
        0   0.00000   0.00000   434:=item B<cmp_ok>
        0   0.00000   0.00000   435:
        0   0.00000   0.00000   436:
        0   0.00000   0.00000   437:
        0   0.00000   0.00000   438:
        0   0.00000   0.00000   439:
        0   0.00000   0.00000   440:
        0   0.00000   0.00000   441:
        0   0.00000   0.00000   442:
        0   0.00000   0.00000   443:
        0   0.00000   0.00000   444:
        0   0.00000   0.00000   445:
        0   0.00000   0.00000   446:
        0   0.00000   0.00000   447:
        0   0.00000   0.00000   448:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 204
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   449:
        0   0.00000   0.00000   450:
        0   0.00000   0.00000   451:
        0   0.00000   0.00000   452:
        0   0.00000   0.00000   453:
        0   0.00000   0.00000   454:
        0   0.00000   0.00000   455:
        0   0.00000   0.00000   456:
        0   0.00000   0.00000   457:
        0   0.00000   0.00000   458:
        0   0.00000   0.00000   459:
        0   0.00000   0.00000   460:
        0   0.00000   0.00000   461:
        0   0.00000   0.00000   462:
        0   0.00000   0.00000   463:
        0   0.00000   0.00000   464:
        0   0.00000   0.00000   465:
        0   0.00000   0.00000   466:
        0   0.00000   0.00000   467:
        0   0.00000   0.00000   468:
        0   0.00000   0.00000   469:
        0   0.00000   0.00000   470:
        0   0.00000   0.00000   471:
        0   0.00000   0.00000   472:
        0   0.00000   0.00000   473:sub cmp_ok($$$;$) {
        0   0.00000   0.00000   474:    my $tb = Test::More->builder;
        0   0.00000   0.00000   475:
        0   0.00000   0.00000   476:    return $tb->cmp_ok(@_);
        0   0.00000   0.00000   477:}
        0   0.00000   0.00000   478:
        0   0.00000   0.00000   479:=item B<can_ok>
        0   0.00000   0.00000   480:
        0   0.00000   0.00000   481:
        0   0.00000   0.00000   482:
        0   0.00000   0.00000   483:
        0   0.00000   0.00000   484:
        0   0.00000   0.00000   485:
        0   0.00000   0.00000   486:
        0   0.00000   0.00000   487:
        0   0.00000   0.00000   488:
        0   0.00000   0.00000   489:
        0   0.00000   0.00000   490:
        0   0.00000   0.00000   491:
        0   0.00000   0.00000   492:
        0   0.00000   0.00000   493:
        0   0.00000   0.00000   494:
        0   0.00000   0.00000   495:
        0   0.00000   0.00000   496:
        0   0.00000   0.00000   497:
        0   0.00000   0.00000   498:
        0   0.00000   0.00000   499:
        0   0.00000   0.00000   500:
        0   0.00000   0.00000   501:
        0   0.00000   0.00000   502:
        0   0.00000   0.00000   503:
        0   0.00000   0.00000   504:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 205
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   505:
        0   0.00000   0.00000   506:
        0   0.00000   0.00000   507:
        0   0.00000   0.00000   508:sub can_ok ($@) {
        0   0.00000   0.00000   509:    my( $proto, @methods ) = @_;
        0   0.00000   0.00000   510:    my $class = ref $proto || $proto;
        0   0.00000   0.00000   511:    my $tb = Test::More->builder;
        0   0.00000   0.00000   512:
        0   0.00000   0.00000   513:    unless($class) {
        0   0.00000   0.00000   514:        my $ok = $tb->ok( 0, "->can(...)" );
        0   0.00000   0.00000   515:        $tb->diag('    can_ok() called with
        0   0.00000   0.00000   516:        return $ok;
        0   0.00000   0.00000   517:    }
        0   0.00000   0.00000   518:
        0   0.00000   0.00000   519:    unless(@methods) {
        0   0.00000   0.00000   520:        my $ok = $tb->ok( 0, "$class-
        0   0.00000   0.00000   521:        $tb->diag('    can_ok() called with
        0   0.00000   0.00000   522:        return $ok;
        0   0.00000   0.00000   523:    }
        0   0.00000   0.00000   524:
        0   0.00000   0.00000   525:    my @nok = ();
        0   0.00000   0.00000   526:    foreach my $method (@methods) {
        0   0.00000   0.00000   527:        $tb->_try( sub { $proto->can($method)
        0   0.00000   0.00000   528:    }
        0   0.00000   0.00000   529:
        0   0.00000   0.00000   530:    my $name = (@methods == 1) ? "$class-
        0   0.00000   0.00000   531:                                 "$class-
        0   0.00000   0.00000   532:
        0   0.00000   0.00000   533:    my $ok = $tb->ok( !@nok, $name );
        0   0.00000   0.00000   534:
        0   0.00000   0.00000   535:    $tb->diag( map "    $class->can('$_')
        0   0.00000   0.00000   536:
        0   0.00000   0.00000   537:    return $ok;
        0   0.00000   0.00000   538:}
        0   0.00000   0.00000   539:
        0   0.00000   0.00000   540:=item B<isa_ok>
        0   0.00000   0.00000   541:
        0   0.00000   0.00000   542:
        0   0.00000   0.00000   543:
        0   0.00000   0.00000   544:
        0   0.00000   0.00000   545:
        0   0.00000   0.00000   546:
        0   0.00000   0.00000   547:
        0   0.00000   0.00000   548:
        0   0.00000   0.00000   549:
        0   0.00000   0.00000   550:
        0   0.00000   0.00000   551:
        0   0.00000   0.00000   552:
        0   0.00000   0.00000   553:
        0   0.00000   0.00000   554:
        0   0.00000   0.00000   555:
        0   0.00000   0.00000   556:
        0   0.00000   0.00000   557:
        0   0.00000   0.00000   558:
        0   0.00000   0.00000   559:
        0   0.00000   0.00000   560:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 206
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   561:
        0   0.00000   0.00000   562:
        0   0.00000   0.00000   563:
        0   0.00000   0.00000   564:
        0   0.00000   0.00000   565:
        0   0.00000   0.00000   566:
        0   0.00000   0.00000   567:
        0   0.00000   0.00000   568:
        0   0.00000   0.00000   569:
        0   0.00000   0.00000   570:
        0   0.00000   0.00000   571:
        0   0.00000   0.00000   572:
        0   0.00000   0.00000   573:
        0   0.00000   0.00000   574:sub isa_ok ($$;$) {
        0   0.00000   0.00000   575:    my( $object, $class, $obj_name ) = @_;
        0   0.00000   0.00000   576:    my $tb = Test::More->builder;
        0   0.00000   0.00000   577:
        0   0.00000   0.00000   578:    my $diag;
        0   0.00000   0.00000   579:
        0   0.00000   0.00000   580:    if( !defined $object ) {
        0   0.00000   0.00000   581:        $obj_name = 'The thing' unless
        0   0.00000   0.00000   582:        $diag = "$obj_name isn't defined";
        0   0.00000   0.00000   583:    }
        0   0.00000   0.00000   584:    else {
        0   0.00000   0.00000   585:        my $whatami = ref $object ? 'object'
        0   0.00000   0.00000   586:        # We can't use UNIVERSAL::isa because
        0   0.00000   0.00000   587:        my( $rslt, $error ) = $tb->_try( sub
        0   0.00000   0.00000   588:        if($error) {
        0   0.00000   0.00000   589:            if( $error =~ /^Can't call method
        0   0.00000   0.00000   590:                # Its an unblessed reference
        0   0.00000   0.00000   591:                $obj_name = 'The reference'
        0   0.00000   0.00000   592:                if( !UNIVERSAL::isa( $object,
        0   0.00000   0.00000   593:                    my $ref = ref $object;
        0   0.00000   0.00000   594:                    $diag = "$obj_name isn't
        0   0.00000   0.00000   595:                }
        0   0.00000   0.00000   596:            }
        0   0.00000   0.00000   597:            elsif( $error =~ /Can't call
        0   0.00000   0.00000   598:                # It's something that can't
        0   0.00000   0.00000   599:                $diag = "$obj_name isn't a
        0   0.00000   0.00000   600:            }
        0   0.00000   0.00000   601:            else {
        0   0.00000   0.00000   602:                die <<WHOA;
        0   0.00000   0.00000   603:WHOA! I tried to call ->isa on your $whatami
        0   0.00000   0.00000   604:Here's the error.
        0   0.00000   0.00000   605:$error
        0   0.00000   0.00000   606:WHOA
        0   0.00000   0.00000   607:            }
        0   0.00000   0.00000   608:        }
        0   0.00000   0.00000   609:        else {
        0   0.00000   0.00000   610:            $obj_name = "The $whatami" unless
        0   0.00000   0.00000   611:            if( !$rslt ) {
        0   0.00000   0.00000   612:                my $ref = ref $object;
        0   0.00000   0.00000   613:                $diag = "$obj_name isn't a
        0   0.00000   0.00000   614:            }
        0   0.00000   0.00000   615:        }
        0   0.00000   0.00000   616:    }
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 207
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   617:
        0   0.00000   0.00000   618:    my $name = "$obj_name isa $class";
        0   0.00000   0.00000   619:    my $ok;
        0   0.00000   0.00000   620:    if($diag) {
        0   0.00000   0.00000   621:        $ok = $tb->ok( 0, $name );
        0   0.00000   0.00000   622:        $tb->diag("    $diag\n");
        0   0.00000   0.00000   623:    }
        0   0.00000   0.00000   624:    else {
        0   0.00000   0.00000   625:        $ok = $tb->ok( 1, $name );
        0   0.00000   0.00000   626:    }
        0   0.00000   0.00000   627:
        0   0.00000   0.00000   628:    return $ok;
        0   0.00000   0.00000   629:}
        0   0.00000   0.00000   630:
        0   0.00000   0.00000   631:=item B<new_ok>
        0   0.00000   0.00000   632:
        0   0.00000   0.00000   633:
        0   0.00000   0.00000   634:
        0   0.00000   0.00000   635:
        0   0.00000   0.00000   636:
        0   0.00000   0.00000   637:
        0   0.00000   0.00000   638:
        0   0.00000   0.00000   639:
        0   0.00000   0.00000   640:
        0   0.00000   0.00000   641:
        0   0.00000   0.00000   642:
        0   0.00000   0.00000   643:
        0   0.00000   0.00000   644:
        0   0.00000   0.00000   645:
        0   0.00000   0.00000   646:
        0   0.00000   0.00000   647:
        0   0.00000   0.00000   648:
        0   0.00000   0.00000   649:
        0   0.00000   0.00000   650:
        0   0.00000   0.00000   651:
        0   0.00000   0.00000   652:sub new_ok {
        0   0.00000   0.00000   653:    my $tb = Test::More->builder;
        0   0.00000   0.00000   654:    $tb->croak("new_ok() must be given at
        0   0.00000   0.00000   655:
        0   0.00000   0.00000   656:    my( $class, $args, $object_name ) = @_;
        0   0.00000   0.00000   657:
        0   0.00000   0.00000   658:    $args ||= [];
        0   0.00000   0.00000   659:    $object_name = "The object" unless
        0   0.00000   0.00000   660:
        0   0.00000   0.00000   661:    my $obj;
        0   0.00000   0.00000   662:    my( $success, $error ) = $tb->_try( sub {
        0   0.00000   0.00000   663:    if($success) {
        0   0.00000   0.00000   664:        local $Test::Builder::Level =
        0   0.00000   0.00000   665:        isa_ok $obj, $class, $object_name;
        0   0.00000   0.00000   666:    }
        0   0.00000   0.00000   667:    else {
        0   0.00000   0.00000   668:        $tb->ok( 0, "new() died" );
        0   0.00000   0.00000   669:        $tb->diag("    Error was:  $error");
        0   0.00000   0.00000   670:    }
        0   0.00000   0.00000   671:
        0   0.00000   0.00000   672:    return $obj;
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 208
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   673:}
        0   0.00000   0.00000   674:
        0   0.00000   0.00000   675:=item B<pass>
        0   0.00000   0.00000   676:
        0   0.00000   0.00000   677:
        0   0.00000   0.00000   678:
        0   0.00000   0.00000   679:
        0   0.00000   0.00000   680:
        0   0.00000   0.00000   681:
        0   0.00000   0.00000   682:
        0   0.00000   0.00000   683:
        0   0.00000   0.00000   684:
        0   0.00000   0.00000   685:
        0   0.00000   0.00000   686:
        0   0.00000   0.00000   687:
        0   0.00000   0.00000   688:
        0   0.00000   0.00000   689:
        0   0.00000   0.00000   690:
        0   0.00000   0.00000   691:
        0   0.00000   0.00000   692:sub pass (;$) {
        0   0.00000   0.00000   693:    my $tb = Test::More->builder;
        0   0.00000   0.00000   694:
        0   0.00000   0.00000   695:    return $tb->ok( 1, @_ );
        0   0.00000   0.00000   696:}
        0   0.00000   0.00000   697:
        0   0.00000   0.00000   698:sub fail (;$) {
        0   0.00000   0.00000   699:    my $tb = Test::More->builder;
        0   0.00000   0.00000   700:
        0   0.00000   0.00000   701:    return $tb->ok( 0, @_ );
        0   0.00000   0.00000   702:}
        0   0.00000   0.00000   703:
        0   0.00000   0.00000   704:=back
        0   0.00000   0.00000   705:
        0   0.00000   0.00000   706:
        0   0.00000   0.00000   707:
        0   0.00000   0.00000   708:
        0   0.00000   0.00000   709:
        0   0.00000   0.00000   710:
        0   0.00000   0.00000   711:
        0   0.00000   0.00000   712:
        0   0.00000   0.00000   713:
        0   0.00000   0.00000   714:
        0   0.00000   0.00000   715:
        0   0.00000   0.00000   716:
        0   0.00000   0.00000   717:
        0   0.00000   0.00000   718:
        0   0.00000   0.00000   719:
        0   0.00000   0.00000   720:
        0   0.00000   0.00000   721:
        0   0.00000   0.00000   722:
        0   0.00000   0.00000   723:
        0   0.00000   0.00000   724:
        0   0.00000   0.00000   725:
        0   0.00000   0.00000   726:
        0   0.00000   0.00000   727:
        0   0.00000   0.00000   728:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 209
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   729:
        0   0.00000   0.00000   730:
        0   0.00000   0.00000   731:
        0   0.00000   0.00000   732:
        0   0.00000   0.00000   733:
        0   0.00000   0.00000   734:
        0   0.00000   0.00000   735:
        0   0.00000   0.00000   736:
        0   0.00000   0.00000   737:
        0   0.00000   0.00000   738:
        0   0.00000   0.00000   739:
        0   0.00000   0.00000   740:
        0   0.00000   0.00000   741:
        0   0.00000   0.00000   742:
        0   0.00000   0.00000   743:
        0   0.00000   0.00000   744:
        0   0.00000   0.00000   745:
        0   0.00000   0.00000   746:
        0   0.00000   0.00000   747:
        0   0.00000   0.00000   748:
        0   0.00000   0.00000   749:
        0   0.00000   0.00000   750:
        0   0.00000   0.00000   751:
        0   0.00000   0.00000   752:
        0   0.00000   0.00000   753:
        0   0.00000   0.00000   754:
        0   0.00000   0.00000   755:sub use_ok ($;@) {
        0   0.00000   0.00000   756:    my( $module, @imports ) = @_;
        0   0.00000   0.00000   757:    @imports = () unless @imports;
        0   0.00000   0.00000   758:    my $tb = Test::More->builder;
        0   0.00000   0.00000   759:
        0   0.00000   0.00000   760:    my( $pack, $filename, $line ) = caller;
        0   0.00000   0.00000   761:
        0   0.00000   0.00000   762:    my $code;
        0   0.00000   0.00000   763:    if( @imports == 1 and $imports[0] =~
        0   0.00000   0.00000   764:        # probably a version check.  Perl
        0   0.00000   0.00000   765:        # for it to work with non-Exporter
        0   0.00000   0.00000   766:        $code = <<USE;
        0   0.00000   0.00000   767:package $pack;
        0   0.00000   0.00000   768:use $module $imports[0];
        0   0.00000   0.00000   769:1;
        0   0.00000   0.00000   770:USE
        0   0.00000   0.00000   771:    }
        0   0.00000   0.00000   772:    else {
        0   0.00000   0.00000   773:        $code = <<USE;
        0   0.00000   0.00000   774:package $pack;
        0   0.00000   0.00000   775:use $module \@{\$args[0]};
        0   0.00000   0.00000   776:1;
        0   0.00000   0.00000   777:USE
        0   0.00000   0.00000   778:    }
        0   0.00000   0.00000   779:
        0   0.00000   0.00000   780:    my( $eval_result, $eval_error ) = _eval(
        0   0.00000   0.00000   781:    my $ok = $tb->ok( $eval_result, "use
        0   0.00000   0.00000   782:
        0   0.00000   0.00000   783:    unless($ok) {
        0   0.00000   0.00000   784:        chomp $eval_error;
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 210
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   785:        $@ =~ s{^BEGIN failed--compilation
        0   0.00000   0.00000   786:                {BEGIN failed--compilation
        0   0.00000   0.00000   787:        $tb->diag(<<DIAGNOSTIC);
        0   0.00000   0.00000   788:    Tried to use '$module'.
        0   0.00000   0.00000   789:    Error:  $eval_error
        0   0.00000   0.00000   790:DIAGNOSTIC
        0   0.00000   0.00000   791:
        0   0.00000   0.00000   792:    }
        0   0.00000   0.00000   793:
        0   0.00000   0.00000   794:    return $ok;
        0   0.00000   0.00000   795:}
        0   0.00000   0.00000   796:
        0   0.00000   0.00000   797:sub _eval {
        0   0.00000   0.00000   798:    my( $code, @args ) = @_;
        0   0.00000   0.00000   799:
        0   0.00000   0.00000   800:    # Work around oddities surrounding
        0   0.00000   0.00000   801:    # storing it.
        0   0.00000   0.00000   802:    my( $sigdie, $eval_result, $eval_error );
        0   0.00000   0.00000   803:    {
        0   0.00000   0.00000   804:        local( $@, $!, $SIG{__DIE__} );    #
        0   0.00000   0.00000   805:        $eval_result = eval $code;
        0   0.00000   0.00000   806:        $eval_error  = $@;
        0   0.00000   0.00000   807:        $sigdie      = $SIG{__DIE__} ||
        0   0.00000   0.00000   808:    }
        0   0.00000   0.00000   809:    # make sure that $code got a chance to
        0   0.00000   0.00000   810:    $SIG{__DIE__} = $sigdie if defined
        0   0.00000   0.00000   811:
        0   0.00000   0.00000   812:    return( $eval_result, $eval_error );
        0   0.00000   0.00000   813:}
        0   0.00000   0.00000   814:
        0   0.00000   0.00000   815:=item B<require_ok>
        0   0.00000   0.00000   816:
        0   0.00000   0.00000   817:
        0   0.00000   0.00000   818:
        0   0.00000   0.00000   819:
        0   0.00000   0.00000   820:
        0   0.00000   0.00000   821:
        0   0.00000   0.00000   822:
        0   0.00000   0.00000   823:
        0   0.00000   0.00000   824:sub require_ok ($) {
        0   0.00000   0.00000   825:    my($module) = shift;
        0   0.00000   0.00000   826:    my $tb = Test::More->builder;
        0   0.00000   0.00000   827:
        0   0.00000   0.00000   828:    my $pack = caller;
        0   0.00000   0.00000   829:
        0   0.00000   0.00000   830:    # Try to deterine if we've been given a
        0   0.00000   0.00000   831:    # Module names must be barewords, files
        0   0.00000   0.00000   832:    $module = qq['$module'] unless
        0   0.00000   0.00000   833:
        0   0.00000   0.00000   834:    my $code = <<REQUIRE;
        0   0.00000   0.00000   835:package $pack;
        0   0.00000   0.00000   836:require $module;
        0   0.00000   0.00000   837:1;
        0   0.00000   0.00000   838:REQUIRE
        0   0.00000   0.00000   839:
        0   0.00000   0.00000   840:    my( $eval_result, $eval_error ) =
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 211
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   841:    my $ok = $tb->ok( $eval_result, "require
        0   0.00000   0.00000   842:
        0   0.00000   0.00000   843:    unless($ok) {
        0   0.00000   0.00000   844:        chomp $eval_error;
        0   0.00000   0.00000   845:        $tb->diag(<<DIAGNOSTIC);
        0   0.00000   0.00000   846:    Tried to require '$module'.
        0   0.00000   0.00000   847:    Error:  $eval_error
        0   0.00000   0.00000   848:DIAGNOSTIC
        0   0.00000   0.00000   849:
        0   0.00000   0.00000   850:    }
        0   0.00000   0.00000   851:
        0   0.00000   0.00000   852:    return $ok;
        0   0.00000   0.00000   853:}
        0   0.00000   0.00000   854:
        0   0.00000   0.00000   855:sub _is_module_name {
        0   0.00000   0.00000   856:    my $module = shift;
        0   0.00000   0.00000   857:
        0   0.00000   0.00000   858:    # Module names start with a letter.
        0   0.00000   0.00000   859:    # End with an alphanumeric.
        0   0.00000   0.00000   860:    # The rest is an alphanumeric or ::
        0   0.00000   0.00000   861:    $module =~ s/\b::\b//g;
        0   0.00000   0.00000   862:
        0   0.00000   0.00000   863:    return $module =~ /^[a-zA-Z]\w*$/ ? 1 :
        0   0.00000   0.00000   864:}
        0   0.00000   0.00000   865:
        0   0.00000   0.00000   866:=back
        0   0.00000   0.00000   867:
        0   0.00000   0.00000   868:
        0   0.00000   0.00000   869:
        0   0.00000   0.00000   870:
        0   0.00000   0.00000   871:
        0   0.00000   0.00000   872:
        0   0.00000   0.00000   873:
        0   0.00000   0.00000   874:
        0   0.00000   0.00000   875:
        0   0.00000   0.00000   876:
        0   0.00000   0.00000   877:
        0   0.00000   0.00000   878:
        0   0.00000   0.00000   879:
        0   0.00000   0.00000   880:
        0   0.00000   0.00000   881:
        0   0.00000   0.00000   882:
        0   0.00000   0.00000   883:
        0   0.00000   0.00000   884:
        0   0.00000   0.00000   885:
        0   0.00000   0.00000   886:
        0   0.00000   0.00000   887:
        0   0.00000   0.00000   888:
        0   0.00000   0.00000   889:
        0   0.00000   0.00000   890:
        0   0.00000   0.00000   891:
        0   0.00000   0.00000   892:
        0   0.00000   0.00000   893:
        0   0.00000   0.00000   894:
        0   0.00000   0.00000   895:
        0   0.00000   0.00000   896:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 212
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   897:
        0   0.00000   0.00000   898:
        0   0.00000   0.00000   899:
        0   0.00000   0.00000   900:
        0   0.00000   0.00000   901:our( @Data_Stack, %Refs_Seen );
        0   0.00000   0.00000   902:my $DNE = bless [], 'Does::Not::Exist';
        0   0.00000   0.00000   903:
        0   0.00000   0.00000   904:sub _dne {
        0   0.00000   0.00000   905:    return ref $_[0] eq ref $DNE;
        0   0.00000   0.00000   906:}
        0   0.00000   0.00000   907:
        0   0.00000   0.00000   908:## no critic
        0   0.00000   0.00000   909:sub is_deeply {
        0   0.00000   0.00000   910:    my $tb = Test::More->builder;
        0   0.00000   0.00000   911:
        0   0.00000   0.00000   912:    unless( @_ == 2 or @_ == 3 ) {
        0   0.00000   0.00000   913:        my $msg = <<'WARNING';
        0   0.00000   0.00000   914:is_deeply() takes two or three args, you gave
        0   0.00000   0.00000   915:This usually means you passed an array or
        0   0.00000   0.00000   916:of a reference to it
        0   0.00000   0.00000   917:WARNING
        0   0.00000   0.00000   918:        chop $msg;    # clip off newline so
        0   0.00000   0.00000   919:
        0   0.00000   0.00000   920:        _carp sprintf $msg, scalar @_;
        0   0.00000   0.00000   921:
        0   0.00000   0.00000   922:        return $tb->ok(0);
        0   0.00000   0.00000   923:    }
        0   0.00000   0.00000   924:
        0   0.00000   0.00000   925:    my( $got, $expected, $name ) = @_;
        0   0.00000   0.00000   926:
        0   0.00000   0.00000   927:    $tb->_unoverload_str( \$expected, \$got
        0   0.00000   0.00000   928:
        0   0.00000   0.00000   929:    my $ok;
        0   0.00000   0.00000   930:    if( !ref $got and !ref $expected ) {    #
        0   0.00000   0.00000   931:        $ok = $tb->is_eq( $got, $expected,
        0   0.00000   0.00000   932:    }
        0   0.00000   0.00000   933:    elsif( !ref $got xor !ref $expected ) {
        0   0.00000   0.00000   934:        $ok = $tb->ok( 0, $name );
        0   0.00000   0.00000   935:        $tb->diag( _format_stack({ vals => [
        0   0.00000   0.00000   936:    }
        0   0.00000   0.00000   937:    else {
        0   0.00000   0.00000   938:        local @Data_Stack = ();
        0   0.00000   0.00000   939:        if( _deep_check( $got, $expected ) )
        0   0.00000   0.00000   940:            $ok = $tb->ok( 1, $name );
        0   0.00000   0.00000   941:        }
        0   0.00000   0.00000   942:        else {
        0   0.00000   0.00000   943:            $ok = $tb->ok( 0, $name );
        0   0.00000   0.00000   944:            $tb->diag(
        0   0.00000   0.00000   945:        }
        0   0.00000   0.00000   946:    }
        0   0.00000   0.00000   947:
        0   0.00000   0.00000   948:    return $ok;
        0   0.00000   0.00000   949:}
        0   0.00000   0.00000   950:
        0   0.00000   0.00000   951:sub _format_stack {
        0   0.00000   0.00000   952:    my(@Stack) = @_;
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 213
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   953:
        0   0.00000   0.00000   954:    my $var       = '$FOO';
        0   0.00000   0.00000   955:    my $did_arrow = 0;
        0   0.00000   0.00000   956:    foreach my $entry (@Stack) {
        0   0.00000   0.00000   957:        my $type = $entry->{type} || '';
        0   0.00000   0.00000   958:        my $idx = $entry->{'idx'};
        0   0.00000   0.00000   959:        if( $type eq 'HASH' ) {
        0   0.00000   0.00000   960:            $var .= "->" unless $did_arrow++;
        0   0.00000   0.00000   961:            $var .= "{$idx}";
        0   0.00000   0.00000   962:        }
        0   0.00000   0.00000   963:        elsif( $type eq 'ARRAY' ) {
        0   0.00000   0.00000   964:            $var .= "->" unless $did_arrow++;
        0   0.00000   0.00000   965:            $var .= "[$idx]";
        0   0.00000   0.00000   966:        }
        0   0.00000   0.00000   967:        elsif( $type eq 'REF' ) {
        0   0.00000   0.00000   968:            $var = "\${$var}";
        0   0.00000   0.00000   969:        }
        0   0.00000   0.00000   970:    }
        0   0.00000   0.00000   971:
        0   0.00000   0.00000   972:    my @vals = @{ $Stack[-1]{vals} }[ 0, 1 ];
        0   0.00000   0.00000   973:    my @vars = ();
        0   0.00000   0.00000   974:    ( $vars[0] = $var ) =~ s/\$FOO/
        0   0.00000   0.00000   975:    ( $vars[1] = $var ) =~
        0   0.00000   0.00000   976:
        0   0.00000   0.00000   977:    my $out = "Structures begin differing
        0   0.00000   0.00000   978:    foreach my $idx ( 0 .. $#vals ) {
        0   0.00000   0.00000   979:        my $val = $vals[$idx];
        0   0.00000   0.00000   980:        $vals[$idx]
        0   0.00000   0.00000   981:          = !defined $val ? 'undef'
        0   0.00000   0.00000   982:          : _dne($val)    ? "Does not exist"
        0   0.00000   0.00000   983:          : ref $val      ? "$val"
        0   0.00000   0.00000   984:          :                 "'$val'";
        0   0.00000   0.00000   985:    }
        0   0.00000   0.00000   986:
        0   0.00000   0.00000   987:    $out .= "$vars[0] = $vals[0]\n";
        0   0.00000   0.00000   988:    $out .= "$vars[1] = $vals[1]\n";
        0   0.00000   0.00000   989:
        0   0.00000   0.00000   990:    $out =~ s/^/    /msg;
        0   0.00000   0.00000   991:    return $out;
        0   0.00000   0.00000   992:}
        0   0.00000   0.00000   993:
        0   0.00000   0.00000   994:sub _type {
        0   0.00000   0.00000   995:    my $thing = shift;
        0   0.00000   0.00000   996:
        0   0.00000   0.00000   997:    return '' if !ref $thing;
        0   0.00000   0.00000   998:
        0   0.00000   0.00000   999:    for my $type (qw(ARRAY HASH REF SCALAR
        0   0.00000   0.00000  1000:        return $type if UNIVERSAL::isa(
        0   0.00000   0.00000  1001:    }
        0   0.00000   0.00000  1002:
        0   0.00000   0.00000  1003:    return '';
        0   0.00000   0.00000  1004:}
        0   0.00000   0.00000  1005:
        0   0.00000   0.00000  1006:=back
        0   0.00000   0.00000  1007:
        0   0.00000   0.00000  1008:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 214
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1009:
        0   0.00000   0.00000  1010:
        0   0.00000   0.00000  1011:
        0   0.00000   0.00000  1012:
        0   0.00000   0.00000  1013:
        0   0.00000   0.00000  1014:
        0   0.00000   0.00000  1015:
        0   0.00000   0.00000  1016:
        0   0.00000   0.00000  1017:
        0   0.00000   0.00000  1018:
        0   0.00000   0.00000  1019:
        0   0.00000   0.00000  1020:
        0   0.00000   0.00000  1021:
        0   0.00000   0.00000  1022:
        0   0.00000   0.00000  1023:
        0   0.00000   0.00000  1024:
        0   0.00000   0.00000  1025:
        0   0.00000   0.00000  1026:
        0   0.00000   0.00000  1027:
        0   0.00000   0.00000  1028:
        0   0.00000   0.00000  1029:
        0   0.00000   0.00000  1030:
        0   0.00000   0.00000  1031:
        0   0.00000   0.00000  1032:
        0   0.00000   0.00000  1033:
        0   0.00000   0.00000  1034:
        0   0.00000   0.00000  1035:
        0   0.00000   0.00000  1036:
        0   0.00000   0.00000  1037:
        0   0.00000   0.00000  1038:
        0   0.00000   0.00000  1039:
        0   0.00000   0.00000  1040:
        0   0.00000   0.00000  1041:
        0   0.00000   0.00000  1042:
        0   0.00000   0.00000  1043:
        0   0.00000   0.00000  1044:
        0   0.00000   0.00000  1045:
        0   0.00000   0.00000  1046:
        0   0.00000   0.00000  1047:
        0   0.00000   0.00000  1048:
        0   0.00000   0.00000  1049:
        0   0.00000   0.00000  1050:
        0   0.00000   0.00000  1051:
        0   0.00000   0.00000  1052:
        0   0.00000   0.00000  1053:
        0   0.00000   0.00000  1054:
        0   0.00000   0.00000  1055:
        0   0.00000   0.00000  1056:
        0   0.00000   0.00000  1057:
        0   0.00000   0.00000  1058:
        0   0.00000   0.00000  1059:
        0   0.00000   0.00000  1060:
        0   0.00000   0.00000  1061:sub diag {
        0   0.00000   0.00000  1062:    return Test::More->builder->diag(@_);
        0   0.00000   0.00000  1063:}
        0   0.00000   0.00000  1064:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 215
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1065:sub note {
        0   0.00000   0.00000  1066:    return Test::More->builder->note(@_);
        0   0.00000   0.00000  1067:}
        0   0.00000   0.00000  1068:
        0   0.00000   0.00000  1069:=item B<explain>
        0   0.00000   0.00000  1070:
        0   0.00000   0.00000  1071:
        0   0.00000   0.00000  1072:
        0   0.00000   0.00000  1073:
        0   0.00000   0.00000  1074:
        0   0.00000   0.00000  1075:
        0   0.00000   0.00000  1076:
        0   0.00000   0.00000  1077:
        0   0.00000   0.00000  1078:
        0   0.00000   0.00000  1079:
        0   0.00000   0.00000  1080:
        0   0.00000   0.00000  1081:
        0   0.00000   0.00000  1082:
        0   0.00000   0.00000  1083:
        0   0.00000   0.00000  1084:
        0   0.00000   0.00000  1085:
        0   0.00000   0.00000  1086:
        0   0.00000   0.00000  1087:sub explain {
        0   0.00000   0.00000  1088:    return Test::More->builder->explain(@_);
        0   0.00000   0.00000  1089:}
        0   0.00000   0.00000  1090:
        0   0.00000   0.00000  1091:=back
        0   0.00000   0.00000  1092:
        0   0.00000   0.00000  1093:
        0   0.00000   0.00000  1094:
        0   0.00000   0.00000  1095:
        0   0.00000   0.00000  1096:
        0   0.00000   0.00000  1097:
        0   0.00000   0.00000  1098:
        0   0.00000   0.00000  1099:
        0   0.00000   0.00000  1100:
        0   0.00000   0.00000  1101:
        0   0.00000   0.00000  1102:
        0   0.00000   0.00000  1103:
        0   0.00000   0.00000  1104:
        0   0.00000   0.00000  1105:
        0   0.00000   0.00000  1106:
        0   0.00000   0.00000  1107:
        0   0.00000   0.00000  1108:
        0   0.00000   0.00000  1109:
        0   0.00000   0.00000  1110:
        0   0.00000   0.00000  1111:
        0   0.00000   0.00000  1112:
        0   0.00000   0.00000  1113:
        0   0.00000   0.00000  1114:
        0   0.00000   0.00000  1115:
        0   0.00000   0.00000  1116:
        0   0.00000   0.00000  1117:
        0   0.00000   0.00000  1118:
        0   0.00000   0.00000  1119:
        0   0.00000   0.00000  1120:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 216
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1121:
        0   0.00000   0.00000  1122:
        0   0.00000   0.00000  1123:
        0   0.00000   0.00000  1124:
        0   0.00000   0.00000  1125:
        0   0.00000   0.00000  1126:
        0   0.00000   0.00000  1127:
        0   0.00000   0.00000  1128:
        0   0.00000   0.00000  1129:
        0   0.00000   0.00000  1130:
        0   0.00000   0.00000  1131:
        0   0.00000   0.00000  1132:
        0   0.00000   0.00000  1133:
        0   0.00000   0.00000  1134:
        0   0.00000   0.00000  1135:
        0   0.00000   0.00000  1136:
        0   0.00000   0.00000  1137:
        0   0.00000   0.00000  1138:
        0   0.00000   0.00000  1139:
        0   0.00000   0.00000  1140:
        0   0.00000   0.00000  1141:
        0   0.00000   0.00000  1142:
        0   0.00000   0.00000  1143:
        0   0.00000   0.00000  1144:
        0   0.00000   0.00000  1145:
        0   0.00000   0.00000  1146:
        0   0.00000   0.00000  1147:
        0   0.00000   0.00000  1148:
        0   0.00000   0.00000  1149:
        0   0.00000   0.00000  1150:
        0   0.00000   0.00000  1151:
        0   0.00000   0.00000  1152:
        0   0.00000   0.00000  1153:## no critic
        0   0.00000   0.00000  1154:sub skip {
        0   0.00000   0.00000  1155:    my( $why, $how_many ) = @_;
        0   0.00000   0.00000  1156:    my $tb = Test::More->builder;
        0   0.00000   0.00000  1157:
        0   0.00000   0.00000  1158:    unless( defined $how_many ) {
        0   0.00000   0.00000  1159:        # $how_many can only be avoided when
        0   0.00000   0.00000  1160:        _carp "skip() needs to know
        0   0.00000   0.00000  1161:          unless $tb->has_plan eq 'no_plan';
        0   0.00000   0.00000  1162:        $how_many = 1;
        0   0.00000   0.00000  1163:    }
        0   0.00000   0.00000  1164:
        0   0.00000   0.00000  1165:    if( defined $how_many and $how_many =~
        0   0.00000   0.00000  1166:        _carp
        0   0.00000   0.00000  1167:          "skip() was passed a non-numeric
        0   0.00000   0.00000  1168:        $how_many = 1;
        0   0.00000   0.00000  1169:    }
        0   0.00000   0.00000  1170:
        0   0.00000   0.00000  1171:    for( 1 .. $how_many ) {
        0   0.00000   0.00000  1172:        $tb->skip($why);
        0   0.00000   0.00000  1173:    }
        0   0.00000   0.00000  1174:
        0   0.00000   0.00000  1175:    no warnings 'exiting';
        0   0.00000   0.00000  1176:    last SKIP;
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 217
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1177:}
        0   0.00000   0.00000  1178:
        0   0.00000   0.00000  1179:=item B<TODO: BLOCK>
        0   0.00000   0.00000  1180:
        0   0.00000   0.00000  1181:
        0   0.00000   0.00000  1182:
        0   0.00000   0.00000  1183:
        0   0.00000   0.00000  1184:
        0   0.00000   0.00000  1185:
        0   0.00000   0.00000  1186:
        0   0.00000   0.00000  1187:
        0   0.00000   0.00000  1188:
        0   0.00000   0.00000  1189:
        0   0.00000   0.00000  1190:
        0   0.00000   0.00000  1191:
        0   0.00000   0.00000  1192:
        0   0.00000   0.00000  1193:
        0   0.00000   0.00000  1194:
        0   0.00000   0.00000  1195:
        0   0.00000   0.00000  1196:
        0   0.00000   0.00000  1197:
        0   0.00000   0.00000  1198:
        0   0.00000   0.00000  1199:
        0   0.00000   0.00000  1200:
        0   0.00000   0.00000  1201:
        0   0.00000   0.00000  1202:
        0   0.00000   0.00000  1203:
        0   0.00000   0.00000  1204:
        0   0.00000   0.00000  1205:
        0   0.00000   0.00000  1206:
        0   0.00000   0.00000  1207:
        0   0.00000   0.00000  1208:
        0   0.00000   0.00000  1209:
        0   0.00000   0.00000  1210:
        0   0.00000   0.00000  1211:
        0   0.00000   0.00000  1212:
        0   0.00000   0.00000  1213:
        0   0.00000   0.00000  1214:
        0   0.00000   0.00000  1215:
        0   0.00000   0.00000  1216:
        0   0.00000   0.00000  1217:
        0   0.00000   0.00000  1218:
        0   0.00000   0.00000  1219:
        0   0.00000   0.00000  1220:
        0   0.00000   0.00000  1221:
        0   0.00000   0.00000  1222:
        0   0.00000   0.00000  1223:
        0   0.00000   0.00000  1224:
        0   0.00000   0.00000  1225:
        0   0.00000   0.00000  1226:
        0   0.00000   0.00000  1227:
        0   0.00000   0.00000  1228:
        0   0.00000   0.00000  1229:
        0   0.00000   0.00000  1230:
        0   0.00000   0.00000  1231:
        0   0.00000   0.00000  1232:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 218
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1233:
        0   0.00000   0.00000  1234:
        0   0.00000   0.00000  1235:
        0   0.00000   0.00000  1236:
        0   0.00000   0.00000  1237:
        0   0.00000   0.00000  1238:
        0   0.00000   0.00000  1239:
        0   0.00000   0.00000  1240:sub todo_skip {
        0   0.00000   0.00000  1241:    my( $why, $how_many ) = @_;
        0   0.00000   0.00000  1242:    my $tb = Test::More->builder;
        0   0.00000   0.00000  1243:
        0   0.00000   0.00000  1244:    unless( defined $how_many ) {
        0   0.00000   0.00000  1245:        # $how_many can only be avoided when
        0   0.00000   0.00000  1246:        _carp "todo_skip() needs to know
        0   0.00000   0.00000  1247:          unless $tb->has_plan eq 'no_plan';
        0   0.00000   0.00000  1248:        $how_many = 1;
        0   0.00000   0.00000  1249:    }
        0   0.00000   0.00000  1250:
        0   0.00000   0.00000  1251:    for( 1 .. $how_many ) {
        0   0.00000   0.00000  1252:        $tb->todo_skip($why);
        0   0.00000   0.00000  1253:    }
        0   0.00000   0.00000  1254:
        0   0.00000   0.00000  1255:    no warnings 'exiting';
        0   0.00000   0.00000  1256:    last TODO;
        0   0.00000   0.00000  1257:}
        0   0.00000   0.00000  1258:
        0   0.00000   0.00000  1259:=item When do I use SKIP vs. TODO?
        0   0.00000   0.00000  1260:
        0   0.00000   0.00000  1261:
        0   0.00000   0.00000  1262:
        0   0.00000   0.00000  1263:
        0   0.00000   0.00000  1264:
        0   0.00000   0.00000  1265:
        0   0.00000   0.00000  1266:
        0   0.00000   0.00000  1267:
        0   0.00000   0.00000  1268:
        0   0.00000   0.00000  1269:
        0   0.00000   0.00000  1270:
        0   0.00000   0.00000  1271:
        0   0.00000   0.00000  1272:
        0   0.00000   0.00000  1273:
        0   0.00000   0.00000  1274:
        0   0.00000   0.00000  1275:
        0   0.00000   0.00000  1276:
        0   0.00000   0.00000  1277:
        0   0.00000   0.00000  1278:
        0   0.00000   0.00000  1279:
        0   0.00000   0.00000  1280:
        0   0.00000   0.00000  1281:
        0   0.00000   0.00000  1282:
        0   0.00000   0.00000  1283:
        0   0.00000   0.00000  1284:
        0   0.00000   0.00000  1285:
        0   0.00000   0.00000  1286:
        0   0.00000   0.00000  1287:
        0   0.00000   0.00000  1288:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 219
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1289:
        0   0.00000   0.00000  1290:
        0   0.00000   0.00000  1291:
        0   0.00000   0.00000  1292:
        0   0.00000   0.00000  1293:
        0   0.00000   0.00000  1294:
        0   0.00000   0.00000  1295:sub BAIL_OUT {
        0   0.00000   0.00000  1296:    my $reason = shift;
        0   0.00000   0.00000  1297:    my $tb     = Test::More->builder;
        0   0.00000   0.00000  1298:
        0   0.00000   0.00000  1299:    $tb->BAIL_OUT($reason);
        0   0.00000   0.00000  1300:}
        0   0.00000   0.00000  1301:
        0   0.00000   0.00000  1302:=back
        0   0.00000   0.00000  1303:
        0   0.00000   0.00000  1304:
        0   0.00000   0.00000  1305:
        0   0.00000   0.00000  1306:
        0   0.00000   0.00000  1307:
        0   0.00000   0.00000  1308:
        0   0.00000   0.00000  1309:
        0   0.00000   0.00000  1310:
        0   0.00000   0.00000  1311:
        0   0.00000   0.00000  1312:
        0   0.00000   0.00000  1313:
        0   0.00000   0.00000  1314:
        0   0.00000   0.00000  1315:
        0   0.00000   0.00000  1316:
        0   0.00000   0.00000  1317:
        0   0.00000   0.00000  1318:
        0   0.00000   0.00000  1319:
        0   0.00000   0.00000  1320:
        0   0.00000   0.00000  1321:
        0   0.00000   0.00000  1322:
        0   0.00000   0.00000  1323:
        0   0.00000   0.00000  1324:
        0   0.00000   0.00000  1325:
        0   0.00000   0.00000  1326:
        0   0.00000   0.00000  1327:
        0   0.00000   0.00000  1328:
        0   0.00000   0.00000  1329:
        0   0.00000   0.00000  1330:
        0   0.00000   0.00000  1331:
        0   0.00000   0.00000  1332:
        0   0.00000   0.00000  1333:
        0   0.00000   0.00000  1334:#'#
        0   0.00000   0.00000  1335:sub eq_array {
        0   0.00000   0.00000  1336:    local @Data_Stack = ();
        0   0.00000   0.00000  1337:    _deep_check(@_);
        0   0.00000   0.00000  1338:}
        0   0.00000   0.00000  1339:
        0   0.00000   0.00000  1340:sub _eq_array {
        0   0.00000   0.00000  1341:    my( $a1, $a2 ) = @_;
        0   0.00000   0.00000  1342:
        0   0.00000   0.00000  1343:    if( grep _type($_) ne 'ARRAY', $a1, $a2 )
        0   0.00000   0.00000  1344:        warn "eq_array passed a non-array
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 220
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1345:        return 0;
        0   0.00000   0.00000  1346:    }
        0   0.00000   0.00000  1347:
        0   0.00000   0.00000  1348:    return 1 if $a1 eq $a2;
        0   0.00000   0.00000  1349:
        0   0.00000   0.00000  1350:    my $ok = 1;
        0   0.00000   0.00000  1351:    my $max = $#$a1 > $#$a2 ? $#$a1 : $#$a2;
        0   0.00000   0.00000  1352:    for( 0 .. $max ) {
        0   0.00000   0.00000  1353:        my $e1 = $_ > $#$a1 ? $DNE : $a1-
        0   0.00000   0.00000  1354:        my $e2 = $_ > $#$a2 ? $DNE : $a2-
        0   0.00000   0.00000  1355:
        0   0.00000   0.00000  1356:        push @Data_Stack, { type => 'ARRAY',
        0   0.00000   0.00000  1357:        $ok = _deep_check( $e1, $e2 );
        0   0.00000   0.00000  1358:        pop @Data_Stack if $ok;
        0   0.00000   0.00000  1359:
        0   0.00000   0.00000  1360:        last unless $ok;
        0   0.00000   0.00000  1361:    }
        0   0.00000   0.00000  1362:
        0   0.00000   0.00000  1363:    return $ok;
        0   0.00000   0.00000  1364:}
        0   0.00000   0.00000  1365:
        0   0.00000   0.00000  1366:sub _deep_check {
        0   0.00000   0.00000  1367:    my( $e1, $e2 ) = @_;
        0   0.00000   0.00000  1368:    my $tb = Test::More->builder;
        0   0.00000   0.00000  1369:
        0   0.00000   0.00000  1370:    my $ok = 0;
        0   0.00000   0.00000  1371:
        0   0.00000   0.00000  1372:    # Effectively turn %Refs_Seen into a
        0   0.00000   0.00000  1373:    # the same referenced used twice (such as
        0   0.00000   0.00000  1374:    # circular.
        0   0.00000   0.00000  1375:    local %Refs_Seen = %Refs_Seen;
        0   0.00000   0.00000  1376:
        0   0.00000   0.00000  1377:    {
        0   0.00000   0.00000  1378:        # Quiet uninitialized value warnings
        0   0.00000   0.00000  1379:        no warnings 'uninitialized';
        0   0.00000   0.00000  1380:
        0   0.00000   0.00000  1381:        $tb->_unoverload_str( \$e1, \$e2 );
        0   0.00000   0.00000  1382:
        0   0.00000   0.00000  1383:        # Either they're both references or
        0   0.00000   0.00000  1384:        my $same_ref = !( !ref $e1 xor !ref
        0   0.00000   0.00000  1385:        my $not_ref = ( !ref $e1 and !ref $e2
        0   0.00000   0.00000  1386:
        0   0.00000   0.00000  1387:        if( defined $e1 xor defined $e2 ) {
        0   0.00000   0.00000  1388:            $ok = 0;
        0   0.00000   0.00000  1389:        }
        0   0.00000   0.00000  1390:        elsif( !defined $e1 and !defined $e2
        0   0.00000   0.00000  1391:            # Shortcut if they're both
        0   0.00000   0.00000  1392:            $ok = 1;
        0   0.00000   0.00000  1393:        }
        0   0.00000   0.00000  1394:        elsif( _dne($e1) xor _dne($e2) ) {
        0   0.00000   0.00000  1395:            $ok = 0;
        0   0.00000   0.00000  1396:        }
        0   0.00000   0.00000  1397:        elsif( $same_ref and( $e1 eq $e2 ) )
        0   0.00000   0.00000  1398:            $ok = 1;
        0   0.00000   0.00000  1399:        }
        0   0.00000   0.00000  1400:        elsif($not_ref) {
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 221
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1401:            push @Data_Stack, { type => '',
        0   0.00000   0.00000  1402:            $ok = 0;
        0   0.00000   0.00000  1403:        }
        0   0.00000   0.00000  1404:        else {
        0   0.00000   0.00000  1405:            if( $Refs_Seen{$e1} ) {
        0   0.00000   0.00000  1406:                return $Refs_Seen{$e1} eq
        0   0.00000   0.00000  1407:            }
        0   0.00000   0.00000  1408:            else {
        0   0.00000   0.00000  1409:                $Refs_Seen{$e1} = "$e2";
        0   0.00000   0.00000  1410:            }
        0   0.00000   0.00000  1411:
        0   0.00000   0.00000  1412:            my $type = _type($e1);
        0   0.00000   0.00000  1413:            $type = 'DIFFERENT' unless
        0   0.00000   0.00000  1414:
        0   0.00000   0.00000  1415:            if( $type eq 'DIFFERENT' ) {
        0   0.00000   0.00000  1416:                push @Data_Stack, { type =>
        0   0.00000   0.00000  1417:                $ok = 0;
        0   0.00000   0.00000  1418:            }
        0   0.00000   0.00000  1419:            elsif( $type eq 'ARRAY' ) {
        0   0.00000   0.00000  1420:                $ok = _eq_array( $e1, $e2 );
        0   0.00000   0.00000  1421:            }
        0   0.00000   0.00000  1422:            elsif( $type eq 'HASH' ) {
        0   0.00000   0.00000  1423:                $ok = _eq_hash( $e1, $e2 );
        0   0.00000   0.00000  1424:            }
        0   0.00000   0.00000  1425:            elsif( $type eq 'REF' ) {
        0   0.00000   0.00000  1426:                push @Data_Stack, { type =>
        0   0.00000   0.00000  1427:                $ok = _deep_check( $$e1, $$e2
        0   0.00000   0.00000  1428:                pop @Data_Stack if $ok;
        0   0.00000   0.00000  1429:            }
        0   0.00000   0.00000  1430:            elsif( $type eq 'SCALAR' ) {
        0   0.00000   0.00000  1431:                push @Data_Stack, { type =>
        0   0.00000   0.00000  1432:                $ok = _deep_check( $$e1, $$e2
        0   0.00000   0.00000  1433:                pop @Data_Stack if $ok;
        0   0.00000   0.00000  1434:            }
        0   0.00000   0.00000  1435:            elsif($type) {
        0   0.00000   0.00000  1436:                push @Data_Stack, { type =>
        0   0.00000   0.00000  1437:                $ok = 0;
        0   0.00000   0.00000  1438:            }
        0   0.00000   0.00000  1439:            else {
        0   0.00000   0.00000  1440:                _whoa( 1, "No type in
        0   0.00000   0.00000  1441:            }
        0   0.00000   0.00000  1442:        }
        0   0.00000   0.00000  1443:    }
        0   0.00000   0.00000  1444:
        0   0.00000   0.00000  1445:    return $ok;
        0   0.00000   0.00000  1446:}
        0   0.00000   0.00000  1447:
        0   0.00000   0.00000  1448:sub _whoa {
        0   0.00000   0.00000  1449:    my( $check, $desc ) = @_;
        0   0.00000   0.00000  1450:    if($check) {
        0   0.00000   0.00000  1451:        die <<"WHOA";
        0   0.00000   0.00000  1452:WHOA!  $desc
        0   0.00000   0.00000  1453:This should never happen!  Please contact the
        0   0.00000   0.00000  1454:WHOA
        0   0.00000   0.00000  1455:    }
        0   0.00000   0.00000  1456:}
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 222
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1457:
        0   0.00000   0.00000  1458:=item B<eq_hash>
        0   0.00000   0.00000  1459:
        0   0.00000   0.00000  1460:
        0   0.00000   0.00000  1461:
        0   0.00000   0.00000  1462:
        0   0.00000   0.00000  1463:
        0   0.00000   0.00000  1464:
        0   0.00000   0.00000  1465:
        0   0.00000   0.00000  1466:
        0   0.00000   0.00000  1467:sub eq_hash {
        0   0.00000   0.00000  1468:    local @Data_Stack = ();
        0   0.00000   0.00000  1469:    return _deep_check(@_);
        0   0.00000   0.00000  1470:}
        0   0.00000   0.00000  1471:
        0   0.00000   0.00000  1472:sub _eq_hash {
        0   0.00000   0.00000  1473:    my( $a1, $a2 ) = @_;
        0   0.00000   0.00000  1474:
        0   0.00000   0.00000  1475:    if( grep _type($_) ne 'HASH', $a1, $a2 )
        0   0.00000   0.00000  1476:        warn "eq_hash passed a non-hash ref";
        0   0.00000   0.00000  1477:        return 0;
        0   0.00000   0.00000  1478:    }
        0   0.00000   0.00000  1479:
        0   0.00000   0.00000  1480:    return 1 if $a1 eq $a2;
        0   0.00000   0.00000  1481:
        0   0.00000   0.00000  1482:    my $ok = 1;
        0   0.00000   0.00000  1483:    my $bigger = keys %$a1 > keys %$a2 ? $a1
        0   0.00000   0.00000  1484:    foreach my $k ( keys %$bigger ) {
        0   0.00000   0.00000  1485:        my $e1 = exists $a1->{$k} ? $a1->{$k}
        0   0.00000   0.00000  1486:        my $e2 = exists $a2->{$k} ? $a2->{$k}
        0   0.00000   0.00000  1487:
        0   0.00000   0.00000  1488:        push @Data_Stack, { type => 'HASH',
        0   0.00000   0.00000  1489:        $ok = _deep_check( $e1, $e2 );
        0   0.00000   0.00000  1490:        pop @Data_Stack if $ok;
        0   0.00000   0.00000  1491:
        0   0.00000   0.00000  1492:        last unless $ok;
        0   0.00000   0.00000  1493:    }
        0   0.00000   0.00000  1494:
        0   0.00000   0.00000  1495:    return $ok;
        0   0.00000   0.00000  1496:}
        0   0.00000   0.00000  1497:
        0   0.00000   0.00000  1498:=item B<eq_set>
        0   0.00000   0.00000  1499:
        0   0.00000   0.00000  1500:
        0   0.00000   0.00000  1501:
        0   0.00000   0.00000  1502:
        0   0.00000   0.00000  1503:
        0   0.00000   0.00000  1504:
        0   0.00000   0.00000  1505:
        0   0.00000   0.00000  1506:
        0   0.00000   0.00000  1507:
        0   0.00000   0.00000  1508:
        0   0.00000   0.00000  1509:
        0   0.00000   0.00000  1510:
        0   0.00000   0.00000  1511:
        0   0.00000   0.00000  1512:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 223
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1513:
        0   0.00000   0.00000  1514:
        0   0.00000   0.00000  1515:
        0   0.00000   0.00000  1516:
        0   0.00000   0.00000  1517:
        0   0.00000   0.00000  1518:
        0   0.00000   0.00000  1519:
        0   0.00000   0.00000  1520:
        0   0.00000   0.00000  1521:
        0   0.00000   0.00000  1522:
        0   0.00000   0.00000  1523:
        0   0.00000   0.00000  1524:sub eq_set {
        0   0.00000   0.00000  1525:    my( $a1, $a2 ) = @_;
        0   0.00000   0.00000  1526:    return 0 unless @$a1 == @$a2;
        0   0.00000   0.00000  1527:
        0   0.00000   0.00000  1528:    no warnings 'uninitialized';
        0   0.00000   0.00000  1529:
        0   0.00000   0.00000  1530:    # It really doesn't matter how we sort
        0   0.00000   0.00000  1531:    # sorted with the same algorithm.
        0   0.00000   0.00000  1532:    #
        0   0.00000   0.00000  1533:    # Ensure that references are not
        0   0.00000   0.00000  1534:    # string containing the reference.
        0   0.00000   0.00000  1535:    #
        0   0.00000   0.00000  1536:    # Have to inline the sort routine due to
        0   0.00000   0.00000  1537:    # See [rt.cpan.org 6782]
        0   0.00000   0.00000  1538:    #
        0   0.00000   0.00000  1539:    # I don't know how references would be
        0   0.00000   0.00000  1540:    # them.  This means eq_set doesn't really
        0   0.00000   0.00000  1541:    return eq_array(
        0   0.00000   0.00000  1542:        [ grep( ref, @$a1 ), sort( grep(
        0   0.00000   0.00000  1543:        [ grep( ref, @$a2 ), sort( grep(
        0   0.00000   0.00000  1544:    );
        0   0.00000   0.00000  1545:}
        0   0.00000   0.00000  1546:
        0   0.00000   0.00000  1547:=back
        0   0.00000   0.00000  1548:
        0   0.00000   0.00000  1549:
        0   0.00000   0.00000  1550:
        0   0.00000   0.00000  1551:
        0   0.00000   0.00000  1552:
        0   0.00000   0.00000  1553:
        0   0.00000   0.00000  1554:
        0   0.00000   0.00000  1555:
        0   0.00000   0.00000  1556:
        0   0.00000   0.00000  1557:
        0   0.00000   0.00000  1558:
        0   0.00000   0.00000  1559:
        0   0.00000   0.00000  1560:
        0   0.00000   0.00000  1561:
        0   0.00000   0.00000  1562:
        0   0.00000   0.00000  1563:
        0   0.00000   0.00000  1564:
        0   0.00000   0.00000  1565:
        0   0.00000   0.00000  1566:
        0   0.00000   0.00000  1567:
        0   0.00000   0.00000  1568:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 224
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1569:
        0   0.00000   0.00000  1570:
        0   0.00000   0.00000  1571:
        0   0.00000   0.00000  1572:
        0   0.00000   0.00000  1573:
        0   0.00000   0.00000  1574:
        0   0.00000   0.00000  1575:
        0   0.00000   0.00000  1576:
        0   0.00000   0.00000  1577:
        0   0.00000   0.00000  1578:
        0   0.00000   0.00000  1579:
        0   0.00000   0.00000  1580:
        0   0.00000   0.00000  1581:
        0   0.00000   0.00000  1582:
        0   0.00000   0.00000  1583:
        0   0.00000   0.00000  1584:
        0   0.00000   0.00000  1585:
        0   0.00000   0.00000  1586:
        0   0.00000   0.00000  1587:
        0   0.00000   0.00000  1588:
        0   0.00000   0.00000  1589:
        0   0.00000   0.00000  1590:
        0   0.00000   0.00000  1591:
        0   0.00000   0.00000  1592:
        0   0.00000   0.00000  1593:
        0   0.00000   0.00000  1594:
        0   0.00000   0.00000  1595:
        0   0.00000   0.00000  1596:
        0   0.00000   0.00000  1597:
        0   0.00000   0.00000  1598:
        0   0.00000   0.00000  1599:
        0   0.00000   0.00000  1600:
        0   0.00000   0.00000  1601:
        0   0.00000   0.00000  1602:
        0   0.00000   0.00000  1603:
        0   0.00000   0.00000  1604:
        0   0.00000   0.00000  1605:
        0   0.00000   0.00000  1606:
        0   0.00000   0.00000  1607:
        0   0.00000   0.00000  1608:
        0   0.00000   0.00000  1609:
        0   0.00000   0.00000  1610:
        0   0.00000   0.00000  1611:
        0   0.00000   0.00000  1612:
        0   0.00000   0.00000  1613:
        0   0.00000   0.00000  1614:
        0   0.00000   0.00000  1615:
        0   0.00000   0.00000  1616:
        0   0.00000   0.00000  1617:
        0   0.00000   0.00000  1618:
        0   0.00000   0.00000  1619:
        0   0.00000   0.00000  1620:
        0   0.00000   0.00000  1621:
        0   0.00000   0.00000  1622:
        0   0.00000   0.00000  1623:
        0   0.00000   0.00000  1624:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 225
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1625:
        0   0.00000   0.00000  1626:
        0   0.00000   0.00000  1627:
        0   0.00000   0.00000  1628:
        0   0.00000   0.00000  1629:
        0   0.00000   0.00000  1630:
        0   0.00000   0.00000  1631:
        0   0.00000   0.00000  1632:
        0   0.00000   0.00000  1633:
        0   0.00000   0.00000  1634:
        0   0.00000   0.00000  1635:
        0   0.00000   0.00000  1636:
        0   0.00000   0.00000  1637:
        0   0.00000   0.00000  1638:
        0   0.00000   0.00000  1639:
        0   0.00000   0.00000  1640:
        0   0.00000   0.00000  1641:
        0   0.00000   0.00000  1642:
        0   0.00000   0.00000  1643:
        0   0.00000   0.00000  1644:
        0   0.00000   0.00000  1645:
        0   0.00000   0.00000  1646:
        0   0.00000   0.00000  1647:
        0   0.00000   0.00000  1648:
        0   0.00000   0.00000  1649:
        0   0.00000   0.00000  1650:
        0   0.00000   0.00000  1651:
        0   0.00000   0.00000  1652:
        0   0.00000   0.00000  1653:
        0   0.00000   0.00000  1654:
        0   0.00000   0.00000  1655:
        0   0.00000   0.00000  1656:
        0   0.00000   0.00000  1657:
        0   0.00000   0.00000  1658:
        0   0.00000   0.00000  1659:
        0   0.00000   0.00000  1660:
        0   0.00000   0.00000  1661:
        0   0.00000   0.00000  1662:
        0   0.00000   0.00000  1663:
        0   0.00000   0.00000  1664:
        0   0.00000   0.00000  1665:
        0   0.00000   0.00000  1666:
        0   0.00000   0.00000  1667:
        0   0.00000   0.00000  1668:
        0   0.00000   0.00000  1669:
        0   0.00000   0.00000  1670:
        0   0.00000   0.00000  1671:
        0   0.00000   0.00000  1672:
        0   0.00000   0.00000  1673:
        0   0.00000   0.00000  1674:
        0   0.00000   0.00000  1675:
        0   0.00000   0.00000  1676:
        0   0.00000   0.00000  1677:
        0   0.00000   0.00000  1678:
        0   0.00000   0.00000  1679:
        0   0.00000   0.00000  1680:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 226
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1681:
        0   0.00000   0.00000  1682:
        0   0.00000   0.00000  1683:
        0   0.00000   0.00000  1684:
        0   0.00000   0.00000  1685:
        0   0.00000   0.00000  1686:
        0   0.00000   0.00000  1687:
        0   0.00000   0.00000  1688:
        0   0.00000   0.00000  1689:
        0   0.00000   0.00000  1690:
        0   0.00000   0.00000  1691:
        0   0.00000   0.00000  1692:
        0   0.00000   0.00000  1693:
        0   0.00000   0.00000  1694:
        0   0.00000   0.00000  1695:
        0   0.00000   0.00000  1696:
        0   0.00000   0.00000  1697:
        0   0.00000   0.00000  1698:
        0   0.00000   0.00000  1699:
        0   0.00000   0.00000  1700:
        0   0.00000   0.00000  1701:
        0   0.00000   0.00000  1702:
        0   0.00000   0.00000  1703:
        0   0.00000   0.00000  1704:
        0   0.00000   0.00000  1705:
        0   0.00000   0.00000  1706:
        0   0.00000   0.00000  1707:
        0   0.00000   0.00000  1708:
        0   0.00000   0.00000  1709:
        0   0.00000   0.00000  1710:
        0   0.00000   0.00000  1711:
        0   0.00000   0.00000  1712:
        0   0.00000   0.00000  1713:
        0   0.00000   0.00000  1714:
        0   0.00000   0.00000  1715:
        0   0.00000   0.00000  1716:
        0   0.00000   0.00000  1717:
        0   0.00000   0.00000  1718:
        0   0.00000   0.00000  1719:
        0   0.00000   0.00000  1720:
        0   0.00000   0.00000  1721:
        0   0.00000   0.00000  1722:
        0   0.00000   0.00000  1723:
        0   0.00000   0.00000  1724:
        0   0.00000   0.00000  1725:
        0   0.00000   0.00000  1726:
        0   0.00000   0.00000  1727:
        0   0.00000   0.00000  1728:
        0   0.00000   0.00000  1729:
        0   0.00000   0.00000  1730:
        0   0.00000   0.00000  1731:
        0   0.00000   0.00000  1732:
        0   0.00000   0.00000  1733:
        0   0.00000   0.00000  1734:
        0   0.00000   0.00000  1735:
        0   0.00000   0.00000  1736:
           ================ SmallProf version 2.02 ================
             Profile of /usr/local/share/perl/5.10.0/Test/More.pm      Page 227
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000  1737:1;
           ================ SmallProf version 2.02 ================
                 Profile of /usr/share/perl/5.10/AutoLoader.pm         Page 228
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:package AutoLoader;
        0   0.00000   0.00000     2:
        0   0.00000   0.00000     3:use strict;
        0   0.00000   0.00000     4:use 5.006_001;
        0   0.00000   0.00000     5:
        0   0.00000   0.00000     6:our($VERSION, $AUTOLOAD);
        0   0.00000   0.00000     7:
        0   0.00000   0.00000     8:my $is_dosish;
        0   0.00000   0.00000     9:my $is_epoc;
        0   0.00000   0.00000    10:my $is_vms;
        0   0.00000   0.00000    11:my $is_macos;
        0   0.00000   0.00000    12:
        0   0.00000   0.00000    13:BEGIN {
        0   0.00000   0.00000    14:    $is_dosish = $^O eq 'dos' || $^O eq 'os2'
        0   0.00000   0.00000    15:    $is_epoc = $^O eq 'epoc';
        0   0.00000   0.00000    16:    $is_vms = $^O eq 'VMS';
        0   0.00000   0.00000    17:    $is_macos = $^O eq 'MacOS';
        0   0.00000   0.00000    18:    $VERSION = '5.63';
        0   0.00000   0.00000    19:}
        0   0.00000   0.00000    20:
        0   0.00000   0.00000    21:AUTOLOAD {
        1   0.00000   0.00000    22:    my $sub = $AUTOLOAD;
        1   0.00000   0.00000    23:    my $filename = AutoLoader::find_filename(
        0   0.00000   0.00000    24:
        1   0.00000   0.00000    25:    my $save = $@;
        1   0.00001   0.00000    26:    local $!; # Do not munge the value.
        3   0.00007   0.00000    27:    eval { local $SIG{__DIE__}; require
        1   0.00000   0.00000    28:    if ($@) {
        1   0.00000   0.00000    29: if (substr($sub,-9) eq '::DESTROY') {
        0   0.00000   0.00000    30:     no strict 'refs';
      829   0.00001   0.01000    31:     *$sub = sub {};
        1   0.00000   0.00000    32:     $@ = undef;
        0   0.00000   0.00000    33: } elsif ($@ =~ /^Can't locate/) {
        0   0.00000   0.00000    34:     # The load might just have failed
        0   0.00000   0.00000    35:     # long for some old SVR3 systems which
        0   0.00000   0.00000    36:     # If we can successfully truncate a long
        0   0.00000   0.00000    37:     # There is a slight risk that we could
        0   0.00000   0.00000    38:     # but autosplit should have warned about
        0   0.00000   0.00000    39:     if ($filename =~
        0   0.00000   0.00000    40:  eval { local $SIG{__DIE__}; require
        0   0.00000   0.00000    41:     }
        0   0.00000   0.00000    42: }
        1   0.00000   0.00000    43: if ($@){
        0   0.00000   0.00000    44:     $@ =~ s/ at .*\n//;
        0   0.00000   0.00000    45:     my $error = $@;
        0   0.00000   0.00000    46:     require Carp;
        0   0.00000   0.00000    47:     Carp::croak($error);
        0   0.00000   0.00000    48: }
        0   0.00000   0.00000    49:    }
        1   0.00000   0.00000    50:    $@ = $save;
        1   0.00000   0.00000    51:    goto &$sub;
        0   0.00000   0.00000    52:}
        0   0.00000   0.00000    53:
        0   0.00000   0.00000    54:sub can {
        0   0.00000   0.00000    55:    my ($self, $method) = @_;
        0   0.00000   0.00000    56:
           ================ SmallProf version 2.02 ================
                 Profile of /usr/share/perl/5.10/AutoLoader.pm         Page 229
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000    57:    my $parent          = $self->SUPER::can(
        0   0.00000   0.00000    58:    return $parent if $parent;
        0   0.00000   0.00000    59:
        0   0.00000   0.00000    60:    my $package         = ref( $self ) ||
        0   0.00000   0.00000    61:    my $filename        =
        0   0.00000   0.00000    62:    local $@;
        0   0.00000   0.00000    63:    return unless eval { require $filename };
        0   0.00000   0.00000    64:
        0   0.00000   0.00000    65:    no strict 'refs';
        0   0.00000   0.00000    66:    return \&{ $package . '::' . $method };
        0   0.00000   0.00000    67:}
        0   0.00000   0.00000    68:
        0   0.00000   0.00000    69:sub find_filename {
        1   0.00000   0.00000    70:    my $sub = shift;
        1   0.00000   0.00000    71:    my $filename;
        0   0.00000   0.00000    72:    # Braces used to preserve $1 et al.
        0   0.00000   0.00000    73:    {
        0   0.00000   0.00000    74: # Try to find the autoloaded file from the
        0   0.00000   0.00000    75: # name of the sub. e.g., if the sub needed
        0   0.00000   0.00000    76: # Getopt::Long::GetOptions(), then
        0   0.00000   0.00000    77: # something like
        0   0.00000   0.00000    78: # autoload file is
        0   0.00000   0.00000    79: #
        0   0.00000   0.00000    80: # However, if @INC is a relative path, this
        0   0.00000   0.00000    81: # for example, @INC = ('lib'), then
        0   0.00000   0.00000    82: # 'lib/Getopt/Long.pm', and we want to
        0   0.00000   0.00000    83: # 'auto/Getopt/Long/GetOptions.al' (without
        0   0.00000   0.00000    84: # In this case, we simple prepend the
        0   0.00000   0.00000    85: # C<require> take care of the searching for
        0   0.00000   0.00000    86:
        2   0.00001   0.00000    87: my ($pkg,$func) = ($sub =~
        1   0.00000   0.00000    88: $pkg =~ s#::#/#g;
        1   0.00000   0.00000    89: if (defined($filename = $INC{"$pkg.pm"})) {
        1   0.00000   0.00000    90:     if ($is_macos) {
        0   0.00000   0.00000    91:  $pkg =~ tr#/#:#;
        0   0.00000   0.00000    92:  $filename = undef
        0   0.00000   0.00000    93:    unless $filename =~
        0   0.00000   0.00000    94:     } else {
        1   0.00007   0.00000    95:  $filename = undef
        0   0.00000   0.00000    96:    unless $filename =~
        0   0.00000   0.00000    97:     }
        0   0.00000   0.00000    98:
        0   0.00000   0.00000    99:     # if the file exists, then make sure
        0   0.00000   0.00000   100:     # a fully anchored path (i.e either
        0   0.00000   0.00000   101:     # or './lib/auto/foo/bar.al'.  This
        0   0.00000   0.00000   102:     # (and failing) to find the
        0   0.00000   0.00000   103:     # looked for 'lib/lib/auto/foo/bar.al',
        0   0.00000   0.00000   104:
        1   0.00000   0.00000   105:     if (defined $filename and -r $filename)
        0   0.00000   0.00000   106:  unless ($filename =~ m|^/|s) {
        0   0.00000   0.00000   107:      if ($is_dosish) {
        0   0.00000   0.00000   108:   unless ($filename =~ m{^([a-z]:)?[\\/]}is)
        0   0.00000   0.00000   109:       if ($^O ne 'NetWare') {
        0   0.00000   0.00000   110:    $filename = "./$filename";
        0   0.00000   0.00000   111:       } else {
        0   0.00000   0.00000   112:    $filename = "$filename";
           ================ SmallProf version 2.02 ================
                 Profile of /usr/share/perl/5.10/AutoLoader.pm         Page 230
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   113:       }
        0   0.00000   0.00000   114:   }
        0   0.00000   0.00000   115:      }
        0   0.00000   0.00000   116:      elsif ($is_epoc) {
        0   0.00000   0.00000   117:   unless ($filename =~ m{^([a-
        0   0.00000   0.00000   118:        $filename = "./$filename";
        0   0.00000   0.00000   119:   }
        0   0.00000   0.00000   120:      }
        0   0.00000   0.00000   121:      elsif ($is_vms) {
        0   0.00000   0.00000   122:   # XXX todo by VMSmiths
        0   0.00000   0.00000   123:   $filename = "./$filename";
        0   0.00000   0.00000   124:      }
        0   0.00000   0.00000   125:      elsif (!$is_macos) {
        0   0.00000   0.00000   126:   $filename = "./$filename";
        0   0.00000   0.00000   127:      }
        0   0.00000   0.00000   128:  }
        0   0.00000   0.00000   129:     }
        0   0.00000   0.00000   130:     else {
        1   0.00000   0.00000   131:  $filename = undef;
        0   0.00000   0.00000   132:     }
        0   0.00000   0.00000   133: }
        1   0.00000   0.00000   134: unless (defined $filename) {
        0   0.00000   0.00000   135:     # let C<require> do the searching
        1   0.00000   0.00000   136:     $filename = "auto/$sub.al";
        1   0.00000   0.00000   137:     $filename =~ s#::#/#g;
        0   0.00000   0.00000   138: }
        0   0.00000   0.00000   139:    }
        1   0.00000   0.00000   140:    return $filename;
        0   0.00000   0.00000   141:}
        0   0.00000   0.00000   142:
        0   0.00000   0.00000   143:sub import {
        0   0.00000   0.00000   144:    my $pkg = shift;
        0   0.00000   0.00000   145:    my $callpkg = caller;
        0   0.00000   0.00000   146:
        0   0.00000   0.00000   147:    #
        0   0.00000   0.00000   148:    # Export symbols, but not by accident of
        0   0.00000   0.00000   149:    #
        0   0.00000   0.00000   150:
        0   0.00000   0.00000   151:    if ($pkg eq 'AutoLoader') {
        0   0.00000   0.00000   152: if ( @_ and $_[0] =~ /^&?AUTOLOAD$/ ) {
        0   0.00000   0.00000   153:     no strict 'refs';
        0   0.00000   0.00000   154:     *{ $callpkg . '::AUTOLOAD' } =
        0   0.00000   0.00000   155:     *{ $callpkg . '::can'      } = \&can;
        0   0.00000   0.00000   156: }
        0   0.00000   0.00000   157:    }
        0   0.00000   0.00000   158:
        0   0.00000   0.00000   159:    #
        0   0.00000   0.00000   160:    # Try to find the autosplit index file.
        0   0.00000   0.00000   161:    # is POSIX, then $INC{POSIX.pm} is
        0   0.00000   0.00000   162:    # '/usr/local/lib/perl5/POSIX.pm', and
        0   0.00000   0.00000   163:    #
        0   0.00000   0.00000   164:    #
        0   0.00000   0.00000   165:    # However, if @INC is a relative path,
        0   0.00000   0.00000   166:    # for example, @INC = ('lib'), then
        0   0.00000   0.00000   167:    # $INC{POSIX.pm} is 'lib/POSIX.pm', and
        0   0.00000   0.00000   168:    # 'auto/POSIX/autosplit.ix' (without the
           ================ SmallProf version 2.02 ================
                 Profile of /usr/share/perl/5.10/AutoLoader.pm         Page 231
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000   169:    #
        0   0.00000   0.00000   170:
        0   0.00000   0.00000   171:    (my $calldir = $callpkg) =~ s#::#/#g;
        0   0.00000   0.00000   172:    my $path = $INC{$calldir . '.pm'};
        0   0.00000   0.00000   173:    if (defined($path)) {
        0   0.00000   0.00000   174: # Try absolute path name.
        0   0.00000   0.00000   175: if ($is_macos) {
        0   0.00000   0.00000   176:     (my $malldir = $calldir) =~ tr#/#:#;
        0   0.00000   0.00000   177:     $path =~
        0   0.00000   0.00000   178: } else {
        0   0.00000   0.00000   179:     $path =~
        0   0.00000   0.00000   180: }
        0   0.00000   0.00000   181:
        0   0.00000   0.00000   182: eval { require $path; };
        0   0.00000   0.00000   183: # If that failed, try relative path with
        0   0.00000   0.00000   184: if ($@) {
        0   0.00000   0.00000   185:     $path ="auto/$calldir/autosplit.ix";
        0   0.00000   0.00000   186:     eval { require $path; };
        0   0.00000   0.00000   187: }
        0   0.00000   0.00000   188: if ($@) {
        0   0.00000   0.00000   189:     my $error = $@;
        0   0.00000   0.00000   190:     require Carp;
        0   0.00000   0.00000   191:     Carp::carp($error);
        0   0.00000   0.00000   192: }
        0   0.00000   0.00000   193:    }
        0   0.00000   0.00000   194:}
        0   0.00000   0.00000   195:
        0   0.00000   0.00000   196:sub unimport {
        0   0.00000   0.00000   197:    my $callpkg = caller;
        0   0.00000   0.00000   198:
        0   0.00000   0.00000   199:    no strict 'refs';
        0   0.00000   0.00000   200:
        0   0.00000   0.00000   201:    for my $exported (qw( AUTOLOAD can )) {
        0   0.00000   0.00000   202: my $symname = $callpkg . '::' . $exported;
        0   0.00000   0.00000   203: undef *{ $symname } if \&{ $symname } == \&{
        0   0.00000   0.00000   204: *{ $symname } = \&{ $symname };
        0   0.00000   0.00000   205:    }
        0   0.00000   0.00000   206:}
        0   0.00000   0.00000   207:
        0   0.00000   0.00000   208:1;
        0   0.00000   0.00000   209:
        0   0.00000   0.00000   210:__END__
           ================ SmallProf version 2.02 ================
            Profile of cmp_ok [from testProtocolParser.pl line 53]     Page 232
       =================================================================
    count wall tm  cpu time line
        1   0.00001   0.00000     1:The code for cmp_ok [from
           ================ SmallProf version 2.02 ================
                       Profile of testProtocolParser.pl                Page 233
       =================================================================
    count wall tm  cpu time line
        0   0.00000   0.00000     1:#!/usr/bin/perl
        0   0.00000   0.00000     2:
        0   0.00000   0.00000     3:use strict;
        0   0.00000   0.00000     4:use warnings;
        0   0.00000   0.00000     5:use Test::More tests => 1;
        0   0.00000   0.00000     6:use lib "../modules";
        0   0.00000   0.00000     7:use ProtocolParser;
        0   0.00000   0.00000     8:use Utilities;
        0   0.00000   0.00000     9:use File;
        0   0.00000   0.00000    10:use Configuration;
        0   0.00000   0.00000    11:use Topology;
        0   0.00000   0.00000    12:
        0   0.00000   0.00000    13:sub prepareProtocolParser {
        4   0.00000   0.00000    14:    my $name = shift;
        4   0.00000   0.00000    15:    my $run = shift;
        4   0.01882   0.01000    16:    my @fileNames = `ls simulate60sec-
        4   0.00000   0.00000    17:    my @files = ();
        4   0.00000   0.00000    18:    foreach my $fileName (@fileNames) {
       62   0.00000   0.00000    19:        next if not $fileName =~ /\.dump$/;
       62   0.00006   0.01000    20:        push(@files,new File("simulate60sec-
        0   0.00000   0.00000    21:    }
        0   0.00000   0.00000    22:
        4   0.00000   0.00000    23:    my $parser = new ProtocolParser(new
        0   0.00000   0.00000    24:
        4   0.00401   0.00000    25:    return ($parser,@files);
        0   0.00000   0.00000    26:}
        0   0.00000   0.00000    27:
        0   0.00000   0.00000    28:sub testClass {
        1   0.00000   0.00000    29:    my ($parser,@files) =
        1   0.00010   0.00000    30:    my @packets = @{$parser->{PACKETS}};
        1   0.00022   0.00000    31:    print "there are ".@packets." packets\n";
        1   0.00000   0.00000    32:    my $timestamp = $parser-
        1   0.00000   0.00000    33:    print "time =
        0   0.00000   0.00000    34:}
        0   0.00000   0.00000    35:
        0   0.00000   0.00000    36:sub testGetLastTimeStamp{
        1   0.00000   0.00000    37:    my %testHash = ("internet2_new" =>
        0   0.00000   0.00000    38:
        0   0.00000   0.00000    39:
        1   0.00000   0.00000    40:    my $ok = 1;
        1   0.00000   0.00000    41:    foreach my $name (keys %testHash) {
        3   0.00000   0.00000    42:        my ($parser) =
        3   0.00001   0.00000    43:        my $timestamp = $parser-
        3   0.00000   0.00000    44:        print "time =
        3   0.00000   0.00000    45:        $ok = 0 if($timestamp !=
        0   0.00000   0.00000    46:    }
        1   0.00001   0.00000    47:    return $ok;
        0   0.00000   0.00000    48:}
        0   0.00000   0.00000    49:
        1   0.00000   0.00000    50:my $config = new Configuration();
        0   0.00000   0.00000    51:
        1   0.00000   0.00000    52:testClass;
        1   0.00000   0.00000    53:is(testGetLastTimeStamp(),1,"getLastTimeStamp
